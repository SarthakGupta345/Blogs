
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model BlockedUser
 * 
 */
export type BlockedUser = $Result.DefaultSelection<Prisma.$BlockedUserPayload>
/**
 * Model ReportUser
 * 
 */
export type ReportUser = $Result.DefaultSelection<Prisma.$ReportUserPayload>
/**
 * Model ReadHistory
 * 
 */
export type ReadHistory = $Result.DefaultSelection<Prisma.$ReadHistoryPayload>
/**
 * Model Blog
 * 
 */
export type Blog = $Result.DefaultSelection<Prisma.$BlogPayload>
/**
 * Model BlogLike
 * 
 */
export type BlogLike = $Result.DefaultSelection<Prisma.$BlogLikePayload>
/**
 * Model BlogDisLike
 * 
 */
export type BlogDisLike = $Result.DefaultSelection<Prisma.$BlogDisLikePayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model LikeComment
 * 
 */
export type LikeComment = $Result.DefaultSelection<Prisma.$LikeCommentPayload>
/**
 * Model DisLikeComment
 * 
 */
export type DisLikeComment = $Result.DefaultSelection<Prisma.$DisLikeCommentPayload>
/**
 * Model CommentReply
 * 
 */
export type CommentReply = $Result.DefaultSelection<Prisma.$CommentReplyPayload>
/**
 * Model SavedBlog
 * 
 */
export type SavedBlog = $Result.DefaultSelection<Prisma.$SavedBlogPayload>
/**
 * Model Membership
 * 
 */
export type Membership = $Result.DefaultSelection<Prisma.$MembershipPayload>
/**
 * Model ReportBlog
 * 
 */
export type ReportBlog = $Result.DefaultSelection<Prisma.$ReportBlogPayload>
/**
 * Model CommentNotification
 * 
 */
export type CommentNotification = $Result.DefaultSelection<Prisma.$CommentNotificationPayload>
/**
 * Model MessageNotification
 * 
 */
export type MessageNotification = $Result.DefaultSelection<Prisma.$MessageNotificationPayload>
/**
 * Model LikeNotification
 * 
 */
export type LikeNotification = $Result.DefaultSelection<Prisma.$LikeNotificationPayload>
/**
 * Model inboxes
 * 
 */
export type inboxes = $Result.DefaultSelection<Prisma.$inboxesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MemberShipType: {
  YEARLY: 'YEARLY',
  MONTHLY: 'MONTHLY'
};

export type MemberShipType = (typeof MemberShipType)[keyof typeof MemberShipType]


export const ReportMessage: {
  SPAM: 'SPAM',
  HATE: 'HATE',
  VIOLENCE: 'VIOLENCE',
  SEXUAL: 'SEXUAL',
  POLITICAL: 'POLITICAL',
  RACISM: 'RACISM',
  COPYRIGHT: 'COPYRIGHT',
  INAPPROPRIATE: 'INAPPROPRIATE',
  OTHER: 'OTHER'
};

export type ReportMessage = (typeof ReportMessage)[keyof typeof ReportMessage]

}

export type MemberShipType = $Enums.MemberShipType

export const MemberShipType: typeof $Enums.MemberShipType

export type ReportMessage = $Enums.ReportMessage

export const ReportMessage: typeof $Enums.ReportMessage

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blockedUser`: Exposes CRUD operations for the **BlockedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedUsers
    * const blockedUsers = await prisma.blockedUser.findMany()
    * ```
    */
  get blockedUser(): Prisma.BlockedUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportUser`: Exposes CRUD operations for the **ReportUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportUsers
    * const reportUsers = await prisma.reportUser.findMany()
    * ```
    */
  get reportUser(): Prisma.ReportUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.readHistory`: Exposes CRUD operations for the **ReadHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReadHistories
    * const readHistories = await prisma.readHistory.findMany()
    * ```
    */
  get readHistory(): Prisma.ReadHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogLike`: Exposes CRUD operations for the **BlogLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogLikes
    * const blogLikes = await prisma.blogLike.findMany()
    * ```
    */
  get blogLike(): Prisma.BlogLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogDisLike`: Exposes CRUD operations for the **BlogDisLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogDisLikes
    * const blogDisLikes = await prisma.blogDisLike.findMany()
    * ```
    */
  get blogDisLike(): Prisma.BlogDisLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.likeComment`: Exposes CRUD operations for the **LikeComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LikeComments
    * const likeComments = await prisma.likeComment.findMany()
    * ```
    */
  get likeComment(): Prisma.LikeCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disLikeComment`: Exposes CRUD operations for the **DisLikeComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisLikeComments
    * const disLikeComments = await prisma.disLikeComment.findMany()
    * ```
    */
  get disLikeComment(): Prisma.DisLikeCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentReply`: Exposes CRUD operations for the **CommentReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentReplies
    * const commentReplies = await prisma.commentReply.findMany()
    * ```
    */
  get commentReply(): Prisma.CommentReplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedBlog`: Exposes CRUD operations for the **SavedBlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedBlogs
    * const savedBlogs = await prisma.savedBlog.findMany()
    * ```
    */
  get savedBlog(): Prisma.SavedBlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.membership.findMany()
    * ```
    */
  get membership(): Prisma.MembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportBlog`: Exposes CRUD operations for the **ReportBlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportBlogs
    * const reportBlogs = await prisma.reportBlog.findMany()
    * ```
    */
  get reportBlog(): Prisma.ReportBlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentNotification`: Exposes CRUD operations for the **CommentNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentNotifications
    * const commentNotifications = await prisma.commentNotification.findMany()
    * ```
    */
  get commentNotification(): Prisma.CommentNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageNotification`: Exposes CRUD operations for the **MessageNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageNotifications
    * const messageNotifications = await prisma.messageNotification.findMany()
    * ```
    */
  get messageNotification(): Prisma.MessageNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.likeNotification`: Exposes CRUD operations for the **LikeNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LikeNotifications
    * const likeNotifications = await prisma.likeNotification.findMany()
    * ```
    */
  get likeNotification(): Prisma.LikeNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inboxes`: Exposes CRUD operations for the **inboxes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inboxes
    * const inboxes = await prisma.inboxes.findMany()
    * ```
    */
  get inboxes(): Prisma.inboxesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    BlockedUser: 'BlockedUser',
    ReportUser: 'ReportUser',
    ReadHistory: 'ReadHistory',
    Blog: 'Blog',
    BlogLike: 'BlogLike',
    BlogDisLike: 'BlogDisLike',
    Topic: 'Topic',
    Follow: 'Follow',
    Comment: 'Comment',
    LikeComment: 'LikeComment',
    DisLikeComment: 'DisLikeComment',
    CommentReply: 'CommentReply',
    SavedBlog: 'SavedBlog',
    Membership: 'Membership',
    ReportBlog: 'ReportBlog',
    CommentNotification: 'CommentNotification',
    MessageNotification: 'MessageNotification',
    LikeNotification: 'LikeNotification',
    inboxes: 'inboxes'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "blockedUser" | "reportUser" | "readHistory" | "blog" | "blogLike" | "blogDisLike" | "topic" | "follow" | "comment" | "likeComment" | "disLikeComment" | "commentReply" | "savedBlog" | "membership" | "reportBlog" | "commentNotification" | "messageNotification" | "likeNotification" | "inboxes"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      BlockedUser: {
        payload: Prisma.$BlockedUserPayload<ExtArgs>
        fields: Prisma.BlockedUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findFirst: {
            args: Prisma.BlockedUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findMany: {
            args: Prisma.BlockedUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          create: {
            args: Prisma.BlockedUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          createMany: {
            args: Prisma.BlockedUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          delete: {
            args: Prisma.BlockedUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          update: {
            args: Prisma.BlockedUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          deleteMany: {
            args: Prisma.BlockedUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockedUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          upsert: {
            args: Prisma.BlockedUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          aggregate: {
            args: Prisma.BlockedUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedUser>
          }
          groupBy: {
            args: Prisma.BlockedUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedUserCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserCountAggregateOutputType> | number
          }
        }
      }
      ReportUser: {
        payload: Prisma.$ReportUserPayload<ExtArgs>
        fields: Prisma.ReportUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          findFirst: {
            args: Prisma.ReportUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          findMany: {
            args: Prisma.ReportUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>[]
          }
          create: {
            args: Prisma.ReportUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          createMany: {
            args: Prisma.ReportUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>[]
          }
          delete: {
            args: Prisma.ReportUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          update: {
            args: Prisma.ReportUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          deleteMany: {
            args: Prisma.ReportUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>[]
          }
          upsert: {
            args: Prisma.ReportUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          aggregate: {
            args: Prisma.ReportUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportUser>
          }
          groupBy: {
            args: Prisma.ReportUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportUserCountArgs<ExtArgs>
            result: $Utils.Optional<ReportUserCountAggregateOutputType> | number
          }
        }
      }
      ReadHistory: {
        payload: Prisma.$ReadHistoryPayload<ExtArgs>
        fields: Prisma.ReadHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReadHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReadHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>
          }
          findFirst: {
            args: Prisma.ReadHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReadHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>
          }
          findMany: {
            args: Prisma.ReadHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>[]
          }
          create: {
            args: Prisma.ReadHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>
          }
          createMany: {
            args: Prisma.ReadHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReadHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>[]
          }
          delete: {
            args: Prisma.ReadHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>
          }
          update: {
            args: Prisma.ReadHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ReadHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReadHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReadHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ReadHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadHistoryPayload>
          }
          aggregate: {
            args: Prisma.ReadHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReadHistory>
          }
          groupBy: {
            args: Prisma.ReadHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReadHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReadHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ReadHistoryCountAggregateOutputType> | number
          }
        }
      }
      Blog: {
        payload: Prisma.$BlogPayload<ExtArgs>
        fields: Prisma.BlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findFirst: {
            args: Prisma.BlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findMany: {
            args: Prisma.BlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          create: {
            args: Prisma.BlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          createMany: {
            args: Prisma.BlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          delete: {
            args: Prisma.BlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          update: {
            args: Prisma.BlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          deleteMany: {
            args: Prisma.BlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          upsert: {
            args: Prisma.BlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.BlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      BlogLike: {
        payload: Prisma.$BlogLikePayload<ExtArgs>
        fields: Prisma.BlogLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>
          }
          findFirst: {
            args: Prisma.BlogLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>
          }
          findMany: {
            args: Prisma.BlogLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>[]
          }
          create: {
            args: Prisma.BlogLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>
          }
          createMany: {
            args: Prisma.BlogLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>[]
          }
          delete: {
            args: Prisma.BlogLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>
          }
          update: {
            args: Prisma.BlogLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>
          }
          deleteMany: {
            args: Prisma.BlogLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>[]
          }
          upsert: {
            args: Prisma.BlogLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogLikePayload>
          }
          aggregate: {
            args: Prisma.BlogLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogLike>
          }
          groupBy: {
            args: Prisma.BlogLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogLikeCountArgs<ExtArgs>
            result: $Utils.Optional<BlogLikeCountAggregateOutputType> | number
          }
        }
      }
      BlogDisLike: {
        payload: Prisma.$BlogDisLikePayload<ExtArgs>
        fields: Prisma.BlogDisLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogDisLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogDisLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>
          }
          findFirst: {
            args: Prisma.BlogDisLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogDisLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>
          }
          findMany: {
            args: Prisma.BlogDisLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>[]
          }
          create: {
            args: Prisma.BlogDisLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>
          }
          createMany: {
            args: Prisma.BlogDisLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogDisLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>[]
          }
          delete: {
            args: Prisma.BlogDisLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>
          }
          update: {
            args: Prisma.BlogDisLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>
          }
          deleteMany: {
            args: Prisma.BlogDisLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogDisLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogDisLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>[]
          }
          upsert: {
            args: Prisma.BlogDisLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogDisLikePayload>
          }
          aggregate: {
            args: Prisma.BlogDisLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogDisLike>
          }
          groupBy: {
            args: Prisma.BlogDisLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogDisLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogDisLikeCountArgs<ExtArgs>
            result: $Utils.Optional<BlogDisLikeCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      LikeComment: {
        payload: Prisma.$LikeCommentPayload<ExtArgs>
        fields: Prisma.LikeCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>
          }
          findFirst: {
            args: Prisma.LikeCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>
          }
          findMany: {
            args: Prisma.LikeCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>[]
          }
          create: {
            args: Prisma.LikeCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>
          }
          createMany: {
            args: Prisma.LikeCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>[]
          }
          delete: {
            args: Prisma.LikeCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>
          }
          update: {
            args: Prisma.LikeCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>
          }
          deleteMany: {
            args: Prisma.LikeCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>[]
          }
          upsert: {
            args: Prisma.LikeCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeCommentPayload>
          }
          aggregate: {
            args: Prisma.LikeCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikeComment>
          }
          groupBy: {
            args: Prisma.LikeCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCommentCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCommentCountAggregateOutputType> | number
          }
        }
      }
      DisLikeComment: {
        payload: Prisma.$DisLikeCommentPayload<ExtArgs>
        fields: Prisma.DisLikeCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisLikeCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisLikeCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>
          }
          findFirst: {
            args: Prisma.DisLikeCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisLikeCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>
          }
          findMany: {
            args: Prisma.DisLikeCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>[]
          }
          create: {
            args: Prisma.DisLikeCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>
          }
          createMany: {
            args: Prisma.DisLikeCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisLikeCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>[]
          }
          delete: {
            args: Prisma.DisLikeCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>
          }
          update: {
            args: Prisma.DisLikeCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>
          }
          deleteMany: {
            args: Prisma.DisLikeCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisLikeCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisLikeCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>[]
          }
          upsert: {
            args: Prisma.DisLikeCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisLikeCommentPayload>
          }
          aggregate: {
            args: Prisma.DisLikeCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisLikeComment>
          }
          groupBy: {
            args: Prisma.DisLikeCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisLikeCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisLikeCommentCountArgs<ExtArgs>
            result: $Utils.Optional<DisLikeCommentCountAggregateOutputType> | number
          }
        }
      }
      CommentReply: {
        payload: Prisma.$CommentReplyPayload<ExtArgs>
        fields: Prisma.CommentReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          findFirst: {
            args: Prisma.CommentReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          findMany: {
            args: Prisma.CommentReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>[]
          }
          create: {
            args: Prisma.CommentReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          createMany: {
            args: Prisma.CommentReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>[]
          }
          delete: {
            args: Prisma.CommentReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          update: {
            args: Prisma.CommentReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          deleteMany: {
            args: Prisma.CommentReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentReplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>[]
          }
          upsert: {
            args: Prisma.CommentReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          aggregate: {
            args: Prisma.CommentReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentReply>
          }
          groupBy: {
            args: Prisma.CommentReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentReplyCountArgs<ExtArgs>
            result: $Utils.Optional<CommentReplyCountAggregateOutputType> | number
          }
        }
      }
      SavedBlog: {
        payload: Prisma.$SavedBlogPayload<ExtArgs>
        fields: Prisma.SavedBlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedBlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedBlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>
          }
          findFirst: {
            args: Prisma.SavedBlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedBlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>
          }
          findMany: {
            args: Prisma.SavedBlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>[]
          }
          create: {
            args: Prisma.SavedBlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>
          }
          createMany: {
            args: Prisma.SavedBlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedBlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>[]
          }
          delete: {
            args: Prisma.SavedBlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>
          }
          update: {
            args: Prisma.SavedBlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>
          }
          deleteMany: {
            args: Prisma.SavedBlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedBlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedBlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>[]
          }
          upsert: {
            args: Prisma.SavedBlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedBlogPayload>
          }
          aggregate: {
            args: Prisma.SavedBlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedBlog>
          }
          groupBy: {
            args: Prisma.SavedBlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedBlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedBlogCountArgs<ExtArgs>
            result: $Utils.Optional<SavedBlogCountAggregateOutputType> | number
          }
        }
      }
      Membership: {
        payload: Prisma.$MembershipPayload<ExtArgs>
        fields: Prisma.MembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findFirst: {
            args: Prisma.MembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findMany: {
            args: Prisma.MembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          create: {
            args: Prisma.MembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          createMany: {
            args: Prisma.MembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          delete: {
            args: Prisma.MembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          update: {
            args: Prisma.MembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          deleteMany: {
            args: Prisma.MembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          upsert: {
            args: Prisma.MembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          aggregate: {
            args: Prisma.MembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembership>
          }
          groupBy: {
            args: Prisma.MembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipCountAggregateOutputType> | number
          }
        }
      }
      ReportBlog: {
        payload: Prisma.$ReportBlogPayload<ExtArgs>
        fields: Prisma.ReportBlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportBlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportBlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>
          }
          findFirst: {
            args: Prisma.ReportBlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportBlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>
          }
          findMany: {
            args: Prisma.ReportBlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>[]
          }
          create: {
            args: Prisma.ReportBlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>
          }
          createMany: {
            args: Prisma.ReportBlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportBlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>[]
          }
          delete: {
            args: Prisma.ReportBlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>
          }
          update: {
            args: Prisma.ReportBlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>
          }
          deleteMany: {
            args: Prisma.ReportBlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportBlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportBlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>[]
          }
          upsert: {
            args: Prisma.ReportBlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportBlogPayload>
          }
          aggregate: {
            args: Prisma.ReportBlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportBlog>
          }
          groupBy: {
            args: Prisma.ReportBlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportBlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportBlogCountArgs<ExtArgs>
            result: $Utils.Optional<ReportBlogCountAggregateOutputType> | number
          }
        }
      }
      CommentNotification: {
        payload: Prisma.$CommentNotificationPayload<ExtArgs>
        fields: Prisma.CommentNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>
          }
          findFirst: {
            args: Prisma.CommentNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>
          }
          findMany: {
            args: Prisma.CommentNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>[]
          }
          create: {
            args: Prisma.CommentNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>
          }
          createMany: {
            args: Prisma.CommentNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>[]
          }
          delete: {
            args: Prisma.CommentNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>
          }
          update: {
            args: Prisma.CommentNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>
          }
          deleteMany: {
            args: Prisma.CommentNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>[]
          }
          upsert: {
            args: Prisma.CommentNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentNotificationPayload>
          }
          aggregate: {
            args: Prisma.CommentNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentNotification>
          }
          groupBy: {
            args: Prisma.CommentNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<CommentNotificationCountAggregateOutputType> | number
          }
        }
      }
      MessageNotification: {
        payload: Prisma.$MessageNotificationPayload<ExtArgs>
        fields: Prisma.MessageNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>
          }
          findFirst: {
            args: Prisma.MessageNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>
          }
          findMany: {
            args: Prisma.MessageNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>[]
          }
          create: {
            args: Prisma.MessageNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>
          }
          createMany: {
            args: Prisma.MessageNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>[]
          }
          delete: {
            args: Prisma.MessageNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>
          }
          update: {
            args: Prisma.MessageNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>
          }
          deleteMany: {
            args: Prisma.MessageNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>[]
          }
          upsert: {
            args: Prisma.MessageNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageNotificationPayload>
          }
          aggregate: {
            args: Prisma.MessageNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageNotification>
          }
          groupBy: {
            args: Prisma.MessageNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<MessageNotificationCountAggregateOutputType> | number
          }
        }
      }
      LikeNotification: {
        payload: Prisma.$LikeNotificationPayload<ExtArgs>
        fields: Prisma.LikeNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>
          }
          findFirst: {
            args: Prisma.LikeNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>
          }
          findMany: {
            args: Prisma.LikeNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>[]
          }
          create: {
            args: Prisma.LikeNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>
          }
          createMany: {
            args: Prisma.LikeNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>[]
          }
          delete: {
            args: Prisma.LikeNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>
          }
          update: {
            args: Prisma.LikeNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>
          }
          deleteMany: {
            args: Prisma.LikeNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>[]
          }
          upsert: {
            args: Prisma.LikeNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeNotificationPayload>
          }
          aggregate: {
            args: Prisma.LikeNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikeNotification>
          }
          groupBy: {
            args: Prisma.LikeNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<LikeNotificationCountAggregateOutputType> | number
          }
        }
      }
      inboxes: {
        payload: Prisma.$inboxesPayload<ExtArgs>
        fields: Prisma.inboxesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inboxesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inboxesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>
          }
          findFirst: {
            args: Prisma.inboxesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inboxesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>
          }
          findMany: {
            args: Prisma.inboxesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>[]
          }
          create: {
            args: Prisma.inboxesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>
          }
          createMany: {
            args: Prisma.inboxesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inboxesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>[]
          }
          delete: {
            args: Prisma.inboxesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>
          }
          update: {
            args: Prisma.inboxesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>
          }
          deleteMany: {
            args: Prisma.inboxesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inboxesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inboxesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>[]
          }
          upsert: {
            args: Prisma.inboxesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inboxesPayload>
          }
          aggregate: {
            args: Prisma.InboxesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInboxes>
          }
          groupBy: {
            args: Prisma.inboxesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InboxesGroupByOutputType>[]
          }
          count: {
            args: Prisma.inboxesCountArgs<ExtArgs>
            result: $Utils.Optional<InboxesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    blockedUser?: BlockedUserOmit
    reportUser?: ReportUserOmit
    readHistory?: ReadHistoryOmit
    blog?: BlogOmit
    blogLike?: BlogLikeOmit
    blogDisLike?: BlogDisLikeOmit
    topic?: TopicOmit
    follow?: FollowOmit
    comment?: CommentOmit
    likeComment?: LikeCommentOmit
    disLikeComment?: DisLikeCommentOmit
    commentReply?: CommentReplyOmit
    savedBlog?: SavedBlogOmit
    membership?: MembershipOmit
    reportBlog?: ReportBlogOmit
    commentNotification?: CommentNotificationOmit
    messageNotification?: MessageNotificationOmit
    likeNotification?: LikeNotificationOmit
    inboxes?: inboxesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    blockedByUsers: number
    blockedUsers: number
    blogDisLikes: number
    blogLikes: number
    reportedBlogs: number
    blogs: number
    disLikeComments: number
    likeComments: number
    commentNotifications: number
    commentReplies: number
    comments: number
    followings: number
    followers: number
    inboxes_inboxes_receiverIDTousers: number
    inboxes_inboxes_senderIDTousers: number
    likeNotifications: number
    messageNotifications: number
    readHistories: number
    reportedUsers: number
    usersReported: number
    savedBlogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockedByUsers?: boolean | UserCountOutputTypeCountBlockedByUsersArgs
    blockedUsers?: boolean | UserCountOutputTypeCountBlockedUsersArgs
    blogDisLikes?: boolean | UserCountOutputTypeCountBlogDisLikesArgs
    blogLikes?: boolean | UserCountOutputTypeCountBlogLikesArgs
    reportedBlogs?: boolean | UserCountOutputTypeCountReportedBlogsArgs
    blogs?: boolean | UserCountOutputTypeCountBlogsArgs
    disLikeComments?: boolean | UserCountOutputTypeCountDisLikeCommentsArgs
    likeComments?: boolean | UserCountOutputTypeCountLikeCommentsArgs
    commentNotifications?: boolean | UserCountOutputTypeCountCommentNotificationsArgs
    commentReplies?: boolean | UserCountOutputTypeCountCommentRepliesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    followings?: boolean | UserCountOutputTypeCountFollowingsArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    inboxes_inboxes_receiverIDTousers?: boolean | UserCountOutputTypeCountInboxes_inboxes_receiverIDTousersArgs
    inboxes_inboxes_senderIDTousers?: boolean | UserCountOutputTypeCountInboxes_inboxes_senderIDTousersArgs
    likeNotifications?: boolean | UserCountOutputTypeCountLikeNotificationsArgs
    messageNotifications?: boolean | UserCountOutputTypeCountMessageNotificationsArgs
    readHistories?: boolean | UserCountOutputTypeCountReadHistoriesArgs
    reportedUsers?: boolean | UserCountOutputTypeCountReportedUsersArgs
    usersReported?: boolean | UserCountOutputTypeCountUsersReportedArgs
    savedBlogs?: boolean | UserCountOutputTypeCountSavedBlogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogDisLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogDisLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportBlogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDisLikeCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisLikeCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikeCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInboxes_inboxes_receiverIDTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inboxesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInboxes_inboxes_senderIDTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inboxesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikeNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReadHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsersReportedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedBlogWhereInput
  }


  /**
   * Count Type BlogCountOutputType
   */

  export type BlogCountOutputType = {
    dislikes: number
    likes: number
    reports: number
    comments: number
    readHistories: number
    savedBy: number
    topics: number
  }

  export type BlogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dislikes?: boolean | BlogCountOutputTypeCountDislikesArgs
    likes?: boolean | BlogCountOutputTypeCountLikesArgs
    reports?: boolean | BlogCountOutputTypeCountReportsArgs
    comments?: boolean | BlogCountOutputTypeCountCommentsArgs
    readHistories?: boolean | BlogCountOutputTypeCountReadHistoriesArgs
    savedBy?: boolean | BlogCountOutputTypeCountSavedByArgs
    topics?: boolean | BlogCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCountOutputType
     */
    select?: BlogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountDislikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogDisLikeWhereInput
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogLikeWhereInput
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportBlogWhereInput
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountReadHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadHistoryWhereInput
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountSavedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedBlogWhereInput
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }


  /**
   * Count Type BlogLikeCountOutputType
   */

  export type BlogLikeCountOutputType = {
    likeNotifications: number
  }

  export type BlogLikeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likeNotifications?: boolean | BlogLikeCountOutputTypeCountLikeNotificationsArgs
  }

  // Custom InputTypes
  /**
   * BlogLikeCountOutputType without action
   */
  export type BlogLikeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLikeCountOutputType
     */
    select?: BlogLikeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogLikeCountOutputType without action
   */
  export type BlogLikeCountOutputTypeCountLikeNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeNotificationWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    blogs: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogs?: boolean | TopicCountOutputTypeCountBlogsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    disLikeComments: number
    likeComments: number
    commentNotifications: number
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disLikeComments?: boolean | CommentCountOutputTypeCountDisLikeCommentsArgs
    likeComments?: boolean | CommentCountOutputTypeCountLikeCommentsArgs
    commentNotifications?: boolean | CommentCountOutputTypeCountCommentNotificationsArgs
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountDisLikeCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisLikeCommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountLikeCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeCommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountCommentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentNotificationWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    age: number | null
    experience: number | null
  }

  export type UserSumAggregateOutputType = {
    age: number | null
    experience: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    age: number | null
    about: string | null
    experience: number | null
    field: string | null
    password: string | null
    shortBio: string | null
    profilePhoto: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    age: number | null
    about: string | null
    experience: number | null
    field: string | null
    password: string | null
    shortBio: string | null
    profilePhoto: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    age: number
    about: number
    experience: number
    interests: number
    field: number
    password: number
    shortBio: number
    profilePhoto: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    age?: true
    experience?: true
  }

  export type UserSumAggregateInputType = {
    age?: true
    experience?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    age?: true
    about?: true
    experience?: true
    field?: true
    password?: true
    shortBio?: true
    profilePhoto?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    age?: true
    about?: true
    experience?: true
    field?: true
    password?: true
    shortBio?: true
    profilePhoto?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    age?: true
    about?: true
    experience?: true
    interests?: true
    field?: true
    password?: true
    shortBio?: true
    profilePhoto?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    age: number | null
    about: string | null
    experience: number | null
    interests: string[]
    field: string | null
    password: string | null
    shortBio: string | null
    profilePhoto: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    age?: boolean
    about?: boolean
    experience?: boolean
    interests?: boolean
    field?: boolean
    password?: boolean
    shortBio?: boolean
    profilePhoto?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blockedByUsers?: boolean | User$blockedByUsersArgs<ExtArgs>
    blockedUsers?: boolean | User$blockedUsersArgs<ExtArgs>
    blogDisLikes?: boolean | User$blogDisLikesArgs<ExtArgs>
    blogLikes?: boolean | User$blogLikesArgs<ExtArgs>
    reportedBlogs?: boolean | User$reportedBlogsArgs<ExtArgs>
    blogs?: boolean | User$blogsArgs<ExtArgs>
    disLikeComments?: boolean | User$disLikeCommentsArgs<ExtArgs>
    likeComments?: boolean | User$likeCommentsArgs<ExtArgs>
    commentNotifications?: boolean | User$commentNotificationsArgs<ExtArgs>
    commentReplies?: boolean | User$commentRepliesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    followings?: boolean | User$followingsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    inboxes_inboxes_receiverIDTousers?: boolean | User$inboxes_inboxes_receiverIDTousersArgs<ExtArgs>
    inboxes_inboxes_senderIDTousers?: boolean | User$inboxes_inboxes_senderIDTousersArgs<ExtArgs>
    likeNotifications?: boolean | User$likeNotificationsArgs<ExtArgs>
    membership?: boolean | User$membershipArgs<ExtArgs>
    messageNotifications?: boolean | User$messageNotificationsArgs<ExtArgs>
    readHistories?: boolean | User$readHistoriesArgs<ExtArgs>
    reportedUsers?: boolean | User$reportedUsersArgs<ExtArgs>
    usersReported?: boolean | User$usersReportedArgs<ExtArgs>
    savedBlogs?: boolean | User$savedBlogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    age?: boolean
    about?: boolean
    experience?: boolean
    interests?: boolean
    field?: boolean
    password?: boolean
    shortBio?: boolean
    profilePhoto?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    age?: boolean
    about?: boolean
    experience?: boolean
    interests?: boolean
    field?: boolean
    password?: boolean
    shortBio?: boolean
    profilePhoto?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    age?: boolean
    about?: boolean
    experience?: boolean
    interests?: boolean
    field?: boolean
    password?: boolean
    shortBio?: boolean
    profilePhoto?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "age" | "about" | "experience" | "interests" | "field" | "password" | "shortBio" | "profilePhoto" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockedByUsers?: boolean | User$blockedByUsersArgs<ExtArgs>
    blockedUsers?: boolean | User$blockedUsersArgs<ExtArgs>
    blogDisLikes?: boolean | User$blogDisLikesArgs<ExtArgs>
    blogLikes?: boolean | User$blogLikesArgs<ExtArgs>
    reportedBlogs?: boolean | User$reportedBlogsArgs<ExtArgs>
    blogs?: boolean | User$blogsArgs<ExtArgs>
    disLikeComments?: boolean | User$disLikeCommentsArgs<ExtArgs>
    likeComments?: boolean | User$likeCommentsArgs<ExtArgs>
    commentNotifications?: boolean | User$commentNotificationsArgs<ExtArgs>
    commentReplies?: boolean | User$commentRepliesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    followings?: boolean | User$followingsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    inboxes_inboxes_receiverIDTousers?: boolean | User$inboxes_inboxes_receiverIDTousersArgs<ExtArgs>
    inboxes_inboxes_senderIDTousers?: boolean | User$inboxes_inboxes_senderIDTousersArgs<ExtArgs>
    likeNotifications?: boolean | User$likeNotificationsArgs<ExtArgs>
    membership?: boolean | User$membershipArgs<ExtArgs>
    messageNotifications?: boolean | User$messageNotificationsArgs<ExtArgs>
    readHistories?: boolean | User$readHistoriesArgs<ExtArgs>
    reportedUsers?: boolean | User$reportedUsersArgs<ExtArgs>
    usersReported?: boolean | User$usersReportedArgs<ExtArgs>
    savedBlogs?: boolean | User$savedBlogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      blockedByUsers: Prisma.$BlockedUserPayload<ExtArgs>[]
      blockedUsers: Prisma.$BlockedUserPayload<ExtArgs>[]
      blogDisLikes: Prisma.$BlogDisLikePayload<ExtArgs>[]
      blogLikes: Prisma.$BlogLikePayload<ExtArgs>[]
      reportedBlogs: Prisma.$ReportBlogPayload<ExtArgs>[]
      blogs: Prisma.$BlogPayload<ExtArgs>[]
      disLikeComments: Prisma.$DisLikeCommentPayload<ExtArgs>[]
      likeComments: Prisma.$LikeCommentPayload<ExtArgs>[]
      commentNotifications: Prisma.$CommentNotificationPayload<ExtArgs>[]
      commentReplies: Prisma.$CommentReplyPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      followings: Prisma.$FollowPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      inboxes_inboxes_receiverIDTousers: Prisma.$inboxesPayload<ExtArgs>[]
      inboxes_inboxes_senderIDTousers: Prisma.$inboxesPayload<ExtArgs>[]
      likeNotifications: Prisma.$LikeNotificationPayload<ExtArgs>[]
      membership: Prisma.$MembershipPayload<ExtArgs> | null
      messageNotifications: Prisma.$MessageNotificationPayload<ExtArgs>[]
      readHistories: Prisma.$ReadHistoryPayload<ExtArgs>[]
      reportedUsers: Prisma.$ReportUserPayload<ExtArgs>[]
      usersReported: Prisma.$ReportUserPayload<ExtArgs>[]
      savedBlogs: Prisma.$SavedBlogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      age: number | null
      about: string | null
      experience: number | null
      interests: string[]
      field: string | null
      password: string | null
      shortBio: string | null
      profilePhoto: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blockedByUsers<T extends User$blockedByUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$blockedByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blockedUsers<T extends User$blockedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$blockedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogDisLikes<T extends User$blogDisLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$blogDisLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogLikes<T extends User$blogLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$blogLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedBlogs<T extends User$reportedBlogsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedBlogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogs<T extends User$blogsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disLikeComments<T extends User$disLikeCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$disLikeCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likeComments<T extends User$likeCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$likeCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentNotifications<T extends User$commentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentReplies<T extends User$commentRepliesArgs<ExtArgs> = {}>(args?: Subset<T, User$commentRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followings<T extends User$followingsArgs<ExtArgs> = {}>(args?: Subset<T, User$followingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inboxes_inboxes_receiverIDTousers<T extends User$inboxes_inboxes_receiverIDTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$inboxes_inboxes_receiverIDTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inboxes_inboxes_senderIDTousers<T extends User$inboxes_inboxes_senderIDTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$inboxes_inboxes_senderIDTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likeNotifications<T extends User$likeNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$likeNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    membership<T extends User$membershipArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messageNotifications<T extends User$messageNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readHistories<T extends User$readHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$readHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedUsers<T extends User$reportedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usersReported<T extends User$usersReportedArgs<ExtArgs> = {}>(args?: Subset<T, User$usersReportedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedBlogs<T extends User$savedBlogsArgs<ExtArgs> = {}>(args?: Subset<T, User$savedBlogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly age: FieldRef<"User", 'Int'>
    readonly about: FieldRef<"User", 'String'>
    readonly experience: FieldRef<"User", 'Int'>
    readonly interests: FieldRef<"User", 'String[]'>
    readonly field: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly shortBio: FieldRef<"User", 'String'>
    readonly profilePhoto: FieldRef<"User", 'String'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.blockedByUsers
   */
  export type User$blockedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    cursor?: BlockedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * User.blockedUsers
   */
  export type User$blockedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    cursor?: BlockedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * User.blogDisLikes
   */
  export type User$blogDisLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    where?: BlogDisLikeWhereInput
    orderBy?: BlogDisLikeOrderByWithRelationInput | BlogDisLikeOrderByWithRelationInput[]
    cursor?: BlogDisLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogDisLikeScalarFieldEnum | BlogDisLikeScalarFieldEnum[]
  }

  /**
   * User.blogLikes
   */
  export type User$blogLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    where?: BlogLikeWhereInput
    orderBy?: BlogLikeOrderByWithRelationInput | BlogLikeOrderByWithRelationInput[]
    cursor?: BlogLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogLikeScalarFieldEnum | BlogLikeScalarFieldEnum[]
  }

  /**
   * User.reportedBlogs
   */
  export type User$reportedBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    where?: ReportBlogWhereInput
    orderBy?: ReportBlogOrderByWithRelationInput | ReportBlogOrderByWithRelationInput[]
    cursor?: ReportBlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportBlogScalarFieldEnum | ReportBlogScalarFieldEnum[]
  }

  /**
   * User.blogs
   */
  export type User$blogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    cursor?: BlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * User.disLikeComments
   */
  export type User$disLikeCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    where?: DisLikeCommentWhereInput
    orderBy?: DisLikeCommentOrderByWithRelationInput | DisLikeCommentOrderByWithRelationInput[]
    cursor?: DisLikeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisLikeCommentScalarFieldEnum | DisLikeCommentScalarFieldEnum[]
  }

  /**
   * User.likeComments
   */
  export type User$likeCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    where?: LikeCommentWhereInput
    orderBy?: LikeCommentOrderByWithRelationInput | LikeCommentOrderByWithRelationInput[]
    cursor?: LikeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeCommentScalarFieldEnum | LikeCommentScalarFieldEnum[]
  }

  /**
   * User.commentNotifications
   */
  export type User$commentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    where?: CommentNotificationWhereInput
    orderBy?: CommentNotificationOrderByWithRelationInput | CommentNotificationOrderByWithRelationInput[]
    cursor?: CommentNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentNotificationScalarFieldEnum | CommentNotificationScalarFieldEnum[]
  }

  /**
   * User.commentReplies
   */
  export type User$commentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    cursor?: CommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.followings
   */
  export type User$followingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.inboxes_inboxes_receiverIDTousers
   */
  export type User$inboxes_inboxes_receiverIDTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    where?: inboxesWhereInput
    orderBy?: inboxesOrderByWithRelationInput | inboxesOrderByWithRelationInput[]
    cursor?: inboxesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InboxesScalarFieldEnum | InboxesScalarFieldEnum[]
  }

  /**
   * User.inboxes_inboxes_senderIDTousers
   */
  export type User$inboxes_inboxes_senderIDTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    where?: inboxesWhereInput
    orderBy?: inboxesOrderByWithRelationInput | inboxesOrderByWithRelationInput[]
    cursor?: inboxesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InboxesScalarFieldEnum | InboxesScalarFieldEnum[]
  }

  /**
   * User.likeNotifications
   */
  export type User$likeNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    where?: LikeNotificationWhereInput
    orderBy?: LikeNotificationOrderByWithRelationInput | LikeNotificationOrderByWithRelationInput[]
    cursor?: LikeNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeNotificationScalarFieldEnum | LikeNotificationScalarFieldEnum[]
  }

  /**
   * User.membership
   */
  export type User$membershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    where?: MembershipWhereInput
  }

  /**
   * User.messageNotifications
   */
  export type User$messageNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    where?: MessageNotificationWhereInput
    orderBy?: MessageNotificationOrderByWithRelationInput | MessageNotificationOrderByWithRelationInput[]
    cursor?: MessageNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageNotificationScalarFieldEnum | MessageNotificationScalarFieldEnum[]
  }

  /**
   * User.readHistories
   */
  export type User$readHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    where?: ReadHistoryWhereInput
    orderBy?: ReadHistoryOrderByWithRelationInput | ReadHistoryOrderByWithRelationInput[]
    cursor?: ReadHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadHistoryScalarFieldEnum | ReadHistoryScalarFieldEnum[]
  }

  /**
   * User.reportedUsers
   */
  export type User$reportedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    where?: ReportUserWhereInput
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    cursor?: ReportUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * User.usersReported
   */
  export type User$usersReportedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    where?: ReportUserWhereInput
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    cursor?: ReportUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * User.savedBlogs
   */
  export type User$savedBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    where?: SavedBlogWhereInput
    orderBy?: SavedBlogOrderByWithRelationInput | SavedBlogOrderByWithRelationInput[]
    cursor?: SavedBlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedBlogScalarFieldEnum | SavedBlogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model BlockedUser
   */

  export type AggregateBlockedUser = {
    _count: BlockedUserCountAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  export type BlockedUserMinAggregateOutputType = {
    id: string | null
    userID: string | null
    blockedID: string | null
    createdAt: Date | null
  }

  export type BlockedUserMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    blockedID: string | null
    createdAt: Date | null
  }

  export type BlockedUserCountAggregateOutputType = {
    id: number
    userID: number
    blockedID: number
    createdAt: number
    _all: number
  }


  export type BlockedUserMinAggregateInputType = {
    id?: true
    userID?: true
    blockedID?: true
    createdAt?: true
  }

  export type BlockedUserMaxAggregateInputType = {
    id?: true
    userID?: true
    blockedID?: true
    createdAt?: true
  }

  export type BlockedUserCountAggregateInputType = {
    id?: true
    userID?: true
    blockedID?: true
    createdAt?: true
    _all?: true
  }

  export type BlockedUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUser to aggregate.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedUsers
    **/
    _count?: true | BlockedUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedUserMaxAggregateInputType
  }

  export type GetBlockedUserAggregateType<T extends BlockedUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedUser[P]>
      : GetScalarType<T[P], AggregateBlockedUser[P]>
  }




  export type BlockedUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithAggregationInput | BlockedUserOrderByWithAggregationInput[]
    by: BlockedUserScalarFieldEnum[] | BlockedUserScalarFieldEnum
    having?: BlockedUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedUserCountAggregateInputType | true
    _min?: BlockedUserMinAggregateInputType
    _max?: BlockedUserMaxAggregateInputType
  }

  export type BlockedUserGroupByOutputType = {
    id: string
    userID: string
    blockedID: string
    createdAt: Date
    _count: BlockedUserCountAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  type GetBlockedUserGroupByPayload<T extends BlockedUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
        }
      >
    >


  export type BlockedUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blockedID?: boolean
    createdAt?: boolean
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blockedID?: boolean
    createdAt?: boolean
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blockedID?: boolean
    createdAt?: boolean
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectScalar = {
    id?: boolean
    userID?: boolean
    blockedID?: boolean
    createdAt?: boolean
  }

  export type BlockedUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "blockedID" | "createdAt", ExtArgs["result"]["blockedUser"]>
  export type BlockedUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockedUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockedUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlockedUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedUser"
    objects: {
      blockedUser: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      blockedID: string
      createdAt: Date
    }, ExtArgs["result"]["blockedUser"]>
    composites: {}
  }

  type BlockedUserGetPayload<S extends boolean | null | undefined | BlockedUserDefaultArgs> = $Result.GetResult<Prisma.$BlockedUserPayload, S>

  type BlockedUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockedUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockedUserCountAggregateInputType | true
    }

  export interface BlockedUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedUser'], meta: { name: 'BlockedUser' } }
    /**
     * Find zero or one BlockedUser that matches the filter.
     * @param {BlockedUserFindUniqueArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedUserFindUniqueArgs>(args: SelectSubset<T, BlockedUserFindUniqueArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlockedUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockedUserFindUniqueOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedUserFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedUserFindFirstArgs>(args?: SelectSubset<T, BlockedUserFindFirstArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedUserFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlockedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany()
     * 
     * // Get first 10 BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockedUserFindManyArgs>(args?: SelectSubset<T, BlockedUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlockedUser.
     * @param {BlockedUserCreateArgs} args - Arguments to create a BlockedUser.
     * @example
     * // Create one BlockedUser
     * const BlockedUser = await prisma.blockedUser.create({
     *   data: {
     *     // ... data to create a BlockedUser
     *   }
     * })
     * 
     */
    create<T extends BlockedUserCreateArgs>(args: SelectSubset<T, BlockedUserCreateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlockedUsers.
     * @param {BlockedUserCreateManyArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedUserCreateManyArgs>(args?: SelectSubset<T, BlockedUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedUsers and returns the data saved in the database.
     * @param {BlockedUserCreateManyAndReturnArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedUsers and only return the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedUserCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlockedUser.
     * @param {BlockedUserDeleteArgs} args - Arguments to delete one BlockedUser.
     * @example
     * // Delete one BlockedUser
     * const BlockedUser = await prisma.blockedUser.delete({
     *   where: {
     *     // ... filter to delete one BlockedUser
     *   }
     * })
     * 
     */
    delete<T extends BlockedUserDeleteArgs>(args: SelectSubset<T, BlockedUserDeleteArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlockedUser.
     * @param {BlockedUserUpdateArgs} args - Arguments to update one BlockedUser.
     * @example
     * // Update one BlockedUser
     * const blockedUser = await prisma.blockedUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedUserUpdateArgs>(args: SelectSubset<T, BlockedUserUpdateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlockedUsers.
     * @param {BlockedUserDeleteManyArgs} args - Arguments to filter BlockedUsers to delete.
     * @example
     * // Delete a few BlockedUsers
     * const { count } = await prisma.blockedUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedUserDeleteManyArgs>(args?: SelectSubset<T, BlockedUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedUsers
     * const blockedUser = await prisma.blockedUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedUserUpdateManyArgs>(args: SelectSubset<T, BlockedUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUsers and returns the data updated in the database.
     * @param {BlockedUserUpdateManyAndReturnArgs} args - Arguments to update many BlockedUsers.
     * @example
     * // Update many BlockedUsers
     * const blockedUser = await prisma.blockedUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlockedUsers and only return the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockedUserUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockedUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlockedUser.
     * @param {BlockedUserUpsertArgs} args - Arguments to update or create a BlockedUser.
     * @example
     * // Update or create a BlockedUser
     * const blockedUser = await prisma.blockedUser.upsert({
     *   create: {
     *     // ... data to create a BlockedUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedUser we want to update
     *   }
     * })
     */
    upsert<T extends BlockedUserUpsertArgs>(args: SelectSubset<T, BlockedUserUpsertArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserCountArgs} args - Arguments to filter BlockedUsers to count.
     * @example
     * // Count the number of BlockedUsers
     * const count = await prisma.blockedUser.count({
     *   where: {
     *     // ... the filter for the BlockedUsers we want to count
     *   }
     * })
    **/
    count<T extends BlockedUserCountArgs>(
      args?: Subset<T, BlockedUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedUserAggregateArgs>(args: Subset<T, BlockedUserAggregateArgs>): Prisma.PrismaPromise<GetBlockedUserAggregateType<T>>

    /**
     * Group by BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedUserGroupByArgs['orderBy'] }
        : { orderBy?: BlockedUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedUser model
   */
  readonly fields: BlockedUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blockedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedUser model
   */
  interface BlockedUserFieldRefs {
    readonly id: FieldRef<"BlockedUser", 'String'>
    readonly userID: FieldRef<"BlockedUser", 'String'>
    readonly blockedID: FieldRef<"BlockedUser", 'String'>
    readonly createdAt: FieldRef<"BlockedUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockedUser findUnique
   */
  export type BlockedUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findUniqueOrThrow
   */
  export type BlockedUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findFirst
   */
  export type BlockedUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findFirstOrThrow
   */
  export type BlockedUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findMany
   */
  export type BlockedUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUsers to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser create
   */
  export type BlockedUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockedUser.
     */
    data: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
  }

  /**
   * BlockedUser createMany
   */
  export type BlockedUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedUser createManyAndReturn
   */
  export type BlockedUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUser update
   */
  export type BlockedUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockedUser.
     */
    data: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
    /**
     * Choose, which BlockedUser to update.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser updateMany
   */
  export type BlockedUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedUsers.
     */
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUsers to update
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to update.
     */
    limit?: number
  }

  /**
   * BlockedUser updateManyAndReturn
   */
  export type BlockedUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * The data used to update BlockedUsers.
     */
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUsers to update
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUser upsert
   */
  export type BlockedUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockedUser to update in case it exists.
     */
    where: BlockedUserWhereUniqueInput
    /**
     * In case the BlockedUser found by the `where` argument doesn't exist, create a new BlockedUser with this data.
     */
    create: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
    /**
     * In case the BlockedUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
  }

  /**
   * BlockedUser delete
   */
  export type BlockedUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter which BlockedUser to delete.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser deleteMany
   */
  export type BlockedUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUsers to delete
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to delete.
     */
    limit?: number
  }

  /**
   * BlockedUser without action
   */
  export type BlockedUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
  }


  /**
   * Model ReportUser
   */

  export type AggregateReportUser = {
    _count: ReportUserCountAggregateOutputType | null
    _min: ReportUserMinAggregateOutputType | null
    _max: ReportUserMaxAggregateOutputType | null
  }

  export type ReportUserMinAggregateOutputType = {
    id: string | null
    userID: string | null
    reportedID: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReportUserMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    reportedID: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReportUserCountAggregateOutputType = {
    id: number
    userID: number
    reportedID: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ReportUserMinAggregateInputType = {
    id?: true
    userID?: true
    reportedID?: true
    reason?: true
    createdAt?: true
  }

  export type ReportUserMaxAggregateInputType = {
    id?: true
    userID?: true
    reportedID?: true
    reason?: true
    createdAt?: true
  }

  export type ReportUserCountAggregateInputType = {
    id?: true
    userID?: true
    reportedID?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ReportUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportUser to aggregate.
     */
    where?: ReportUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUsers to fetch.
     */
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportUsers
    **/
    _count?: true | ReportUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportUserMaxAggregateInputType
  }

  export type GetReportUserAggregateType<T extends ReportUserAggregateArgs> = {
        [P in keyof T & keyof AggregateReportUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportUser[P]>
      : GetScalarType<T[P], AggregateReportUser[P]>
  }




  export type ReportUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUserWhereInput
    orderBy?: ReportUserOrderByWithAggregationInput | ReportUserOrderByWithAggregationInput[]
    by: ReportUserScalarFieldEnum[] | ReportUserScalarFieldEnum
    having?: ReportUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportUserCountAggregateInputType | true
    _min?: ReportUserMinAggregateInputType
    _max?: ReportUserMaxAggregateInputType
  }

  export type ReportUserGroupByOutputType = {
    id: string
    userID: string
    reportedID: string
    reason: string | null
    createdAt: Date
    _count: ReportUserCountAggregateOutputType | null
    _min: ReportUserMinAggregateOutputType | null
    _max: ReportUserMaxAggregateOutputType | null
  }

  type GetReportUserGroupByPayload<T extends ReportUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportUserGroupByOutputType[P]>
            : GetScalarType<T[P], ReportUserGroupByOutputType[P]>
        }
      >
    >


  export type ReportUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    reportedID?: boolean
    reason?: boolean
    createdAt?: boolean
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportUser"]>

  export type ReportUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    reportedID?: boolean
    reason?: boolean
    createdAt?: boolean
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportUser"]>

  export type ReportUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    reportedID?: boolean
    reason?: boolean
    createdAt?: boolean
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportUser"]>

  export type ReportUserSelectScalar = {
    id?: boolean
    userID?: boolean
    reportedID?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ReportUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "reportedID" | "reason" | "createdAt", ExtArgs["result"]["reportUser"]>
  export type ReportUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportUser"
    objects: {
      reportedUser: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      reportedID: string
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["reportUser"]>
    composites: {}
  }

  type ReportUserGetPayload<S extends boolean | null | undefined | ReportUserDefaultArgs> = $Result.GetResult<Prisma.$ReportUserPayload, S>

  type ReportUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportUserCountAggregateInputType | true
    }

  export interface ReportUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportUser'], meta: { name: 'ReportUser' } }
    /**
     * Find zero or one ReportUser that matches the filter.
     * @param {ReportUserFindUniqueArgs} args - Arguments to find a ReportUser
     * @example
     * // Get one ReportUser
     * const reportUser = await prisma.reportUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportUserFindUniqueArgs>(args: SelectSubset<T, ReportUserFindUniqueArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportUserFindUniqueOrThrowArgs} args - Arguments to find a ReportUser
     * @example
     * // Get one ReportUser
     * const reportUser = await prisma.reportUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserFindFirstArgs} args - Arguments to find a ReportUser
     * @example
     * // Get one ReportUser
     * const reportUser = await prisma.reportUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportUserFindFirstArgs>(args?: SelectSubset<T, ReportUserFindFirstArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserFindFirstOrThrowArgs} args - Arguments to find a ReportUser
     * @example
     * // Get one ReportUser
     * const reportUser = await prisma.reportUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportUsers
     * const reportUsers = await prisma.reportUser.findMany()
     * 
     * // Get first 10 ReportUsers
     * const reportUsers = await prisma.reportUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportUserWithIdOnly = await prisma.reportUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportUserFindManyArgs>(args?: SelectSubset<T, ReportUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportUser.
     * @param {ReportUserCreateArgs} args - Arguments to create a ReportUser.
     * @example
     * // Create one ReportUser
     * const ReportUser = await prisma.reportUser.create({
     *   data: {
     *     // ... data to create a ReportUser
     *   }
     * })
     * 
     */
    create<T extends ReportUserCreateArgs>(args: SelectSubset<T, ReportUserCreateArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportUsers.
     * @param {ReportUserCreateManyArgs} args - Arguments to create many ReportUsers.
     * @example
     * // Create many ReportUsers
     * const reportUser = await prisma.reportUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportUserCreateManyArgs>(args?: SelectSubset<T, ReportUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportUsers and returns the data saved in the database.
     * @param {ReportUserCreateManyAndReturnArgs} args - Arguments to create many ReportUsers.
     * @example
     * // Create many ReportUsers
     * const reportUser = await prisma.reportUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportUsers and only return the `id`
     * const reportUserWithIdOnly = await prisma.reportUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportUserCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportUser.
     * @param {ReportUserDeleteArgs} args - Arguments to delete one ReportUser.
     * @example
     * // Delete one ReportUser
     * const ReportUser = await prisma.reportUser.delete({
     *   where: {
     *     // ... filter to delete one ReportUser
     *   }
     * })
     * 
     */
    delete<T extends ReportUserDeleteArgs>(args: SelectSubset<T, ReportUserDeleteArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportUser.
     * @param {ReportUserUpdateArgs} args - Arguments to update one ReportUser.
     * @example
     * // Update one ReportUser
     * const reportUser = await prisma.reportUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUserUpdateArgs>(args: SelectSubset<T, ReportUserUpdateArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportUsers.
     * @param {ReportUserDeleteManyArgs} args - Arguments to filter ReportUsers to delete.
     * @example
     * // Delete a few ReportUsers
     * const { count } = await prisma.reportUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportUserDeleteManyArgs>(args?: SelectSubset<T, ReportUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportUsers
     * const reportUser = await prisma.reportUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUserUpdateManyArgs>(args: SelectSubset<T, ReportUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportUsers and returns the data updated in the database.
     * @param {ReportUserUpdateManyAndReturnArgs} args - Arguments to update many ReportUsers.
     * @example
     * // Update many ReportUsers
     * const reportUser = await prisma.reportUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportUsers and only return the `id`
     * const reportUserWithIdOnly = await prisma.reportUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUserUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportUser.
     * @param {ReportUserUpsertArgs} args - Arguments to update or create a ReportUser.
     * @example
     * // Update or create a ReportUser
     * const reportUser = await prisma.reportUser.upsert({
     *   create: {
     *     // ... data to create a ReportUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportUser we want to update
     *   }
     * })
     */
    upsert<T extends ReportUserUpsertArgs>(args: SelectSubset<T, ReportUserUpsertArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserCountArgs} args - Arguments to filter ReportUsers to count.
     * @example
     * // Count the number of ReportUsers
     * const count = await prisma.reportUser.count({
     *   where: {
     *     // ... the filter for the ReportUsers we want to count
     *   }
     * })
    **/
    count<T extends ReportUserCountArgs>(
      args?: Subset<T, ReportUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportUserAggregateArgs>(args: Subset<T, ReportUserAggregateArgs>): Prisma.PrismaPromise<GetReportUserAggregateType<T>>

    /**
     * Group by ReportUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportUserGroupByArgs['orderBy'] }
        : { orderBy?: ReportUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportUser model
   */
  readonly fields: ReportUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reportedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportUser model
   */
  interface ReportUserFieldRefs {
    readonly id: FieldRef<"ReportUser", 'String'>
    readonly userID: FieldRef<"ReportUser", 'String'>
    readonly reportedID: FieldRef<"ReportUser", 'String'>
    readonly reason: FieldRef<"ReportUser", 'String'>
    readonly createdAt: FieldRef<"ReportUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportUser findUnique
   */
  export type ReportUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUser to fetch.
     */
    where: ReportUserWhereUniqueInput
  }

  /**
   * ReportUser findUniqueOrThrow
   */
  export type ReportUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUser to fetch.
     */
    where: ReportUserWhereUniqueInput
  }

  /**
   * ReportUser findFirst
   */
  export type ReportUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUser to fetch.
     */
    where?: ReportUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUsers to fetch.
     */
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportUsers.
     */
    cursor?: ReportUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportUsers.
     */
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * ReportUser findFirstOrThrow
   */
  export type ReportUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUser to fetch.
     */
    where?: ReportUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUsers to fetch.
     */
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportUsers.
     */
    cursor?: ReportUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportUsers.
     */
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * ReportUser findMany
   */
  export type ReportUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUsers to fetch.
     */
    where?: ReportUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUsers to fetch.
     */
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportUsers.
     */
    cursor?: ReportUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUsers.
     */
    skip?: number
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * ReportUser create
   */
  export type ReportUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportUser.
     */
    data: XOR<ReportUserCreateInput, ReportUserUncheckedCreateInput>
  }

  /**
   * ReportUser createMany
   */
  export type ReportUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportUsers.
     */
    data: ReportUserCreateManyInput | ReportUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportUser createManyAndReturn
   */
  export type ReportUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * The data used to create many ReportUsers.
     */
    data: ReportUserCreateManyInput | ReportUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportUser update
   */
  export type ReportUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportUser.
     */
    data: XOR<ReportUserUpdateInput, ReportUserUncheckedUpdateInput>
    /**
     * Choose, which ReportUser to update.
     */
    where: ReportUserWhereUniqueInput
  }

  /**
   * ReportUser updateMany
   */
  export type ReportUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportUsers.
     */
    data: XOR<ReportUserUpdateManyMutationInput, ReportUserUncheckedUpdateManyInput>
    /**
     * Filter which ReportUsers to update
     */
    where?: ReportUserWhereInput
    /**
     * Limit how many ReportUsers to update.
     */
    limit?: number
  }

  /**
   * ReportUser updateManyAndReturn
   */
  export type ReportUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * The data used to update ReportUsers.
     */
    data: XOR<ReportUserUpdateManyMutationInput, ReportUserUncheckedUpdateManyInput>
    /**
     * Filter which ReportUsers to update
     */
    where?: ReportUserWhereInput
    /**
     * Limit how many ReportUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportUser upsert
   */
  export type ReportUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportUser to update in case it exists.
     */
    where: ReportUserWhereUniqueInput
    /**
     * In case the ReportUser found by the `where` argument doesn't exist, create a new ReportUser with this data.
     */
    create: XOR<ReportUserCreateInput, ReportUserUncheckedCreateInput>
    /**
     * In case the ReportUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUserUpdateInput, ReportUserUncheckedUpdateInput>
  }

  /**
   * ReportUser delete
   */
  export type ReportUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter which ReportUser to delete.
     */
    where: ReportUserWhereUniqueInput
  }

  /**
   * ReportUser deleteMany
   */
  export type ReportUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportUsers to delete
     */
    where?: ReportUserWhereInput
    /**
     * Limit how many ReportUsers to delete.
     */
    limit?: number
  }

  /**
   * ReportUser without action
   */
  export type ReportUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
  }


  /**
   * Model ReadHistory
   */

  export type AggregateReadHistory = {
    _count: ReadHistoryCountAggregateOutputType | null
    _min: ReadHistoryMinAggregateOutputType | null
    _max: ReadHistoryMaxAggregateOutputType | null
  }

  export type ReadHistoryMinAggregateOutputType = {
    id: string | null
    userID: string | null
    blogId: string | null
    createdAt: Date | null
  }

  export type ReadHistoryMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    blogId: string | null
    createdAt: Date | null
  }

  export type ReadHistoryCountAggregateOutputType = {
    id: number
    userID: number
    blogId: number
    createdAt: number
    _all: number
  }


  export type ReadHistoryMinAggregateInputType = {
    id?: true
    userID?: true
    blogId?: true
    createdAt?: true
  }

  export type ReadHistoryMaxAggregateInputType = {
    id?: true
    userID?: true
    blogId?: true
    createdAt?: true
  }

  export type ReadHistoryCountAggregateInputType = {
    id?: true
    userID?: true
    blogId?: true
    createdAt?: true
    _all?: true
  }

  export type ReadHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReadHistory to aggregate.
     */
    where?: ReadHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadHistories to fetch.
     */
    orderBy?: ReadHistoryOrderByWithRelationInput | ReadHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReadHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReadHistories
    **/
    _count?: true | ReadHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReadHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReadHistoryMaxAggregateInputType
  }

  export type GetReadHistoryAggregateType<T extends ReadHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateReadHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReadHistory[P]>
      : GetScalarType<T[P], AggregateReadHistory[P]>
  }




  export type ReadHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadHistoryWhereInput
    orderBy?: ReadHistoryOrderByWithAggregationInput | ReadHistoryOrderByWithAggregationInput[]
    by: ReadHistoryScalarFieldEnum[] | ReadHistoryScalarFieldEnum
    having?: ReadHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReadHistoryCountAggregateInputType | true
    _min?: ReadHistoryMinAggregateInputType
    _max?: ReadHistoryMaxAggregateInputType
  }

  export type ReadHistoryGroupByOutputType = {
    id: string
    userID: string
    blogId: string
    createdAt: Date
    _count: ReadHistoryCountAggregateOutputType | null
    _min: ReadHistoryMinAggregateOutputType | null
    _max: ReadHistoryMaxAggregateOutputType | null
  }

  type GetReadHistoryGroupByPayload<T extends ReadHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReadHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReadHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReadHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ReadHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ReadHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogId?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readHistory"]>

  export type ReadHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogId?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readHistory"]>

  export type ReadHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogId?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readHistory"]>

  export type ReadHistorySelectScalar = {
    id?: boolean
    userID?: boolean
    blogId?: boolean
    createdAt?: boolean
  }

  export type ReadHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "blogId" | "createdAt", ExtArgs["result"]["readHistory"]>
  export type ReadHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReadHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReadHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReadHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReadHistory"
    objects: {
      blog: Prisma.$BlogPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      blogId: string
      createdAt: Date
    }, ExtArgs["result"]["readHistory"]>
    composites: {}
  }

  type ReadHistoryGetPayload<S extends boolean | null | undefined | ReadHistoryDefaultArgs> = $Result.GetResult<Prisma.$ReadHistoryPayload, S>

  type ReadHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReadHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReadHistoryCountAggregateInputType | true
    }

  export interface ReadHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReadHistory'], meta: { name: 'ReadHistory' } }
    /**
     * Find zero or one ReadHistory that matches the filter.
     * @param {ReadHistoryFindUniqueArgs} args - Arguments to find a ReadHistory
     * @example
     * // Get one ReadHistory
     * const readHistory = await prisma.readHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReadHistoryFindUniqueArgs>(args: SelectSubset<T, ReadHistoryFindUniqueArgs<ExtArgs>>): Prisma__ReadHistoryClient<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReadHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReadHistoryFindUniqueOrThrowArgs} args - Arguments to find a ReadHistory
     * @example
     * // Get one ReadHistory
     * const readHistory = await prisma.readHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReadHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ReadHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReadHistoryClient<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReadHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadHistoryFindFirstArgs} args - Arguments to find a ReadHistory
     * @example
     * // Get one ReadHistory
     * const readHistory = await prisma.readHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReadHistoryFindFirstArgs>(args?: SelectSubset<T, ReadHistoryFindFirstArgs<ExtArgs>>): Prisma__ReadHistoryClient<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReadHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadHistoryFindFirstOrThrowArgs} args - Arguments to find a ReadHistory
     * @example
     * // Get one ReadHistory
     * const readHistory = await prisma.readHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReadHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ReadHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReadHistoryClient<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReadHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReadHistories
     * const readHistories = await prisma.readHistory.findMany()
     * 
     * // Get first 10 ReadHistories
     * const readHistories = await prisma.readHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const readHistoryWithIdOnly = await prisma.readHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReadHistoryFindManyArgs>(args?: SelectSubset<T, ReadHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReadHistory.
     * @param {ReadHistoryCreateArgs} args - Arguments to create a ReadHistory.
     * @example
     * // Create one ReadHistory
     * const ReadHistory = await prisma.readHistory.create({
     *   data: {
     *     // ... data to create a ReadHistory
     *   }
     * })
     * 
     */
    create<T extends ReadHistoryCreateArgs>(args: SelectSubset<T, ReadHistoryCreateArgs<ExtArgs>>): Prisma__ReadHistoryClient<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReadHistories.
     * @param {ReadHistoryCreateManyArgs} args - Arguments to create many ReadHistories.
     * @example
     * // Create many ReadHistories
     * const readHistory = await prisma.readHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReadHistoryCreateManyArgs>(args?: SelectSubset<T, ReadHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReadHistories and returns the data saved in the database.
     * @param {ReadHistoryCreateManyAndReturnArgs} args - Arguments to create many ReadHistories.
     * @example
     * // Create many ReadHistories
     * const readHistory = await prisma.readHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReadHistories and only return the `id`
     * const readHistoryWithIdOnly = await prisma.readHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReadHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ReadHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReadHistory.
     * @param {ReadHistoryDeleteArgs} args - Arguments to delete one ReadHistory.
     * @example
     * // Delete one ReadHistory
     * const ReadHistory = await prisma.readHistory.delete({
     *   where: {
     *     // ... filter to delete one ReadHistory
     *   }
     * })
     * 
     */
    delete<T extends ReadHistoryDeleteArgs>(args: SelectSubset<T, ReadHistoryDeleteArgs<ExtArgs>>): Prisma__ReadHistoryClient<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReadHistory.
     * @param {ReadHistoryUpdateArgs} args - Arguments to update one ReadHistory.
     * @example
     * // Update one ReadHistory
     * const readHistory = await prisma.readHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReadHistoryUpdateArgs>(args: SelectSubset<T, ReadHistoryUpdateArgs<ExtArgs>>): Prisma__ReadHistoryClient<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReadHistories.
     * @param {ReadHistoryDeleteManyArgs} args - Arguments to filter ReadHistories to delete.
     * @example
     * // Delete a few ReadHistories
     * const { count } = await prisma.readHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReadHistoryDeleteManyArgs>(args?: SelectSubset<T, ReadHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReadHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReadHistories
     * const readHistory = await prisma.readHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReadHistoryUpdateManyArgs>(args: SelectSubset<T, ReadHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReadHistories and returns the data updated in the database.
     * @param {ReadHistoryUpdateManyAndReturnArgs} args - Arguments to update many ReadHistories.
     * @example
     * // Update many ReadHistories
     * const readHistory = await prisma.readHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReadHistories and only return the `id`
     * const readHistoryWithIdOnly = await prisma.readHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReadHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ReadHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReadHistory.
     * @param {ReadHistoryUpsertArgs} args - Arguments to update or create a ReadHistory.
     * @example
     * // Update or create a ReadHistory
     * const readHistory = await prisma.readHistory.upsert({
     *   create: {
     *     // ... data to create a ReadHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReadHistory we want to update
     *   }
     * })
     */
    upsert<T extends ReadHistoryUpsertArgs>(args: SelectSubset<T, ReadHistoryUpsertArgs<ExtArgs>>): Prisma__ReadHistoryClient<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReadHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadHistoryCountArgs} args - Arguments to filter ReadHistories to count.
     * @example
     * // Count the number of ReadHistories
     * const count = await prisma.readHistory.count({
     *   where: {
     *     // ... the filter for the ReadHistories we want to count
     *   }
     * })
    **/
    count<T extends ReadHistoryCountArgs>(
      args?: Subset<T, ReadHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReadHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReadHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReadHistoryAggregateArgs>(args: Subset<T, ReadHistoryAggregateArgs>): Prisma.PrismaPromise<GetReadHistoryAggregateType<T>>

    /**
     * Group by ReadHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReadHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReadHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ReadHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReadHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReadHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReadHistory model
   */
  readonly fields: ReadHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReadHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReadHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReadHistory model
   */
  interface ReadHistoryFieldRefs {
    readonly id: FieldRef<"ReadHistory", 'String'>
    readonly userID: FieldRef<"ReadHistory", 'String'>
    readonly blogId: FieldRef<"ReadHistory", 'String'>
    readonly createdAt: FieldRef<"ReadHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReadHistory findUnique
   */
  export type ReadHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ReadHistory to fetch.
     */
    where: ReadHistoryWhereUniqueInput
  }

  /**
   * ReadHistory findUniqueOrThrow
   */
  export type ReadHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ReadHistory to fetch.
     */
    where: ReadHistoryWhereUniqueInput
  }

  /**
   * ReadHistory findFirst
   */
  export type ReadHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ReadHistory to fetch.
     */
    where?: ReadHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadHistories to fetch.
     */
    orderBy?: ReadHistoryOrderByWithRelationInput | ReadHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReadHistories.
     */
    cursor?: ReadHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReadHistories.
     */
    distinct?: ReadHistoryScalarFieldEnum | ReadHistoryScalarFieldEnum[]
  }

  /**
   * ReadHistory findFirstOrThrow
   */
  export type ReadHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ReadHistory to fetch.
     */
    where?: ReadHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadHistories to fetch.
     */
    orderBy?: ReadHistoryOrderByWithRelationInput | ReadHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReadHistories.
     */
    cursor?: ReadHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReadHistories.
     */
    distinct?: ReadHistoryScalarFieldEnum | ReadHistoryScalarFieldEnum[]
  }

  /**
   * ReadHistory findMany
   */
  export type ReadHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ReadHistories to fetch.
     */
    where?: ReadHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadHistories to fetch.
     */
    orderBy?: ReadHistoryOrderByWithRelationInput | ReadHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReadHistories.
     */
    cursor?: ReadHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadHistories.
     */
    skip?: number
    distinct?: ReadHistoryScalarFieldEnum | ReadHistoryScalarFieldEnum[]
  }

  /**
   * ReadHistory create
   */
  export type ReadHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ReadHistory.
     */
    data: XOR<ReadHistoryCreateInput, ReadHistoryUncheckedCreateInput>
  }

  /**
   * ReadHistory createMany
   */
  export type ReadHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReadHistories.
     */
    data: ReadHistoryCreateManyInput | ReadHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReadHistory createManyAndReturn
   */
  export type ReadHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ReadHistories.
     */
    data: ReadHistoryCreateManyInput | ReadHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReadHistory update
   */
  export type ReadHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ReadHistory.
     */
    data: XOR<ReadHistoryUpdateInput, ReadHistoryUncheckedUpdateInput>
    /**
     * Choose, which ReadHistory to update.
     */
    where: ReadHistoryWhereUniqueInput
  }

  /**
   * ReadHistory updateMany
   */
  export type ReadHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReadHistories.
     */
    data: XOR<ReadHistoryUpdateManyMutationInput, ReadHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ReadHistories to update
     */
    where?: ReadHistoryWhereInput
    /**
     * Limit how many ReadHistories to update.
     */
    limit?: number
  }

  /**
   * ReadHistory updateManyAndReturn
   */
  export type ReadHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ReadHistories.
     */
    data: XOR<ReadHistoryUpdateManyMutationInput, ReadHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ReadHistories to update
     */
    where?: ReadHistoryWhereInput
    /**
     * Limit how many ReadHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReadHistory upsert
   */
  export type ReadHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ReadHistory to update in case it exists.
     */
    where: ReadHistoryWhereUniqueInput
    /**
     * In case the ReadHistory found by the `where` argument doesn't exist, create a new ReadHistory with this data.
     */
    create: XOR<ReadHistoryCreateInput, ReadHistoryUncheckedCreateInput>
    /**
     * In case the ReadHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReadHistoryUpdateInput, ReadHistoryUncheckedUpdateInput>
  }

  /**
   * ReadHistory delete
   */
  export type ReadHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    /**
     * Filter which ReadHistory to delete.
     */
    where: ReadHistoryWhereUniqueInput
  }

  /**
   * ReadHistory deleteMany
   */
  export type ReadHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReadHistories to delete
     */
    where?: ReadHistoryWhereInput
    /**
     * Limit how many ReadHistories to delete.
     */
    limit?: number
  }

  /**
   * ReadHistory without action
   */
  export type ReadHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogAvgAggregateOutputType = {
    viewCount: number | null
    readCount: number | null
  }

  export type BlogSumAggregateOutputType = {
    viewCount: number | null
    readCount: number | null
  }

  export type BlogMinAggregateOutputType = {
    id: string | null
    userID: string | null
    title: string | null
    content: string | null
    thumbnail: string | null
    isMemberOnly: boolean | null
    isPublished: boolean | null
    viewCount: number | null
    readCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    title: string | null
    content: string | null
    thumbnail: string | null
    isMemberOnly: boolean | null
    isPublished: boolean | null
    viewCount: number | null
    readCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    userID: number
    title: number
    content: number
    thumbnail: number
    isMemberOnly: number
    isPublished: number
    viewCount: number
    readCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogAvgAggregateInputType = {
    viewCount?: true
    readCount?: true
  }

  export type BlogSumAggregateInputType = {
    viewCount?: true
    readCount?: true
  }

  export type BlogMinAggregateInputType = {
    id?: true
    userID?: true
    title?: true
    content?: true
    thumbnail?: true
    isMemberOnly?: true
    isPublished?: true
    viewCount?: true
    readCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    userID?: true
    title?: true
    content?: true
    thumbnail?: true
    isMemberOnly?: true
    isPublished?: true
    viewCount?: true
    readCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    userID?: true
    title?: true
    content?: true
    thumbnail?: true
    isMemberOnly?: true
    isPublished?: true
    viewCount?: true
    readCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blog to aggregate.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithAggregationInput | BlogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _avg?: BlogAvgAggregateInputType
    _sum?: BlogSumAggregateInputType
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    id: string
    userID: string
    title: string
    content: string
    thumbnail: string | null
    isMemberOnly: boolean
    isPublished: boolean
    viewCount: number
    readCount: number
    createdAt: Date
    updatedAt: Date
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    title?: boolean
    content?: boolean
    thumbnail?: boolean
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: boolean
    readCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dislikes?: boolean | Blog$dislikesArgs<ExtArgs>
    likes?: boolean | Blog$likesArgs<ExtArgs>
    reports?: boolean | Blog$reportsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Blog$commentsArgs<ExtArgs>
    readHistories?: boolean | Blog$readHistoriesArgs<ExtArgs>
    savedBy?: boolean | Blog$savedByArgs<ExtArgs>
    topics?: boolean | Blog$topicsArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    title?: boolean
    content?: boolean
    thumbnail?: boolean
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: boolean
    readCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    title?: boolean
    content?: boolean
    thumbnail?: boolean
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: boolean
    readCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectScalar = {
    id?: boolean
    userID?: boolean
    title?: boolean
    content?: boolean
    thumbnail?: boolean
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: boolean
    readCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "title" | "content" | "thumbnail" | "isMemberOnly" | "isPublished" | "viewCount" | "readCount" | "createdAt" | "updatedAt", ExtArgs["result"]["blog"]>
  export type BlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dislikes?: boolean | Blog$dislikesArgs<ExtArgs>
    likes?: boolean | Blog$likesArgs<ExtArgs>
    reports?: boolean | Blog$reportsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Blog$commentsArgs<ExtArgs>
    readHistories?: boolean | Blog$readHistoriesArgs<ExtArgs>
    savedBy?: boolean | Blog$savedByArgs<ExtArgs>
    topics?: boolean | Blog$topicsArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blog"
    objects: {
      dislikes: Prisma.$BlogDisLikePayload<ExtArgs>[]
      likes: Prisma.$BlogLikePayload<ExtArgs>[]
      reports: Prisma.$ReportBlogPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      readHistories: Prisma.$ReadHistoryPayload<ExtArgs>[]
      savedBy: Prisma.$SavedBlogPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      title: string
      content: string
      thumbnail: string | null
      isMemberOnly: boolean
      isPublished: boolean
      viewCount: number
      readCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }

  type BlogGetPayload<S extends boolean | null | undefined | BlogDefaultArgs> = $Result.GetResult<Prisma.$BlogPayload, S>

  type BlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface BlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blog'], meta: { name: 'Blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogFindUniqueArgs>(args: SelectSubset<T, BlogFindUniqueArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogFindFirstArgs>(args?: SelectSubset<T, BlogFindFirstArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogFindManyArgs>(args?: SelectSubset<T, BlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
     */
    create<T extends BlogCreateArgs>(args: SelectSubset<T, BlogCreateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blogs.
     * @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCreateManyArgs>(args?: SelectSubset<T, BlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blogs and returns the data saved in the database.
     * @param {BlogCreateManyAndReturnArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blogs and only return the `id`
     * const blogWithIdOnly = await prisma.blog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
     */
    delete<T extends BlogDeleteArgs>(args: SelectSubset<T, BlogDeleteArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogUpdateArgs>(args: SelectSubset<T, BlogUpdateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogDeleteManyArgs>(args?: SelectSubset<T, BlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogUpdateManyArgs>(args: SelectSubset<T, BlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs and returns the data updated in the database.
     * @param {BlogUpdateManyAndReturnArgs} args - Arguments to update many Blogs.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blogs and only return the `id`
     * const blogWithIdOnly = await prisma.blog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
     */
    upsert<T extends BlogUpsertArgs>(args: SelectSubset<T, BlogUpsertArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blog model
   */
  readonly fields: BlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dislikes<T extends Blog$dislikesArgs<ExtArgs> = {}>(args?: Subset<T, Blog$dislikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Blog$likesArgs<ExtArgs> = {}>(args?: Subset<T, Blog$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Blog$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Blog$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends Blog$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Blog$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readHistories<T extends Blog$readHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Blog$readHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedBy<T extends Blog$savedByArgs<ExtArgs> = {}>(args?: Subset<T, Blog$savedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topics<T extends Blog$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Blog$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blog model
   */
  interface BlogFieldRefs {
    readonly id: FieldRef<"Blog", 'String'>
    readonly userID: FieldRef<"Blog", 'String'>
    readonly title: FieldRef<"Blog", 'String'>
    readonly content: FieldRef<"Blog", 'String'>
    readonly thumbnail: FieldRef<"Blog", 'String'>
    readonly isMemberOnly: FieldRef<"Blog", 'Boolean'>
    readonly isPublished: FieldRef<"Blog", 'Boolean'>
    readonly viewCount: FieldRef<"Blog", 'Int'>
    readonly readCount: FieldRef<"Blog", 'Int'>
    readonly createdAt: FieldRef<"Blog", 'DateTime'>
    readonly updatedAt: FieldRef<"Blog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findUniqueOrThrow
   */
  export type BlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findFirstOrThrow
   */
  export type BlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findMany
   */
  export type BlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog create
   */
  export type BlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to create a Blog.
     */
    data: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }

  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blog createManyAndReturn
   */
  export type BlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blog update
   */
  export type BlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to update a Blog.
     */
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to update.
     */
    limit?: number
  }

  /**
   * Blog updateManyAndReturn
   */
  export type BlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blog upsert
   */
  export type BlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The filter to search for the Blog to update in case it exists.
     */
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     */
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }

  /**
   * Blog delete
   */
  export type BlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter which Blog to delete.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to delete.
     */
    limit?: number
  }

  /**
   * Blog.dislikes
   */
  export type Blog$dislikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    where?: BlogDisLikeWhereInput
    orderBy?: BlogDisLikeOrderByWithRelationInput | BlogDisLikeOrderByWithRelationInput[]
    cursor?: BlogDisLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogDisLikeScalarFieldEnum | BlogDisLikeScalarFieldEnum[]
  }

  /**
   * Blog.likes
   */
  export type Blog$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    where?: BlogLikeWhereInput
    orderBy?: BlogLikeOrderByWithRelationInput | BlogLikeOrderByWithRelationInput[]
    cursor?: BlogLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogLikeScalarFieldEnum | BlogLikeScalarFieldEnum[]
  }

  /**
   * Blog.reports
   */
  export type Blog$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    where?: ReportBlogWhereInput
    orderBy?: ReportBlogOrderByWithRelationInput | ReportBlogOrderByWithRelationInput[]
    cursor?: ReportBlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportBlogScalarFieldEnum | ReportBlogScalarFieldEnum[]
  }

  /**
   * Blog.comments
   */
  export type Blog$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Blog.readHistories
   */
  export type Blog$readHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadHistory
     */
    select?: ReadHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadHistory
     */
    omit?: ReadHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadHistoryInclude<ExtArgs> | null
    where?: ReadHistoryWhereInput
    orderBy?: ReadHistoryOrderByWithRelationInput | ReadHistoryOrderByWithRelationInput[]
    cursor?: ReadHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadHistoryScalarFieldEnum | ReadHistoryScalarFieldEnum[]
  }

  /**
   * Blog.savedBy
   */
  export type Blog$savedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    where?: SavedBlogWhereInput
    orderBy?: SavedBlogOrderByWithRelationInput | SavedBlogOrderByWithRelationInput[]
    cursor?: SavedBlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedBlogScalarFieldEnum | SavedBlogScalarFieldEnum[]
  }

  /**
   * Blog.topics
   */
  export type Blog$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Blog without action
   */
  export type BlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
  }


  /**
   * Model BlogLike
   */

  export type AggregateBlogLike = {
    _count: BlogLikeCountAggregateOutputType | null
    _min: BlogLikeMinAggregateOutputType | null
    _max: BlogLikeMaxAggregateOutputType | null
  }

  export type BlogLikeMinAggregateOutputType = {
    id: string | null
    userID: string | null
    blogID: string | null
    createdAt: Date | null
  }

  export type BlogLikeMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    blogID: string | null
    createdAt: Date | null
  }

  export type BlogLikeCountAggregateOutputType = {
    id: number
    userID: number
    blogID: number
    createdAt: number
    _all: number
  }


  export type BlogLikeMinAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
  }

  export type BlogLikeMaxAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
  }

  export type BlogLikeCountAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
    _all?: true
  }

  export type BlogLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogLike to aggregate.
     */
    where?: BlogLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogLikes to fetch.
     */
    orderBy?: BlogLikeOrderByWithRelationInput | BlogLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogLikes
    **/
    _count?: true | BlogLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogLikeMaxAggregateInputType
  }

  export type GetBlogLikeAggregateType<T extends BlogLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogLike[P]>
      : GetScalarType<T[P], AggregateBlogLike[P]>
  }




  export type BlogLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogLikeWhereInput
    orderBy?: BlogLikeOrderByWithAggregationInput | BlogLikeOrderByWithAggregationInput[]
    by: BlogLikeScalarFieldEnum[] | BlogLikeScalarFieldEnum
    having?: BlogLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogLikeCountAggregateInputType | true
    _min?: BlogLikeMinAggregateInputType
    _max?: BlogLikeMaxAggregateInputType
  }

  export type BlogLikeGroupByOutputType = {
    id: string
    userID: string
    blogID: string
    createdAt: Date
    _count: BlogLikeCountAggregateOutputType | null
    _min: BlogLikeMinAggregateOutputType | null
    _max: BlogLikeMaxAggregateOutputType | null
  }

  type GetBlogLikeGroupByPayload<T extends BlogLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogLikeGroupByOutputType[P]>
            : GetScalarType<T[P], BlogLikeGroupByOutputType[P]>
        }
      >
    >


  export type BlogLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    likeNotifications?: boolean | BlogLike$likeNotificationsArgs<ExtArgs>
    _count?: boolean | BlogLikeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogLike"]>

  export type BlogLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogLike"]>

  export type BlogLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogLike"]>

  export type BlogLikeSelectScalar = {
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
  }

  export type BlogLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "blogID" | "createdAt", ExtArgs["result"]["blogLike"]>
  export type BlogLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    likeNotifications?: boolean | BlogLike$likeNotificationsArgs<ExtArgs>
    _count?: boolean | BlogLikeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogLike"
    objects: {
      blog: Prisma.$BlogPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      likeNotifications: Prisma.$LikeNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      blogID: string
      createdAt: Date
    }, ExtArgs["result"]["blogLike"]>
    composites: {}
  }

  type BlogLikeGetPayload<S extends boolean | null | undefined | BlogLikeDefaultArgs> = $Result.GetResult<Prisma.$BlogLikePayload, S>

  type BlogLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogLikeCountAggregateInputType | true
    }

  export interface BlogLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogLike'], meta: { name: 'BlogLike' } }
    /**
     * Find zero or one BlogLike that matches the filter.
     * @param {BlogLikeFindUniqueArgs} args - Arguments to find a BlogLike
     * @example
     * // Get one BlogLike
     * const blogLike = await prisma.blogLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogLikeFindUniqueArgs>(args: SelectSubset<T, BlogLikeFindUniqueArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogLikeFindUniqueOrThrowArgs} args - Arguments to find a BlogLike
     * @example
     * // Get one BlogLike
     * const blogLike = await prisma.blogLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogLikeFindFirstArgs} args - Arguments to find a BlogLike
     * @example
     * // Get one BlogLike
     * const blogLike = await prisma.blogLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogLikeFindFirstArgs>(args?: SelectSubset<T, BlogLikeFindFirstArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogLikeFindFirstOrThrowArgs} args - Arguments to find a BlogLike
     * @example
     * // Get one BlogLike
     * const blogLike = await prisma.blogLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogLikes
     * const blogLikes = await prisma.blogLike.findMany()
     * 
     * // Get first 10 BlogLikes
     * const blogLikes = await prisma.blogLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogLikeWithIdOnly = await prisma.blogLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogLikeFindManyArgs>(args?: SelectSubset<T, BlogLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogLike.
     * @param {BlogLikeCreateArgs} args - Arguments to create a BlogLike.
     * @example
     * // Create one BlogLike
     * const BlogLike = await prisma.blogLike.create({
     *   data: {
     *     // ... data to create a BlogLike
     *   }
     * })
     * 
     */
    create<T extends BlogLikeCreateArgs>(args: SelectSubset<T, BlogLikeCreateArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogLikes.
     * @param {BlogLikeCreateManyArgs} args - Arguments to create many BlogLikes.
     * @example
     * // Create many BlogLikes
     * const blogLike = await prisma.blogLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogLikeCreateManyArgs>(args?: SelectSubset<T, BlogLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogLikes and returns the data saved in the database.
     * @param {BlogLikeCreateManyAndReturnArgs} args - Arguments to create many BlogLikes.
     * @example
     * // Create many BlogLikes
     * const blogLike = await prisma.blogLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogLikes and only return the `id`
     * const blogLikeWithIdOnly = await prisma.blogLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogLike.
     * @param {BlogLikeDeleteArgs} args - Arguments to delete one BlogLike.
     * @example
     * // Delete one BlogLike
     * const BlogLike = await prisma.blogLike.delete({
     *   where: {
     *     // ... filter to delete one BlogLike
     *   }
     * })
     * 
     */
    delete<T extends BlogLikeDeleteArgs>(args: SelectSubset<T, BlogLikeDeleteArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogLike.
     * @param {BlogLikeUpdateArgs} args - Arguments to update one BlogLike.
     * @example
     * // Update one BlogLike
     * const blogLike = await prisma.blogLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogLikeUpdateArgs>(args: SelectSubset<T, BlogLikeUpdateArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogLikes.
     * @param {BlogLikeDeleteManyArgs} args - Arguments to filter BlogLikes to delete.
     * @example
     * // Delete a few BlogLikes
     * const { count } = await prisma.blogLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogLikeDeleteManyArgs>(args?: SelectSubset<T, BlogLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogLikes
     * const blogLike = await prisma.blogLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogLikeUpdateManyArgs>(args: SelectSubset<T, BlogLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogLikes and returns the data updated in the database.
     * @param {BlogLikeUpdateManyAndReturnArgs} args - Arguments to update many BlogLikes.
     * @example
     * // Update many BlogLikes
     * const blogLike = await prisma.blogLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogLikes and only return the `id`
     * const blogLikeWithIdOnly = await prisma.blogLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogLike.
     * @param {BlogLikeUpsertArgs} args - Arguments to update or create a BlogLike.
     * @example
     * // Update or create a BlogLike
     * const blogLike = await prisma.blogLike.upsert({
     *   create: {
     *     // ... data to create a BlogLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogLike we want to update
     *   }
     * })
     */
    upsert<T extends BlogLikeUpsertArgs>(args: SelectSubset<T, BlogLikeUpsertArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogLikeCountArgs} args - Arguments to filter BlogLikes to count.
     * @example
     * // Count the number of BlogLikes
     * const count = await prisma.blogLike.count({
     *   where: {
     *     // ... the filter for the BlogLikes we want to count
     *   }
     * })
    **/
    count<T extends BlogLikeCountArgs>(
      args?: Subset<T, BlogLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogLikeAggregateArgs>(args: Subset<T, BlogLikeAggregateArgs>): Prisma.PrismaPromise<GetBlogLikeAggregateType<T>>

    /**
     * Group by BlogLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogLikeGroupByArgs['orderBy'] }
        : { orderBy?: BlogLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogLike model
   */
  readonly fields: BlogLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    likeNotifications<T extends BlogLike$likeNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, BlogLike$likeNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogLike model
   */
  interface BlogLikeFieldRefs {
    readonly id: FieldRef<"BlogLike", 'String'>
    readonly userID: FieldRef<"BlogLike", 'String'>
    readonly blogID: FieldRef<"BlogLike", 'String'>
    readonly createdAt: FieldRef<"BlogLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogLike findUnique
   */
  export type BlogLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogLike to fetch.
     */
    where: BlogLikeWhereUniqueInput
  }

  /**
   * BlogLike findUniqueOrThrow
   */
  export type BlogLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogLike to fetch.
     */
    where: BlogLikeWhereUniqueInput
  }

  /**
   * BlogLike findFirst
   */
  export type BlogLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogLike to fetch.
     */
    where?: BlogLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogLikes to fetch.
     */
    orderBy?: BlogLikeOrderByWithRelationInput | BlogLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogLikes.
     */
    cursor?: BlogLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogLikes.
     */
    distinct?: BlogLikeScalarFieldEnum | BlogLikeScalarFieldEnum[]
  }

  /**
   * BlogLike findFirstOrThrow
   */
  export type BlogLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogLike to fetch.
     */
    where?: BlogLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogLikes to fetch.
     */
    orderBy?: BlogLikeOrderByWithRelationInput | BlogLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogLikes.
     */
    cursor?: BlogLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogLikes.
     */
    distinct?: BlogLikeScalarFieldEnum | BlogLikeScalarFieldEnum[]
  }

  /**
   * BlogLike findMany
   */
  export type BlogLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogLikes to fetch.
     */
    where?: BlogLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogLikes to fetch.
     */
    orderBy?: BlogLikeOrderByWithRelationInput | BlogLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogLikes.
     */
    cursor?: BlogLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogLikes.
     */
    skip?: number
    distinct?: BlogLikeScalarFieldEnum | BlogLikeScalarFieldEnum[]
  }

  /**
   * BlogLike create
   */
  export type BlogLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogLike.
     */
    data: XOR<BlogLikeCreateInput, BlogLikeUncheckedCreateInput>
  }

  /**
   * BlogLike createMany
   */
  export type BlogLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogLikes.
     */
    data: BlogLikeCreateManyInput | BlogLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogLike createManyAndReturn
   */
  export type BlogLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * The data used to create many BlogLikes.
     */
    data: BlogLikeCreateManyInput | BlogLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogLike update
   */
  export type BlogLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogLike.
     */
    data: XOR<BlogLikeUpdateInput, BlogLikeUncheckedUpdateInput>
    /**
     * Choose, which BlogLike to update.
     */
    where: BlogLikeWhereUniqueInput
  }

  /**
   * BlogLike updateMany
   */
  export type BlogLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogLikes.
     */
    data: XOR<BlogLikeUpdateManyMutationInput, BlogLikeUncheckedUpdateManyInput>
    /**
     * Filter which BlogLikes to update
     */
    where?: BlogLikeWhereInput
    /**
     * Limit how many BlogLikes to update.
     */
    limit?: number
  }

  /**
   * BlogLike updateManyAndReturn
   */
  export type BlogLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * The data used to update BlogLikes.
     */
    data: XOR<BlogLikeUpdateManyMutationInput, BlogLikeUncheckedUpdateManyInput>
    /**
     * Filter which BlogLikes to update
     */
    where?: BlogLikeWhereInput
    /**
     * Limit how many BlogLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogLike upsert
   */
  export type BlogLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogLike to update in case it exists.
     */
    where: BlogLikeWhereUniqueInput
    /**
     * In case the BlogLike found by the `where` argument doesn't exist, create a new BlogLike with this data.
     */
    create: XOR<BlogLikeCreateInput, BlogLikeUncheckedCreateInput>
    /**
     * In case the BlogLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogLikeUpdateInput, BlogLikeUncheckedUpdateInput>
  }

  /**
   * BlogLike delete
   */
  export type BlogLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
    /**
     * Filter which BlogLike to delete.
     */
    where: BlogLikeWhereUniqueInput
  }

  /**
   * BlogLike deleteMany
   */
  export type BlogLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogLikes to delete
     */
    where?: BlogLikeWhereInput
    /**
     * Limit how many BlogLikes to delete.
     */
    limit?: number
  }

  /**
   * BlogLike.likeNotifications
   */
  export type BlogLike$likeNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    where?: LikeNotificationWhereInput
    orderBy?: LikeNotificationOrderByWithRelationInput | LikeNotificationOrderByWithRelationInput[]
    cursor?: LikeNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeNotificationScalarFieldEnum | LikeNotificationScalarFieldEnum[]
  }

  /**
   * BlogLike without action
   */
  export type BlogLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogLike
     */
    select?: BlogLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogLike
     */
    omit?: BlogLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogLikeInclude<ExtArgs> | null
  }


  /**
   * Model BlogDisLike
   */

  export type AggregateBlogDisLike = {
    _count: BlogDisLikeCountAggregateOutputType | null
    _min: BlogDisLikeMinAggregateOutputType | null
    _max: BlogDisLikeMaxAggregateOutputType | null
  }

  export type BlogDisLikeMinAggregateOutputType = {
    id: string | null
    userID: string | null
    blogID: string | null
    createdAt: Date | null
  }

  export type BlogDisLikeMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    blogID: string | null
    createdAt: Date | null
  }

  export type BlogDisLikeCountAggregateOutputType = {
    id: number
    userID: number
    blogID: number
    createdAt: number
    _all: number
  }


  export type BlogDisLikeMinAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
  }

  export type BlogDisLikeMaxAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
  }

  export type BlogDisLikeCountAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
    _all?: true
  }

  export type BlogDisLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogDisLike to aggregate.
     */
    where?: BlogDisLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogDisLikes to fetch.
     */
    orderBy?: BlogDisLikeOrderByWithRelationInput | BlogDisLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogDisLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogDisLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogDisLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogDisLikes
    **/
    _count?: true | BlogDisLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogDisLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogDisLikeMaxAggregateInputType
  }

  export type GetBlogDisLikeAggregateType<T extends BlogDisLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogDisLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogDisLike[P]>
      : GetScalarType<T[P], AggregateBlogDisLike[P]>
  }




  export type BlogDisLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogDisLikeWhereInput
    orderBy?: BlogDisLikeOrderByWithAggregationInput | BlogDisLikeOrderByWithAggregationInput[]
    by: BlogDisLikeScalarFieldEnum[] | BlogDisLikeScalarFieldEnum
    having?: BlogDisLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogDisLikeCountAggregateInputType | true
    _min?: BlogDisLikeMinAggregateInputType
    _max?: BlogDisLikeMaxAggregateInputType
  }

  export type BlogDisLikeGroupByOutputType = {
    id: string
    userID: string
    blogID: string
    createdAt: Date
    _count: BlogDisLikeCountAggregateOutputType | null
    _min: BlogDisLikeMinAggregateOutputType | null
    _max: BlogDisLikeMaxAggregateOutputType | null
  }

  type GetBlogDisLikeGroupByPayload<T extends BlogDisLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogDisLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogDisLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogDisLikeGroupByOutputType[P]>
            : GetScalarType<T[P], BlogDisLikeGroupByOutputType[P]>
        }
      >
    >


  export type BlogDisLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogDisLike"]>

  export type BlogDisLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogDisLike"]>

  export type BlogDisLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogDisLike"]>

  export type BlogDisLikeSelectScalar = {
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
  }

  export type BlogDisLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "blogID" | "createdAt", ExtArgs["result"]["blogDisLike"]>
  export type BlogDisLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogDisLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogDisLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogDisLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogDisLike"
    objects: {
      blog: Prisma.$BlogPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      blogID: string
      createdAt: Date
    }, ExtArgs["result"]["blogDisLike"]>
    composites: {}
  }

  type BlogDisLikeGetPayload<S extends boolean | null | undefined | BlogDisLikeDefaultArgs> = $Result.GetResult<Prisma.$BlogDisLikePayload, S>

  type BlogDisLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogDisLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogDisLikeCountAggregateInputType | true
    }

  export interface BlogDisLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogDisLike'], meta: { name: 'BlogDisLike' } }
    /**
     * Find zero or one BlogDisLike that matches the filter.
     * @param {BlogDisLikeFindUniqueArgs} args - Arguments to find a BlogDisLike
     * @example
     * // Get one BlogDisLike
     * const blogDisLike = await prisma.blogDisLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogDisLikeFindUniqueArgs>(args: SelectSubset<T, BlogDisLikeFindUniqueArgs<ExtArgs>>): Prisma__BlogDisLikeClient<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogDisLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogDisLikeFindUniqueOrThrowArgs} args - Arguments to find a BlogDisLike
     * @example
     * // Get one BlogDisLike
     * const blogDisLike = await prisma.blogDisLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogDisLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogDisLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogDisLikeClient<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogDisLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogDisLikeFindFirstArgs} args - Arguments to find a BlogDisLike
     * @example
     * // Get one BlogDisLike
     * const blogDisLike = await prisma.blogDisLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogDisLikeFindFirstArgs>(args?: SelectSubset<T, BlogDisLikeFindFirstArgs<ExtArgs>>): Prisma__BlogDisLikeClient<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogDisLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogDisLikeFindFirstOrThrowArgs} args - Arguments to find a BlogDisLike
     * @example
     * // Get one BlogDisLike
     * const blogDisLike = await prisma.blogDisLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogDisLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogDisLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogDisLikeClient<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogDisLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogDisLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogDisLikes
     * const blogDisLikes = await prisma.blogDisLike.findMany()
     * 
     * // Get first 10 BlogDisLikes
     * const blogDisLikes = await prisma.blogDisLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogDisLikeWithIdOnly = await prisma.blogDisLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogDisLikeFindManyArgs>(args?: SelectSubset<T, BlogDisLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogDisLike.
     * @param {BlogDisLikeCreateArgs} args - Arguments to create a BlogDisLike.
     * @example
     * // Create one BlogDisLike
     * const BlogDisLike = await prisma.blogDisLike.create({
     *   data: {
     *     // ... data to create a BlogDisLike
     *   }
     * })
     * 
     */
    create<T extends BlogDisLikeCreateArgs>(args: SelectSubset<T, BlogDisLikeCreateArgs<ExtArgs>>): Prisma__BlogDisLikeClient<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogDisLikes.
     * @param {BlogDisLikeCreateManyArgs} args - Arguments to create many BlogDisLikes.
     * @example
     * // Create many BlogDisLikes
     * const blogDisLike = await prisma.blogDisLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogDisLikeCreateManyArgs>(args?: SelectSubset<T, BlogDisLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogDisLikes and returns the data saved in the database.
     * @param {BlogDisLikeCreateManyAndReturnArgs} args - Arguments to create many BlogDisLikes.
     * @example
     * // Create many BlogDisLikes
     * const blogDisLike = await prisma.blogDisLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogDisLikes and only return the `id`
     * const blogDisLikeWithIdOnly = await prisma.blogDisLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogDisLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogDisLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogDisLike.
     * @param {BlogDisLikeDeleteArgs} args - Arguments to delete one BlogDisLike.
     * @example
     * // Delete one BlogDisLike
     * const BlogDisLike = await prisma.blogDisLike.delete({
     *   where: {
     *     // ... filter to delete one BlogDisLike
     *   }
     * })
     * 
     */
    delete<T extends BlogDisLikeDeleteArgs>(args: SelectSubset<T, BlogDisLikeDeleteArgs<ExtArgs>>): Prisma__BlogDisLikeClient<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogDisLike.
     * @param {BlogDisLikeUpdateArgs} args - Arguments to update one BlogDisLike.
     * @example
     * // Update one BlogDisLike
     * const blogDisLike = await prisma.blogDisLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogDisLikeUpdateArgs>(args: SelectSubset<T, BlogDisLikeUpdateArgs<ExtArgs>>): Prisma__BlogDisLikeClient<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogDisLikes.
     * @param {BlogDisLikeDeleteManyArgs} args - Arguments to filter BlogDisLikes to delete.
     * @example
     * // Delete a few BlogDisLikes
     * const { count } = await prisma.blogDisLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogDisLikeDeleteManyArgs>(args?: SelectSubset<T, BlogDisLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogDisLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogDisLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogDisLikes
     * const blogDisLike = await prisma.blogDisLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogDisLikeUpdateManyArgs>(args: SelectSubset<T, BlogDisLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogDisLikes and returns the data updated in the database.
     * @param {BlogDisLikeUpdateManyAndReturnArgs} args - Arguments to update many BlogDisLikes.
     * @example
     * // Update many BlogDisLikes
     * const blogDisLike = await prisma.blogDisLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogDisLikes and only return the `id`
     * const blogDisLikeWithIdOnly = await prisma.blogDisLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogDisLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogDisLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogDisLike.
     * @param {BlogDisLikeUpsertArgs} args - Arguments to update or create a BlogDisLike.
     * @example
     * // Update or create a BlogDisLike
     * const blogDisLike = await prisma.blogDisLike.upsert({
     *   create: {
     *     // ... data to create a BlogDisLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogDisLike we want to update
     *   }
     * })
     */
    upsert<T extends BlogDisLikeUpsertArgs>(args: SelectSubset<T, BlogDisLikeUpsertArgs<ExtArgs>>): Prisma__BlogDisLikeClient<$Result.GetResult<Prisma.$BlogDisLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogDisLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogDisLikeCountArgs} args - Arguments to filter BlogDisLikes to count.
     * @example
     * // Count the number of BlogDisLikes
     * const count = await prisma.blogDisLike.count({
     *   where: {
     *     // ... the filter for the BlogDisLikes we want to count
     *   }
     * })
    **/
    count<T extends BlogDisLikeCountArgs>(
      args?: Subset<T, BlogDisLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogDisLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogDisLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogDisLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogDisLikeAggregateArgs>(args: Subset<T, BlogDisLikeAggregateArgs>): Prisma.PrismaPromise<GetBlogDisLikeAggregateType<T>>

    /**
     * Group by BlogDisLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogDisLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogDisLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogDisLikeGroupByArgs['orderBy'] }
        : { orderBy?: BlogDisLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogDisLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogDisLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogDisLike model
   */
  readonly fields: BlogDisLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogDisLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogDisLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogDisLike model
   */
  interface BlogDisLikeFieldRefs {
    readonly id: FieldRef<"BlogDisLike", 'String'>
    readonly userID: FieldRef<"BlogDisLike", 'String'>
    readonly blogID: FieldRef<"BlogDisLike", 'String'>
    readonly createdAt: FieldRef<"BlogDisLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogDisLike findUnique
   */
  export type BlogDisLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogDisLike to fetch.
     */
    where: BlogDisLikeWhereUniqueInput
  }

  /**
   * BlogDisLike findUniqueOrThrow
   */
  export type BlogDisLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogDisLike to fetch.
     */
    where: BlogDisLikeWhereUniqueInput
  }

  /**
   * BlogDisLike findFirst
   */
  export type BlogDisLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogDisLike to fetch.
     */
    where?: BlogDisLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogDisLikes to fetch.
     */
    orderBy?: BlogDisLikeOrderByWithRelationInput | BlogDisLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogDisLikes.
     */
    cursor?: BlogDisLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogDisLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogDisLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogDisLikes.
     */
    distinct?: BlogDisLikeScalarFieldEnum | BlogDisLikeScalarFieldEnum[]
  }

  /**
   * BlogDisLike findFirstOrThrow
   */
  export type BlogDisLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogDisLike to fetch.
     */
    where?: BlogDisLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogDisLikes to fetch.
     */
    orderBy?: BlogDisLikeOrderByWithRelationInput | BlogDisLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogDisLikes.
     */
    cursor?: BlogDisLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogDisLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogDisLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogDisLikes.
     */
    distinct?: BlogDisLikeScalarFieldEnum | BlogDisLikeScalarFieldEnum[]
  }

  /**
   * BlogDisLike findMany
   */
  export type BlogDisLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * Filter, which BlogDisLikes to fetch.
     */
    where?: BlogDisLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogDisLikes to fetch.
     */
    orderBy?: BlogDisLikeOrderByWithRelationInput | BlogDisLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogDisLikes.
     */
    cursor?: BlogDisLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogDisLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogDisLikes.
     */
    skip?: number
    distinct?: BlogDisLikeScalarFieldEnum | BlogDisLikeScalarFieldEnum[]
  }

  /**
   * BlogDisLike create
   */
  export type BlogDisLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogDisLike.
     */
    data: XOR<BlogDisLikeCreateInput, BlogDisLikeUncheckedCreateInput>
  }

  /**
   * BlogDisLike createMany
   */
  export type BlogDisLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogDisLikes.
     */
    data: BlogDisLikeCreateManyInput | BlogDisLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogDisLike createManyAndReturn
   */
  export type BlogDisLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * The data used to create many BlogDisLikes.
     */
    data: BlogDisLikeCreateManyInput | BlogDisLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogDisLike update
   */
  export type BlogDisLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogDisLike.
     */
    data: XOR<BlogDisLikeUpdateInput, BlogDisLikeUncheckedUpdateInput>
    /**
     * Choose, which BlogDisLike to update.
     */
    where: BlogDisLikeWhereUniqueInput
  }

  /**
   * BlogDisLike updateMany
   */
  export type BlogDisLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogDisLikes.
     */
    data: XOR<BlogDisLikeUpdateManyMutationInput, BlogDisLikeUncheckedUpdateManyInput>
    /**
     * Filter which BlogDisLikes to update
     */
    where?: BlogDisLikeWhereInput
    /**
     * Limit how many BlogDisLikes to update.
     */
    limit?: number
  }

  /**
   * BlogDisLike updateManyAndReturn
   */
  export type BlogDisLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * The data used to update BlogDisLikes.
     */
    data: XOR<BlogDisLikeUpdateManyMutationInput, BlogDisLikeUncheckedUpdateManyInput>
    /**
     * Filter which BlogDisLikes to update
     */
    where?: BlogDisLikeWhereInput
    /**
     * Limit how many BlogDisLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogDisLike upsert
   */
  export type BlogDisLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogDisLike to update in case it exists.
     */
    where: BlogDisLikeWhereUniqueInput
    /**
     * In case the BlogDisLike found by the `where` argument doesn't exist, create a new BlogDisLike with this data.
     */
    create: XOR<BlogDisLikeCreateInput, BlogDisLikeUncheckedCreateInput>
    /**
     * In case the BlogDisLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogDisLikeUpdateInput, BlogDisLikeUncheckedUpdateInput>
  }

  /**
   * BlogDisLike delete
   */
  export type BlogDisLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
    /**
     * Filter which BlogDisLike to delete.
     */
    where: BlogDisLikeWhereUniqueInput
  }

  /**
   * BlogDisLike deleteMany
   */
  export type BlogDisLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogDisLikes to delete
     */
    where?: BlogDisLikeWhereInput
    /**
     * Limit how many BlogDisLikes to delete.
     */
    limit?: number
  }

  /**
   * BlogDisLike without action
   */
  export type BlogDisLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogDisLike
     */
    select?: BlogDisLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogDisLike
     */
    omit?: BlogDisLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogDisLikeInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    topicName: string | null
    slug: string | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    topicName: string | null
    slug: string | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    topicName: number
    slug: number
    _all: number
  }


  export type TopicMinAggregateInputType = {
    id?: true
    topicName?: true
    slug?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    topicName?: true
    slug?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    topicName?: true
    slug?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: string
    topicName: string
    slug: string
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicName?: boolean
    slug?: boolean
    blogs?: boolean | Topic$blogsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicName?: boolean
    slug?: boolean
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicName?: boolean
    slug?: boolean
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    topicName?: boolean
    slug?: boolean
  }

  export type TopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "topicName" | "slug", ExtArgs["result"]["topic"]>
  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogs?: boolean | Topic$blogsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      blogs: Prisma.$BlogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicName: string
      slug: string
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogs<T extends Topic$blogsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$blogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'String'>
    readonly topicName: FieldRef<"Topic", 'String'>
    readonly slug: FieldRef<"Topic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic updateManyAndReturn
   */
  export type TopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topic.blogs
   */
  export type Topic$blogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    cursor?: BlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerID: string | null
    followingID: string | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerID: string | null
    followingID: string | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerID: number
    followingID: number
    createdAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerID?: true
    followingID?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerID?: true
    followingID?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerID?: true
    followingID?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerID: string
    followingID: string
    createdAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerID?: boolean
    followingID?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerID?: boolean
    followingID?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerID?: boolean
    followingID?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    followerID?: boolean
    followingID?: boolean
    createdAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerID" | "followingID" | "createdAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerID: string
      followingID: string
      createdAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {FollowUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerID: FieldRef<"Follow", 'String'>
    readonly followingID: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow updateManyAndReturn
   */
  export type FollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    userID: string | null
    blogId: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    blogId: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userID: number
    blogId: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    userID?: true
    blogId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userID?: true
    blogId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userID?: true
    blogId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    userID: string
    blogId: string
    message: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disLikeComments?: boolean | Comment$disLikeCommentsArgs<ExtArgs>
    likeComments?: boolean | Comment$likeCommentsArgs<ExtArgs>
    commentNotifications?: boolean | Comment$commentNotificationsArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    userID?: boolean
    blogId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "blogId" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disLikeComments?: boolean | Comment$disLikeCommentsArgs<ExtArgs>
    likeComments?: boolean | Comment$likeCommentsArgs<ExtArgs>
    commentNotifications?: boolean | Comment$commentNotificationsArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      disLikeComments: Prisma.$DisLikeCommentPayload<ExtArgs>[]
      likeComments: Prisma.$LikeCommentPayload<ExtArgs>[]
      commentNotifications: Prisma.$CommentNotificationPayload<ExtArgs>[]
      replies: Prisma.$CommentReplyPayload<ExtArgs>[]
      blog: Prisma.$BlogPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      blogId: string
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    disLikeComments<T extends Comment$disLikeCommentsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$disLikeCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likeComments<T extends Comment$likeCommentsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$likeCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentNotifications<T extends Comment$commentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$commentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly userID: FieldRef<"Comment", 'String'>
    readonly blogId: FieldRef<"Comment", 'String'>
    readonly message: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.disLikeComments
   */
  export type Comment$disLikeCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    where?: DisLikeCommentWhereInput
    orderBy?: DisLikeCommentOrderByWithRelationInput | DisLikeCommentOrderByWithRelationInput[]
    cursor?: DisLikeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisLikeCommentScalarFieldEnum | DisLikeCommentScalarFieldEnum[]
  }

  /**
   * Comment.likeComments
   */
  export type Comment$likeCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    where?: LikeCommentWhereInput
    orderBy?: LikeCommentOrderByWithRelationInput | LikeCommentOrderByWithRelationInput[]
    cursor?: LikeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeCommentScalarFieldEnum | LikeCommentScalarFieldEnum[]
  }

  /**
   * Comment.commentNotifications
   */
  export type Comment$commentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    where?: CommentNotificationWhereInput
    orderBy?: CommentNotificationOrderByWithRelationInput | CommentNotificationOrderByWithRelationInput[]
    cursor?: CommentNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentNotificationScalarFieldEnum | CommentNotificationScalarFieldEnum[]
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    cursor?: CommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model LikeComment
   */

  export type AggregateLikeComment = {
    _count: LikeCommentCountAggregateOutputType | null
    _min: LikeCommentMinAggregateOutputType | null
    _max: LikeCommentMaxAggregateOutputType | null
  }

  export type LikeCommentMinAggregateOutputType = {
    id: string | null
    userID: string | null
    commentID: string | null
    createdAt: Date | null
  }

  export type LikeCommentMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    commentID: string | null
    createdAt: Date | null
  }

  export type LikeCommentCountAggregateOutputType = {
    id: number
    userID: number
    commentID: number
    createdAt: number
    _all: number
  }


  export type LikeCommentMinAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    createdAt?: true
  }

  export type LikeCommentMaxAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    createdAt?: true
  }

  export type LikeCommentCountAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    createdAt?: true
    _all?: true
  }

  export type LikeCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikeComment to aggregate.
     */
    where?: LikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeComments to fetch.
     */
    orderBy?: LikeCommentOrderByWithRelationInput | LikeCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LikeComments
    **/
    _count?: true | LikeCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeCommentMaxAggregateInputType
  }

  export type GetLikeCommentAggregateType<T extends LikeCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateLikeComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikeComment[P]>
      : GetScalarType<T[P], AggregateLikeComment[P]>
  }




  export type LikeCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeCommentWhereInput
    orderBy?: LikeCommentOrderByWithAggregationInput | LikeCommentOrderByWithAggregationInput[]
    by: LikeCommentScalarFieldEnum[] | LikeCommentScalarFieldEnum
    having?: LikeCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCommentCountAggregateInputType | true
    _min?: LikeCommentMinAggregateInputType
    _max?: LikeCommentMaxAggregateInputType
  }

  export type LikeCommentGroupByOutputType = {
    id: string
    userID: string
    commentID: string
    createdAt: Date
    _count: LikeCommentCountAggregateOutputType | null
    _min: LikeCommentMinAggregateOutputType | null
    _max: LikeCommentMaxAggregateOutputType | null
  }

  type GetLikeCommentGroupByPayload<T extends LikeCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeCommentGroupByOutputType[P]>
            : GetScalarType<T[P], LikeCommentGroupByOutputType[P]>
        }
      >
    >


  export type LikeCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeComment"]>

  export type LikeCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeComment"]>

  export type LikeCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeComment"]>

  export type LikeCommentSelectScalar = {
    id?: boolean
    userID?: boolean
    commentID?: boolean
    createdAt?: boolean
  }

  export type LikeCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "commentID" | "createdAt", ExtArgs["result"]["likeComment"]>
  export type LikeCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikeCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LikeComment"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      commentID: string
      createdAt: Date
    }, ExtArgs["result"]["likeComment"]>
    composites: {}
  }

  type LikeCommentGetPayload<S extends boolean | null | undefined | LikeCommentDefaultArgs> = $Result.GetResult<Prisma.$LikeCommentPayload, S>

  type LikeCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeCommentCountAggregateInputType | true
    }

  export interface LikeCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LikeComment'], meta: { name: 'LikeComment' } }
    /**
     * Find zero or one LikeComment that matches the filter.
     * @param {LikeCommentFindUniqueArgs} args - Arguments to find a LikeComment
     * @example
     * // Get one LikeComment
     * const likeComment = await prisma.likeComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeCommentFindUniqueArgs>(args: SelectSubset<T, LikeCommentFindUniqueArgs<ExtArgs>>): Prisma__LikeCommentClient<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LikeComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeCommentFindUniqueOrThrowArgs} args - Arguments to find a LikeComment
     * @example
     * // Get one LikeComment
     * const likeComment = await prisma.likeComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeCommentClient<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikeComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCommentFindFirstArgs} args - Arguments to find a LikeComment
     * @example
     * // Get one LikeComment
     * const likeComment = await prisma.likeComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeCommentFindFirstArgs>(args?: SelectSubset<T, LikeCommentFindFirstArgs<ExtArgs>>): Prisma__LikeCommentClient<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikeComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCommentFindFirstOrThrowArgs} args - Arguments to find a LikeComment
     * @example
     * // Get one LikeComment
     * const likeComment = await prisma.likeComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeCommentClient<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LikeComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LikeComments
     * const likeComments = await prisma.likeComment.findMany()
     * 
     * // Get first 10 LikeComments
     * const likeComments = await prisma.likeComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeCommentWithIdOnly = await prisma.likeComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeCommentFindManyArgs>(args?: SelectSubset<T, LikeCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LikeComment.
     * @param {LikeCommentCreateArgs} args - Arguments to create a LikeComment.
     * @example
     * // Create one LikeComment
     * const LikeComment = await prisma.likeComment.create({
     *   data: {
     *     // ... data to create a LikeComment
     *   }
     * })
     * 
     */
    create<T extends LikeCommentCreateArgs>(args: SelectSubset<T, LikeCommentCreateArgs<ExtArgs>>): Prisma__LikeCommentClient<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LikeComments.
     * @param {LikeCommentCreateManyArgs} args - Arguments to create many LikeComments.
     * @example
     * // Create many LikeComments
     * const likeComment = await prisma.likeComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCommentCreateManyArgs>(args?: SelectSubset<T, LikeCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LikeComments and returns the data saved in the database.
     * @param {LikeCommentCreateManyAndReturnArgs} args - Arguments to create many LikeComments.
     * @example
     * // Create many LikeComments
     * const likeComment = await prisma.likeComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LikeComments and only return the `id`
     * const likeCommentWithIdOnly = await prisma.likeComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LikeComment.
     * @param {LikeCommentDeleteArgs} args - Arguments to delete one LikeComment.
     * @example
     * // Delete one LikeComment
     * const LikeComment = await prisma.likeComment.delete({
     *   where: {
     *     // ... filter to delete one LikeComment
     *   }
     * })
     * 
     */
    delete<T extends LikeCommentDeleteArgs>(args: SelectSubset<T, LikeCommentDeleteArgs<ExtArgs>>): Prisma__LikeCommentClient<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LikeComment.
     * @param {LikeCommentUpdateArgs} args - Arguments to update one LikeComment.
     * @example
     * // Update one LikeComment
     * const likeComment = await prisma.likeComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeCommentUpdateArgs>(args: SelectSubset<T, LikeCommentUpdateArgs<ExtArgs>>): Prisma__LikeCommentClient<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LikeComments.
     * @param {LikeCommentDeleteManyArgs} args - Arguments to filter LikeComments to delete.
     * @example
     * // Delete a few LikeComments
     * const { count } = await prisma.likeComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeCommentDeleteManyArgs>(args?: SelectSubset<T, LikeCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LikeComments
     * const likeComment = await prisma.likeComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeCommentUpdateManyArgs>(args: SelectSubset<T, LikeCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikeComments and returns the data updated in the database.
     * @param {LikeCommentUpdateManyAndReturnArgs} args - Arguments to update many LikeComments.
     * @example
     * // Update many LikeComments
     * const likeComment = await prisma.likeComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LikeComments and only return the `id`
     * const likeCommentWithIdOnly = await prisma.likeComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LikeComment.
     * @param {LikeCommentUpsertArgs} args - Arguments to update or create a LikeComment.
     * @example
     * // Update or create a LikeComment
     * const likeComment = await prisma.likeComment.upsert({
     *   create: {
     *     // ... data to create a LikeComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LikeComment we want to update
     *   }
     * })
     */
    upsert<T extends LikeCommentUpsertArgs>(args: SelectSubset<T, LikeCommentUpsertArgs<ExtArgs>>): Prisma__LikeCommentClient<$Result.GetResult<Prisma.$LikeCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LikeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCommentCountArgs} args - Arguments to filter LikeComments to count.
     * @example
     * // Count the number of LikeComments
     * const count = await prisma.likeComment.count({
     *   where: {
     *     // ... the filter for the LikeComments we want to count
     *   }
     * })
    **/
    count<T extends LikeCommentCountArgs>(
      args?: Subset<T, LikeCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LikeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeCommentAggregateArgs>(args: Subset<T, LikeCommentAggregateArgs>): Prisma.PrismaPromise<GetLikeCommentAggregateType<T>>

    /**
     * Group by LikeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeCommentGroupByArgs['orderBy'] }
        : { orderBy?: LikeCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LikeComment model
   */
  readonly fields: LikeCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LikeComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LikeComment model
   */
  interface LikeCommentFieldRefs {
    readonly id: FieldRef<"LikeComment", 'String'>
    readonly userID: FieldRef<"LikeComment", 'String'>
    readonly commentID: FieldRef<"LikeComment", 'String'>
    readonly createdAt: FieldRef<"LikeComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LikeComment findUnique
   */
  export type LikeCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which LikeComment to fetch.
     */
    where: LikeCommentWhereUniqueInput
  }

  /**
   * LikeComment findUniqueOrThrow
   */
  export type LikeCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which LikeComment to fetch.
     */
    where: LikeCommentWhereUniqueInput
  }

  /**
   * LikeComment findFirst
   */
  export type LikeCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which LikeComment to fetch.
     */
    where?: LikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeComments to fetch.
     */
    orderBy?: LikeCommentOrderByWithRelationInput | LikeCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikeComments.
     */
    cursor?: LikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikeComments.
     */
    distinct?: LikeCommentScalarFieldEnum | LikeCommentScalarFieldEnum[]
  }

  /**
   * LikeComment findFirstOrThrow
   */
  export type LikeCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which LikeComment to fetch.
     */
    where?: LikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeComments to fetch.
     */
    orderBy?: LikeCommentOrderByWithRelationInput | LikeCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikeComments.
     */
    cursor?: LikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikeComments.
     */
    distinct?: LikeCommentScalarFieldEnum | LikeCommentScalarFieldEnum[]
  }

  /**
   * LikeComment findMany
   */
  export type LikeCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which LikeComments to fetch.
     */
    where?: LikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeComments to fetch.
     */
    orderBy?: LikeCommentOrderByWithRelationInput | LikeCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LikeComments.
     */
    cursor?: LikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeComments.
     */
    skip?: number
    distinct?: LikeCommentScalarFieldEnum | LikeCommentScalarFieldEnum[]
  }

  /**
   * LikeComment create
   */
  export type LikeCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a LikeComment.
     */
    data: XOR<LikeCommentCreateInput, LikeCommentUncheckedCreateInput>
  }

  /**
   * LikeComment createMany
   */
  export type LikeCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LikeComments.
     */
    data: LikeCommentCreateManyInput | LikeCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LikeComment createManyAndReturn
   */
  export type LikeCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * The data used to create many LikeComments.
     */
    data: LikeCommentCreateManyInput | LikeCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikeComment update
   */
  export type LikeCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a LikeComment.
     */
    data: XOR<LikeCommentUpdateInput, LikeCommentUncheckedUpdateInput>
    /**
     * Choose, which LikeComment to update.
     */
    where: LikeCommentWhereUniqueInput
  }

  /**
   * LikeComment updateMany
   */
  export type LikeCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LikeComments.
     */
    data: XOR<LikeCommentUpdateManyMutationInput, LikeCommentUncheckedUpdateManyInput>
    /**
     * Filter which LikeComments to update
     */
    where?: LikeCommentWhereInput
    /**
     * Limit how many LikeComments to update.
     */
    limit?: number
  }

  /**
   * LikeComment updateManyAndReturn
   */
  export type LikeCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * The data used to update LikeComments.
     */
    data: XOR<LikeCommentUpdateManyMutationInput, LikeCommentUncheckedUpdateManyInput>
    /**
     * Filter which LikeComments to update
     */
    where?: LikeCommentWhereInput
    /**
     * Limit how many LikeComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikeComment upsert
   */
  export type LikeCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the LikeComment to update in case it exists.
     */
    where: LikeCommentWhereUniqueInput
    /**
     * In case the LikeComment found by the `where` argument doesn't exist, create a new LikeComment with this data.
     */
    create: XOR<LikeCommentCreateInput, LikeCommentUncheckedCreateInput>
    /**
     * In case the LikeComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeCommentUpdateInput, LikeCommentUncheckedUpdateInput>
  }

  /**
   * LikeComment delete
   */
  export type LikeCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
    /**
     * Filter which LikeComment to delete.
     */
    where: LikeCommentWhereUniqueInput
  }

  /**
   * LikeComment deleteMany
   */
  export type LikeCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikeComments to delete
     */
    where?: LikeCommentWhereInput
    /**
     * Limit how many LikeComments to delete.
     */
    limit?: number
  }

  /**
   * LikeComment without action
   */
  export type LikeCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeComment
     */
    select?: LikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeComment
     */
    omit?: LikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeCommentInclude<ExtArgs> | null
  }


  /**
   * Model DisLikeComment
   */

  export type AggregateDisLikeComment = {
    _count: DisLikeCommentCountAggregateOutputType | null
    _min: DisLikeCommentMinAggregateOutputType | null
    _max: DisLikeCommentMaxAggregateOutputType | null
  }

  export type DisLikeCommentMinAggregateOutputType = {
    id: string | null
    userID: string | null
    commentID: string | null
    createdAt: Date | null
  }

  export type DisLikeCommentMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    commentID: string | null
    createdAt: Date | null
  }

  export type DisLikeCommentCountAggregateOutputType = {
    id: number
    userID: number
    commentID: number
    createdAt: number
    _all: number
  }


  export type DisLikeCommentMinAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    createdAt?: true
  }

  export type DisLikeCommentMaxAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    createdAt?: true
  }

  export type DisLikeCommentCountAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    createdAt?: true
    _all?: true
  }

  export type DisLikeCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisLikeComment to aggregate.
     */
    where?: DisLikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisLikeComments to fetch.
     */
    orderBy?: DisLikeCommentOrderByWithRelationInput | DisLikeCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisLikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisLikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisLikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisLikeComments
    **/
    _count?: true | DisLikeCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisLikeCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisLikeCommentMaxAggregateInputType
  }

  export type GetDisLikeCommentAggregateType<T extends DisLikeCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateDisLikeComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisLikeComment[P]>
      : GetScalarType<T[P], AggregateDisLikeComment[P]>
  }




  export type DisLikeCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisLikeCommentWhereInput
    orderBy?: DisLikeCommentOrderByWithAggregationInput | DisLikeCommentOrderByWithAggregationInput[]
    by: DisLikeCommentScalarFieldEnum[] | DisLikeCommentScalarFieldEnum
    having?: DisLikeCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisLikeCommentCountAggregateInputType | true
    _min?: DisLikeCommentMinAggregateInputType
    _max?: DisLikeCommentMaxAggregateInputType
  }

  export type DisLikeCommentGroupByOutputType = {
    id: string
    userID: string
    commentID: string
    createdAt: Date
    _count: DisLikeCommentCountAggregateOutputType | null
    _min: DisLikeCommentMinAggregateOutputType | null
    _max: DisLikeCommentMaxAggregateOutputType | null
  }

  type GetDisLikeCommentGroupByPayload<T extends DisLikeCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisLikeCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisLikeCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisLikeCommentGroupByOutputType[P]>
            : GetScalarType<T[P], DisLikeCommentGroupByOutputType[P]>
        }
      >
    >


  export type DisLikeCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disLikeComment"]>

  export type DisLikeCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disLikeComment"]>

  export type DisLikeCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disLikeComment"]>

  export type DisLikeCommentSelectScalar = {
    id?: boolean
    userID?: boolean
    commentID?: boolean
    createdAt?: boolean
  }

  export type DisLikeCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "commentID" | "createdAt", ExtArgs["result"]["disLikeComment"]>
  export type DisLikeCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DisLikeCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DisLikeCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DisLikeCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisLikeComment"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      commentID: string
      createdAt: Date
    }, ExtArgs["result"]["disLikeComment"]>
    composites: {}
  }

  type DisLikeCommentGetPayload<S extends boolean | null | undefined | DisLikeCommentDefaultArgs> = $Result.GetResult<Prisma.$DisLikeCommentPayload, S>

  type DisLikeCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisLikeCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisLikeCommentCountAggregateInputType | true
    }

  export interface DisLikeCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisLikeComment'], meta: { name: 'DisLikeComment' } }
    /**
     * Find zero or one DisLikeComment that matches the filter.
     * @param {DisLikeCommentFindUniqueArgs} args - Arguments to find a DisLikeComment
     * @example
     * // Get one DisLikeComment
     * const disLikeComment = await prisma.disLikeComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisLikeCommentFindUniqueArgs>(args: SelectSubset<T, DisLikeCommentFindUniqueArgs<ExtArgs>>): Prisma__DisLikeCommentClient<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisLikeComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisLikeCommentFindUniqueOrThrowArgs} args - Arguments to find a DisLikeComment
     * @example
     * // Get one DisLikeComment
     * const disLikeComment = await prisma.disLikeComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisLikeCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, DisLikeCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisLikeCommentClient<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisLikeComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisLikeCommentFindFirstArgs} args - Arguments to find a DisLikeComment
     * @example
     * // Get one DisLikeComment
     * const disLikeComment = await prisma.disLikeComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisLikeCommentFindFirstArgs>(args?: SelectSubset<T, DisLikeCommentFindFirstArgs<ExtArgs>>): Prisma__DisLikeCommentClient<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisLikeComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisLikeCommentFindFirstOrThrowArgs} args - Arguments to find a DisLikeComment
     * @example
     * // Get one DisLikeComment
     * const disLikeComment = await prisma.disLikeComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisLikeCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, DisLikeCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisLikeCommentClient<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisLikeComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisLikeCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisLikeComments
     * const disLikeComments = await prisma.disLikeComment.findMany()
     * 
     * // Get first 10 DisLikeComments
     * const disLikeComments = await prisma.disLikeComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disLikeCommentWithIdOnly = await prisma.disLikeComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisLikeCommentFindManyArgs>(args?: SelectSubset<T, DisLikeCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisLikeComment.
     * @param {DisLikeCommentCreateArgs} args - Arguments to create a DisLikeComment.
     * @example
     * // Create one DisLikeComment
     * const DisLikeComment = await prisma.disLikeComment.create({
     *   data: {
     *     // ... data to create a DisLikeComment
     *   }
     * })
     * 
     */
    create<T extends DisLikeCommentCreateArgs>(args: SelectSubset<T, DisLikeCommentCreateArgs<ExtArgs>>): Prisma__DisLikeCommentClient<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisLikeComments.
     * @param {DisLikeCommentCreateManyArgs} args - Arguments to create many DisLikeComments.
     * @example
     * // Create many DisLikeComments
     * const disLikeComment = await prisma.disLikeComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisLikeCommentCreateManyArgs>(args?: SelectSubset<T, DisLikeCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisLikeComments and returns the data saved in the database.
     * @param {DisLikeCommentCreateManyAndReturnArgs} args - Arguments to create many DisLikeComments.
     * @example
     * // Create many DisLikeComments
     * const disLikeComment = await prisma.disLikeComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisLikeComments and only return the `id`
     * const disLikeCommentWithIdOnly = await prisma.disLikeComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisLikeCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, DisLikeCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisLikeComment.
     * @param {DisLikeCommentDeleteArgs} args - Arguments to delete one DisLikeComment.
     * @example
     * // Delete one DisLikeComment
     * const DisLikeComment = await prisma.disLikeComment.delete({
     *   where: {
     *     // ... filter to delete one DisLikeComment
     *   }
     * })
     * 
     */
    delete<T extends DisLikeCommentDeleteArgs>(args: SelectSubset<T, DisLikeCommentDeleteArgs<ExtArgs>>): Prisma__DisLikeCommentClient<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisLikeComment.
     * @param {DisLikeCommentUpdateArgs} args - Arguments to update one DisLikeComment.
     * @example
     * // Update one DisLikeComment
     * const disLikeComment = await prisma.disLikeComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisLikeCommentUpdateArgs>(args: SelectSubset<T, DisLikeCommentUpdateArgs<ExtArgs>>): Prisma__DisLikeCommentClient<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisLikeComments.
     * @param {DisLikeCommentDeleteManyArgs} args - Arguments to filter DisLikeComments to delete.
     * @example
     * // Delete a few DisLikeComments
     * const { count } = await prisma.disLikeComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisLikeCommentDeleteManyArgs>(args?: SelectSubset<T, DisLikeCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisLikeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisLikeCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisLikeComments
     * const disLikeComment = await prisma.disLikeComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisLikeCommentUpdateManyArgs>(args: SelectSubset<T, DisLikeCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisLikeComments and returns the data updated in the database.
     * @param {DisLikeCommentUpdateManyAndReturnArgs} args - Arguments to update many DisLikeComments.
     * @example
     * // Update many DisLikeComments
     * const disLikeComment = await prisma.disLikeComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisLikeComments and only return the `id`
     * const disLikeCommentWithIdOnly = await prisma.disLikeComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisLikeCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, DisLikeCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisLikeComment.
     * @param {DisLikeCommentUpsertArgs} args - Arguments to update or create a DisLikeComment.
     * @example
     * // Update or create a DisLikeComment
     * const disLikeComment = await prisma.disLikeComment.upsert({
     *   create: {
     *     // ... data to create a DisLikeComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisLikeComment we want to update
     *   }
     * })
     */
    upsert<T extends DisLikeCommentUpsertArgs>(args: SelectSubset<T, DisLikeCommentUpsertArgs<ExtArgs>>): Prisma__DisLikeCommentClient<$Result.GetResult<Prisma.$DisLikeCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisLikeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisLikeCommentCountArgs} args - Arguments to filter DisLikeComments to count.
     * @example
     * // Count the number of DisLikeComments
     * const count = await prisma.disLikeComment.count({
     *   where: {
     *     // ... the filter for the DisLikeComments we want to count
     *   }
     * })
    **/
    count<T extends DisLikeCommentCountArgs>(
      args?: Subset<T, DisLikeCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisLikeCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisLikeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisLikeCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisLikeCommentAggregateArgs>(args: Subset<T, DisLikeCommentAggregateArgs>): Prisma.PrismaPromise<GetDisLikeCommentAggregateType<T>>

    /**
     * Group by DisLikeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisLikeCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisLikeCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisLikeCommentGroupByArgs['orderBy'] }
        : { orderBy?: DisLikeCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisLikeCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisLikeCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisLikeComment model
   */
  readonly fields: DisLikeCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisLikeComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisLikeCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisLikeComment model
   */
  interface DisLikeCommentFieldRefs {
    readonly id: FieldRef<"DisLikeComment", 'String'>
    readonly userID: FieldRef<"DisLikeComment", 'String'>
    readonly commentID: FieldRef<"DisLikeComment", 'String'>
    readonly createdAt: FieldRef<"DisLikeComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisLikeComment findUnique
   */
  export type DisLikeCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which DisLikeComment to fetch.
     */
    where: DisLikeCommentWhereUniqueInput
  }

  /**
   * DisLikeComment findUniqueOrThrow
   */
  export type DisLikeCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which DisLikeComment to fetch.
     */
    where: DisLikeCommentWhereUniqueInput
  }

  /**
   * DisLikeComment findFirst
   */
  export type DisLikeCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which DisLikeComment to fetch.
     */
    where?: DisLikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisLikeComments to fetch.
     */
    orderBy?: DisLikeCommentOrderByWithRelationInput | DisLikeCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisLikeComments.
     */
    cursor?: DisLikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisLikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisLikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisLikeComments.
     */
    distinct?: DisLikeCommentScalarFieldEnum | DisLikeCommentScalarFieldEnum[]
  }

  /**
   * DisLikeComment findFirstOrThrow
   */
  export type DisLikeCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which DisLikeComment to fetch.
     */
    where?: DisLikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisLikeComments to fetch.
     */
    orderBy?: DisLikeCommentOrderByWithRelationInput | DisLikeCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisLikeComments.
     */
    cursor?: DisLikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisLikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisLikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisLikeComments.
     */
    distinct?: DisLikeCommentScalarFieldEnum | DisLikeCommentScalarFieldEnum[]
  }

  /**
   * DisLikeComment findMany
   */
  export type DisLikeCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * Filter, which DisLikeComments to fetch.
     */
    where?: DisLikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisLikeComments to fetch.
     */
    orderBy?: DisLikeCommentOrderByWithRelationInput | DisLikeCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisLikeComments.
     */
    cursor?: DisLikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisLikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisLikeComments.
     */
    skip?: number
    distinct?: DisLikeCommentScalarFieldEnum | DisLikeCommentScalarFieldEnum[]
  }

  /**
   * DisLikeComment create
   */
  export type DisLikeCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a DisLikeComment.
     */
    data: XOR<DisLikeCommentCreateInput, DisLikeCommentUncheckedCreateInput>
  }

  /**
   * DisLikeComment createMany
   */
  export type DisLikeCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisLikeComments.
     */
    data: DisLikeCommentCreateManyInput | DisLikeCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisLikeComment createManyAndReturn
   */
  export type DisLikeCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * The data used to create many DisLikeComments.
     */
    data: DisLikeCommentCreateManyInput | DisLikeCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisLikeComment update
   */
  export type DisLikeCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a DisLikeComment.
     */
    data: XOR<DisLikeCommentUpdateInput, DisLikeCommentUncheckedUpdateInput>
    /**
     * Choose, which DisLikeComment to update.
     */
    where: DisLikeCommentWhereUniqueInput
  }

  /**
   * DisLikeComment updateMany
   */
  export type DisLikeCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisLikeComments.
     */
    data: XOR<DisLikeCommentUpdateManyMutationInput, DisLikeCommentUncheckedUpdateManyInput>
    /**
     * Filter which DisLikeComments to update
     */
    where?: DisLikeCommentWhereInput
    /**
     * Limit how many DisLikeComments to update.
     */
    limit?: number
  }

  /**
   * DisLikeComment updateManyAndReturn
   */
  export type DisLikeCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * The data used to update DisLikeComments.
     */
    data: XOR<DisLikeCommentUpdateManyMutationInput, DisLikeCommentUncheckedUpdateManyInput>
    /**
     * Filter which DisLikeComments to update
     */
    where?: DisLikeCommentWhereInput
    /**
     * Limit how many DisLikeComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisLikeComment upsert
   */
  export type DisLikeCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the DisLikeComment to update in case it exists.
     */
    where: DisLikeCommentWhereUniqueInput
    /**
     * In case the DisLikeComment found by the `where` argument doesn't exist, create a new DisLikeComment with this data.
     */
    create: XOR<DisLikeCommentCreateInput, DisLikeCommentUncheckedCreateInput>
    /**
     * In case the DisLikeComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisLikeCommentUpdateInput, DisLikeCommentUncheckedUpdateInput>
  }

  /**
   * DisLikeComment delete
   */
  export type DisLikeCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
    /**
     * Filter which DisLikeComment to delete.
     */
    where: DisLikeCommentWhereUniqueInput
  }

  /**
   * DisLikeComment deleteMany
   */
  export type DisLikeCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisLikeComments to delete
     */
    where?: DisLikeCommentWhereInput
    /**
     * Limit how many DisLikeComments to delete.
     */
    limit?: number
  }

  /**
   * DisLikeComment without action
   */
  export type DisLikeCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisLikeComment
     */
    select?: DisLikeCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisLikeComment
     */
    omit?: DisLikeCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisLikeCommentInclude<ExtArgs> | null
  }


  /**
   * Model CommentReply
   */

  export type AggregateCommentReply = {
    _count: CommentReplyCountAggregateOutputType | null
    _min: CommentReplyMinAggregateOutputType | null
    _max: CommentReplyMaxAggregateOutputType | null
  }

  export type CommentReplyMinAggregateOutputType = {
    id: string | null
    userID: string | null
    commentID: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentReplyMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    commentID: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentReplyCountAggregateOutputType = {
    id: number
    userID: number
    commentID: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentReplyMinAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentReplyMaxAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentReplyCountAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReply to aggregate.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentReplies
    **/
    _count?: true | CommentReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentReplyMaxAggregateInputType
  }

  export type GetCommentReplyAggregateType<T extends CommentReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentReply[P]>
      : GetScalarType<T[P], AggregateCommentReply[P]>
  }




  export type CommentReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithAggregationInput | CommentReplyOrderByWithAggregationInput[]
    by: CommentReplyScalarFieldEnum[] | CommentReplyScalarFieldEnum
    having?: CommentReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentReplyCountAggregateInputType | true
    _min?: CommentReplyMinAggregateInputType
    _max?: CommentReplyMaxAggregateInputType
  }

  export type CommentReplyGroupByOutputType = {
    id: string
    userID: string
    commentID: string
    message: string
    createdAt: Date
    updatedAt: Date
    _count: CommentReplyCountAggregateOutputType | null
    _min: CommentReplyMinAggregateOutputType | null
    _max: CommentReplyMaxAggregateOutputType | null
  }

  type GetCommentReplyGroupByPayload<T extends CommentReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentReplyGroupByOutputType[P]>
            : GetScalarType<T[P], CommentReplyGroupByOutputType[P]>
        }
      >
    >


  export type CommentReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReply"]>

  export type CommentReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReply"]>

  export type CommentReplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReply"]>

  export type CommentReplySelectScalar = {
    id?: boolean
    userID?: boolean
    commentID?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentReplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "commentID" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["commentReply"]>
  export type CommentReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentReplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentReply"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      commentID: string
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commentReply"]>
    composites: {}
  }

  type CommentReplyGetPayload<S extends boolean | null | undefined | CommentReplyDefaultArgs> = $Result.GetResult<Prisma.$CommentReplyPayload, S>

  type CommentReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentReplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentReplyCountAggregateInputType | true
    }

  export interface CommentReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentReply'], meta: { name: 'CommentReply' } }
    /**
     * Find zero or one CommentReply that matches the filter.
     * @param {CommentReplyFindUniqueArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentReplyFindUniqueArgs>(args: SelectSubset<T, CommentReplyFindUniqueArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentReply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentReplyFindUniqueOrThrowArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindFirstArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentReplyFindFirstArgs>(args?: SelectSubset<T, CommentReplyFindFirstArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindFirstOrThrowArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentReplies
     * const commentReplies = await prisma.commentReply.findMany()
     * 
     * // Get first 10 CommentReplies
     * const commentReplies = await prisma.commentReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentReplyWithIdOnly = await prisma.commentReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentReplyFindManyArgs>(args?: SelectSubset<T, CommentReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentReply.
     * @param {CommentReplyCreateArgs} args - Arguments to create a CommentReply.
     * @example
     * // Create one CommentReply
     * const CommentReply = await prisma.commentReply.create({
     *   data: {
     *     // ... data to create a CommentReply
     *   }
     * })
     * 
     */
    create<T extends CommentReplyCreateArgs>(args: SelectSubset<T, CommentReplyCreateArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentReplies.
     * @param {CommentReplyCreateManyArgs} args - Arguments to create many CommentReplies.
     * @example
     * // Create many CommentReplies
     * const commentReply = await prisma.commentReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentReplyCreateManyArgs>(args?: SelectSubset<T, CommentReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentReplies and returns the data saved in the database.
     * @param {CommentReplyCreateManyAndReturnArgs} args - Arguments to create many CommentReplies.
     * @example
     * // Create many CommentReplies
     * const commentReply = await prisma.commentReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentReplies and only return the `id`
     * const commentReplyWithIdOnly = await prisma.commentReply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentReply.
     * @param {CommentReplyDeleteArgs} args - Arguments to delete one CommentReply.
     * @example
     * // Delete one CommentReply
     * const CommentReply = await prisma.commentReply.delete({
     *   where: {
     *     // ... filter to delete one CommentReply
     *   }
     * })
     * 
     */
    delete<T extends CommentReplyDeleteArgs>(args: SelectSubset<T, CommentReplyDeleteArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentReply.
     * @param {CommentReplyUpdateArgs} args - Arguments to update one CommentReply.
     * @example
     * // Update one CommentReply
     * const commentReply = await prisma.commentReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentReplyUpdateArgs>(args: SelectSubset<T, CommentReplyUpdateArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentReplies.
     * @param {CommentReplyDeleteManyArgs} args - Arguments to filter CommentReplies to delete.
     * @example
     * // Delete a few CommentReplies
     * const { count } = await prisma.commentReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentReplyDeleteManyArgs>(args?: SelectSubset<T, CommentReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentReplies
     * const commentReply = await prisma.commentReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentReplyUpdateManyArgs>(args: SelectSubset<T, CommentReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReplies and returns the data updated in the database.
     * @param {CommentReplyUpdateManyAndReturnArgs} args - Arguments to update many CommentReplies.
     * @example
     * // Update many CommentReplies
     * const commentReply = await prisma.commentReply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentReplies and only return the `id`
     * const commentReplyWithIdOnly = await prisma.commentReply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentReplyUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentReplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentReply.
     * @param {CommentReplyUpsertArgs} args - Arguments to update or create a CommentReply.
     * @example
     * // Update or create a CommentReply
     * const commentReply = await prisma.commentReply.upsert({
     *   create: {
     *     // ... data to create a CommentReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentReply we want to update
     *   }
     * })
     */
    upsert<T extends CommentReplyUpsertArgs>(args: SelectSubset<T, CommentReplyUpsertArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyCountArgs} args - Arguments to filter CommentReplies to count.
     * @example
     * // Count the number of CommentReplies
     * const count = await prisma.commentReply.count({
     *   where: {
     *     // ... the filter for the CommentReplies we want to count
     *   }
     * })
    **/
    count<T extends CommentReplyCountArgs>(
      args?: Subset<T, CommentReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentReplyAggregateArgs>(args: Subset<T, CommentReplyAggregateArgs>): Prisma.PrismaPromise<GetCommentReplyAggregateType<T>>

    /**
     * Group by CommentReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentReplyGroupByArgs['orderBy'] }
        : { orderBy?: CommentReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentReply model
   */
  readonly fields: CommentReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentReply model
   */
  interface CommentReplyFieldRefs {
    readonly id: FieldRef<"CommentReply", 'String'>
    readonly userID: FieldRef<"CommentReply", 'String'>
    readonly commentID: FieldRef<"CommentReply", 'String'>
    readonly message: FieldRef<"CommentReply", 'String'>
    readonly createdAt: FieldRef<"CommentReply", 'DateTime'>
    readonly updatedAt: FieldRef<"CommentReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentReply findUnique
   */
  export type CommentReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply findUniqueOrThrow
   */
  export type CommentReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply findFirst
   */
  export type CommentReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReplies.
     */
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply findFirstOrThrow
   */
  export type CommentReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReplies.
     */
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply findMany
   */
  export type CommentReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReplies to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply create
   */
  export type CommentReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentReply.
     */
    data: XOR<CommentReplyCreateInput, CommentReplyUncheckedCreateInput>
  }

  /**
   * CommentReply createMany
   */
  export type CommentReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentReplies.
     */
    data: CommentReplyCreateManyInput | CommentReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentReply createManyAndReturn
   */
  export type CommentReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * The data used to create many CommentReplies.
     */
    data: CommentReplyCreateManyInput | CommentReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentReply update
   */
  export type CommentReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentReply.
     */
    data: XOR<CommentReplyUpdateInput, CommentReplyUncheckedUpdateInput>
    /**
     * Choose, which CommentReply to update.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply updateMany
   */
  export type CommentReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentReplies.
     */
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyInput>
    /**
     * Filter which CommentReplies to update
     */
    where?: CommentReplyWhereInput
    /**
     * Limit how many CommentReplies to update.
     */
    limit?: number
  }

  /**
   * CommentReply updateManyAndReturn
   */
  export type CommentReplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * The data used to update CommentReplies.
     */
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyInput>
    /**
     * Filter which CommentReplies to update
     */
    where?: CommentReplyWhereInput
    /**
     * Limit how many CommentReplies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentReply upsert
   */
  export type CommentReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentReply to update in case it exists.
     */
    where: CommentReplyWhereUniqueInput
    /**
     * In case the CommentReply found by the `where` argument doesn't exist, create a new CommentReply with this data.
     */
    create: XOR<CommentReplyCreateInput, CommentReplyUncheckedCreateInput>
    /**
     * In case the CommentReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentReplyUpdateInput, CommentReplyUncheckedUpdateInput>
  }

  /**
   * CommentReply delete
   */
  export type CommentReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter which CommentReply to delete.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply deleteMany
   */
  export type CommentReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReplies to delete
     */
    where?: CommentReplyWhereInput
    /**
     * Limit how many CommentReplies to delete.
     */
    limit?: number
  }

  /**
   * CommentReply without action
   */
  export type CommentReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReply
     */
    omit?: CommentReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
  }


  /**
   * Model SavedBlog
   */

  export type AggregateSavedBlog = {
    _count: SavedBlogCountAggregateOutputType | null
    _min: SavedBlogMinAggregateOutputType | null
    _max: SavedBlogMaxAggregateOutputType | null
  }

  export type SavedBlogMinAggregateOutputType = {
    id: string | null
    userID: string | null
    blogID: string | null
    createdAt: Date | null
  }

  export type SavedBlogMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    blogID: string | null
    createdAt: Date | null
  }

  export type SavedBlogCountAggregateOutputType = {
    id: number
    userID: number
    blogID: number
    createdAt: number
    _all: number
  }


  export type SavedBlogMinAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
  }

  export type SavedBlogMaxAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
  }

  export type SavedBlogCountAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    createdAt?: true
    _all?: true
  }

  export type SavedBlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedBlog to aggregate.
     */
    where?: SavedBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedBlogs to fetch.
     */
    orderBy?: SavedBlogOrderByWithRelationInput | SavedBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedBlogs
    **/
    _count?: true | SavedBlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedBlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedBlogMaxAggregateInputType
  }

  export type GetSavedBlogAggregateType<T extends SavedBlogAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedBlog[P]>
      : GetScalarType<T[P], AggregateSavedBlog[P]>
  }




  export type SavedBlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedBlogWhereInput
    orderBy?: SavedBlogOrderByWithAggregationInput | SavedBlogOrderByWithAggregationInput[]
    by: SavedBlogScalarFieldEnum[] | SavedBlogScalarFieldEnum
    having?: SavedBlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedBlogCountAggregateInputType | true
    _min?: SavedBlogMinAggregateInputType
    _max?: SavedBlogMaxAggregateInputType
  }

  export type SavedBlogGroupByOutputType = {
    id: string
    userID: string
    blogID: string
    createdAt: Date
    _count: SavedBlogCountAggregateOutputType | null
    _min: SavedBlogMinAggregateOutputType | null
    _max: SavedBlogMaxAggregateOutputType | null
  }

  type GetSavedBlogGroupByPayload<T extends SavedBlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedBlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedBlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedBlogGroupByOutputType[P]>
            : GetScalarType<T[P], SavedBlogGroupByOutputType[P]>
        }
      >
    >


  export type SavedBlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedBlog"]>

  export type SavedBlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedBlog"]>

  export type SavedBlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedBlog"]>

  export type SavedBlogSelectScalar = {
    id?: boolean
    userID?: boolean
    blogID?: boolean
    createdAt?: boolean
  }

  export type SavedBlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "blogID" | "createdAt", ExtArgs["result"]["savedBlog"]>
  export type SavedBlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedBlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedBlogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SavedBlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedBlog"
    objects: {
      blog: Prisma.$BlogPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      blogID: string
      createdAt: Date
    }, ExtArgs["result"]["savedBlog"]>
    composites: {}
  }

  type SavedBlogGetPayload<S extends boolean | null | undefined | SavedBlogDefaultArgs> = $Result.GetResult<Prisma.$SavedBlogPayload, S>

  type SavedBlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedBlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedBlogCountAggregateInputType | true
    }

  export interface SavedBlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedBlog'], meta: { name: 'SavedBlog' } }
    /**
     * Find zero or one SavedBlog that matches the filter.
     * @param {SavedBlogFindUniqueArgs} args - Arguments to find a SavedBlog
     * @example
     * // Get one SavedBlog
     * const savedBlog = await prisma.savedBlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedBlogFindUniqueArgs>(args: SelectSubset<T, SavedBlogFindUniqueArgs<ExtArgs>>): Prisma__SavedBlogClient<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedBlog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedBlogFindUniqueOrThrowArgs} args - Arguments to find a SavedBlog
     * @example
     * // Get one SavedBlog
     * const savedBlog = await prisma.savedBlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedBlogFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedBlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedBlogClient<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedBlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedBlogFindFirstArgs} args - Arguments to find a SavedBlog
     * @example
     * // Get one SavedBlog
     * const savedBlog = await prisma.savedBlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedBlogFindFirstArgs>(args?: SelectSubset<T, SavedBlogFindFirstArgs<ExtArgs>>): Prisma__SavedBlogClient<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedBlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedBlogFindFirstOrThrowArgs} args - Arguments to find a SavedBlog
     * @example
     * // Get one SavedBlog
     * const savedBlog = await prisma.savedBlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedBlogFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedBlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedBlogClient<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedBlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedBlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedBlogs
     * const savedBlogs = await prisma.savedBlog.findMany()
     * 
     * // Get first 10 SavedBlogs
     * const savedBlogs = await prisma.savedBlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedBlogWithIdOnly = await prisma.savedBlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedBlogFindManyArgs>(args?: SelectSubset<T, SavedBlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedBlog.
     * @param {SavedBlogCreateArgs} args - Arguments to create a SavedBlog.
     * @example
     * // Create one SavedBlog
     * const SavedBlog = await prisma.savedBlog.create({
     *   data: {
     *     // ... data to create a SavedBlog
     *   }
     * })
     * 
     */
    create<T extends SavedBlogCreateArgs>(args: SelectSubset<T, SavedBlogCreateArgs<ExtArgs>>): Prisma__SavedBlogClient<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedBlogs.
     * @param {SavedBlogCreateManyArgs} args - Arguments to create many SavedBlogs.
     * @example
     * // Create many SavedBlogs
     * const savedBlog = await prisma.savedBlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedBlogCreateManyArgs>(args?: SelectSubset<T, SavedBlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedBlogs and returns the data saved in the database.
     * @param {SavedBlogCreateManyAndReturnArgs} args - Arguments to create many SavedBlogs.
     * @example
     * // Create many SavedBlogs
     * const savedBlog = await prisma.savedBlog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedBlogs and only return the `id`
     * const savedBlogWithIdOnly = await prisma.savedBlog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedBlogCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedBlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedBlog.
     * @param {SavedBlogDeleteArgs} args - Arguments to delete one SavedBlog.
     * @example
     * // Delete one SavedBlog
     * const SavedBlog = await prisma.savedBlog.delete({
     *   where: {
     *     // ... filter to delete one SavedBlog
     *   }
     * })
     * 
     */
    delete<T extends SavedBlogDeleteArgs>(args: SelectSubset<T, SavedBlogDeleteArgs<ExtArgs>>): Prisma__SavedBlogClient<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedBlog.
     * @param {SavedBlogUpdateArgs} args - Arguments to update one SavedBlog.
     * @example
     * // Update one SavedBlog
     * const savedBlog = await prisma.savedBlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedBlogUpdateArgs>(args: SelectSubset<T, SavedBlogUpdateArgs<ExtArgs>>): Prisma__SavedBlogClient<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedBlogs.
     * @param {SavedBlogDeleteManyArgs} args - Arguments to filter SavedBlogs to delete.
     * @example
     * // Delete a few SavedBlogs
     * const { count } = await prisma.savedBlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedBlogDeleteManyArgs>(args?: SelectSubset<T, SavedBlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedBlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedBlogs
     * const savedBlog = await prisma.savedBlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedBlogUpdateManyArgs>(args: SelectSubset<T, SavedBlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedBlogs and returns the data updated in the database.
     * @param {SavedBlogUpdateManyAndReturnArgs} args - Arguments to update many SavedBlogs.
     * @example
     * // Update many SavedBlogs
     * const savedBlog = await prisma.savedBlog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedBlogs and only return the `id`
     * const savedBlogWithIdOnly = await prisma.savedBlog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedBlogUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedBlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedBlog.
     * @param {SavedBlogUpsertArgs} args - Arguments to update or create a SavedBlog.
     * @example
     * // Update or create a SavedBlog
     * const savedBlog = await prisma.savedBlog.upsert({
     *   create: {
     *     // ... data to create a SavedBlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedBlog we want to update
     *   }
     * })
     */
    upsert<T extends SavedBlogUpsertArgs>(args: SelectSubset<T, SavedBlogUpsertArgs<ExtArgs>>): Prisma__SavedBlogClient<$Result.GetResult<Prisma.$SavedBlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedBlogCountArgs} args - Arguments to filter SavedBlogs to count.
     * @example
     * // Count the number of SavedBlogs
     * const count = await prisma.savedBlog.count({
     *   where: {
     *     // ... the filter for the SavedBlogs we want to count
     *   }
     * })
    **/
    count<T extends SavedBlogCountArgs>(
      args?: Subset<T, SavedBlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedBlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedBlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedBlogAggregateArgs>(args: Subset<T, SavedBlogAggregateArgs>): Prisma.PrismaPromise<GetSavedBlogAggregateType<T>>

    /**
     * Group by SavedBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedBlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedBlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedBlogGroupByArgs['orderBy'] }
        : { orderBy?: SavedBlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedBlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedBlog model
   */
  readonly fields: SavedBlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedBlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedBlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedBlog model
   */
  interface SavedBlogFieldRefs {
    readonly id: FieldRef<"SavedBlog", 'String'>
    readonly userID: FieldRef<"SavedBlog", 'String'>
    readonly blogID: FieldRef<"SavedBlog", 'String'>
    readonly createdAt: FieldRef<"SavedBlog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedBlog findUnique
   */
  export type SavedBlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * Filter, which SavedBlog to fetch.
     */
    where: SavedBlogWhereUniqueInput
  }

  /**
   * SavedBlog findUniqueOrThrow
   */
  export type SavedBlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * Filter, which SavedBlog to fetch.
     */
    where: SavedBlogWhereUniqueInput
  }

  /**
   * SavedBlog findFirst
   */
  export type SavedBlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * Filter, which SavedBlog to fetch.
     */
    where?: SavedBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedBlogs to fetch.
     */
    orderBy?: SavedBlogOrderByWithRelationInput | SavedBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedBlogs.
     */
    cursor?: SavedBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedBlogs.
     */
    distinct?: SavedBlogScalarFieldEnum | SavedBlogScalarFieldEnum[]
  }

  /**
   * SavedBlog findFirstOrThrow
   */
  export type SavedBlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * Filter, which SavedBlog to fetch.
     */
    where?: SavedBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedBlogs to fetch.
     */
    orderBy?: SavedBlogOrderByWithRelationInput | SavedBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedBlogs.
     */
    cursor?: SavedBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedBlogs.
     */
    distinct?: SavedBlogScalarFieldEnum | SavedBlogScalarFieldEnum[]
  }

  /**
   * SavedBlog findMany
   */
  export type SavedBlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * Filter, which SavedBlogs to fetch.
     */
    where?: SavedBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedBlogs to fetch.
     */
    orderBy?: SavedBlogOrderByWithRelationInput | SavedBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedBlogs.
     */
    cursor?: SavedBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedBlogs.
     */
    skip?: number
    distinct?: SavedBlogScalarFieldEnum | SavedBlogScalarFieldEnum[]
  }

  /**
   * SavedBlog create
   */
  export type SavedBlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedBlog.
     */
    data: XOR<SavedBlogCreateInput, SavedBlogUncheckedCreateInput>
  }

  /**
   * SavedBlog createMany
   */
  export type SavedBlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedBlogs.
     */
    data: SavedBlogCreateManyInput | SavedBlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedBlog createManyAndReturn
   */
  export type SavedBlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * The data used to create many SavedBlogs.
     */
    data: SavedBlogCreateManyInput | SavedBlogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedBlog update
   */
  export type SavedBlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedBlog.
     */
    data: XOR<SavedBlogUpdateInput, SavedBlogUncheckedUpdateInput>
    /**
     * Choose, which SavedBlog to update.
     */
    where: SavedBlogWhereUniqueInput
  }

  /**
   * SavedBlog updateMany
   */
  export type SavedBlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedBlogs.
     */
    data: XOR<SavedBlogUpdateManyMutationInput, SavedBlogUncheckedUpdateManyInput>
    /**
     * Filter which SavedBlogs to update
     */
    where?: SavedBlogWhereInput
    /**
     * Limit how many SavedBlogs to update.
     */
    limit?: number
  }

  /**
   * SavedBlog updateManyAndReturn
   */
  export type SavedBlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * The data used to update SavedBlogs.
     */
    data: XOR<SavedBlogUpdateManyMutationInput, SavedBlogUncheckedUpdateManyInput>
    /**
     * Filter which SavedBlogs to update
     */
    where?: SavedBlogWhereInput
    /**
     * Limit how many SavedBlogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedBlog upsert
   */
  export type SavedBlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedBlog to update in case it exists.
     */
    where: SavedBlogWhereUniqueInput
    /**
     * In case the SavedBlog found by the `where` argument doesn't exist, create a new SavedBlog with this data.
     */
    create: XOR<SavedBlogCreateInput, SavedBlogUncheckedCreateInput>
    /**
     * In case the SavedBlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedBlogUpdateInput, SavedBlogUncheckedUpdateInput>
  }

  /**
   * SavedBlog delete
   */
  export type SavedBlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
    /**
     * Filter which SavedBlog to delete.
     */
    where: SavedBlogWhereUniqueInput
  }

  /**
   * SavedBlog deleteMany
   */
  export type SavedBlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedBlogs to delete
     */
    where?: SavedBlogWhereInput
    /**
     * Limit how many SavedBlogs to delete.
     */
    limit?: number
  }

  /**
   * SavedBlog without action
   */
  export type SavedBlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedBlog
     */
    select?: SavedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedBlog
     */
    omit?: SavedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedBlogInclude<ExtArgs> | null
  }


  /**
   * Model Membership
   */

  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null
    _avg: MembershipAvgAggregateOutputType | null
    _sum: MembershipSumAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  export type MembershipAvgAggregateOutputType = {
    price: number | null
  }

  export type MembershipSumAggregateOutputType = {
    price: number | null
  }

  export type MembershipMinAggregateOutputType = {
    id: string | null
    type: $Enums.MemberShipType | null
    userID: string | null
    details: string | null
    price: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipMaxAggregateOutputType = {
    id: string | null
    type: $Enums.MemberShipType | null
    userID: string | null
    details: string | null
    price: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipCountAggregateOutputType = {
    id: number
    type: number
    userID: number
    details: number
    price: number
    isActive: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipAvgAggregateInputType = {
    price?: true
  }

  export type MembershipSumAggregateInputType = {
    price?: true
  }

  export type MembershipMinAggregateInputType = {
    id?: true
    type?: true
    userID?: true
    details?: true
    price?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipMaxAggregateInputType = {
    id?: true
    type?: true
    userID?: true
    details?: true
    price?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipCountAggregateInputType = {
    id?: true
    type?: true
    userID?: true
    details?: true
    price?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Membership to aggregate.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memberships
    **/
    _count?: true | MembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipMaxAggregateInputType
  }

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>
  }




  export type MembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithAggregationInput | MembershipOrderByWithAggregationInput[]
    by: MembershipScalarFieldEnum[] | MembershipScalarFieldEnum
    having?: MembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipCountAggregateInputType | true
    _avg?: MembershipAvgAggregateInputType
    _sum?: MembershipSumAggregateInputType
    _min?: MembershipMinAggregateInputType
    _max?: MembershipMaxAggregateInputType
  }

  export type MembershipGroupByOutputType = {
    id: string
    type: $Enums.MemberShipType
    userID: string
    details: string | null
    price: number
    isActive: boolean
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: MembershipCountAggregateOutputType | null
    _avg: MembershipAvgAggregateOutputType | null
    _sum: MembershipSumAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
        }
      >
    >


  export type MembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userID?: boolean
    details?: boolean
    price?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userID?: boolean
    details?: boolean
    price?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userID?: boolean
    details?: boolean
    price?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectScalar = {
    id?: boolean
    type?: boolean
    userID?: boolean
    details?: boolean
    price?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "userID" | "details" | "price" | "isActive" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["membership"]>
  export type MembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Membership"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.MemberShipType
      userID: string
      details: string | null
      price: number
      isActive: boolean
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membership"]>
    composites: {}
  }

  type MembershipGetPayload<S extends boolean | null | undefined | MembershipDefaultArgs> = $Result.GetResult<Prisma.$MembershipPayload, S>

  type MembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipCountAggregateInputType | true
    }

  export interface MembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Membership'], meta: { name: 'Membership' } }
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipFindUniqueArgs>(args: SelectSubset<T, MembershipFindUniqueArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Membership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipFindFirstArgs>(args?: SelectSubset<T, MembershipFindFirstArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipFindManyArgs>(args?: SelectSubset<T, MembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     * 
     */
    create<T extends MembershipCreateArgs>(args: SelectSubset<T, MembershipCreateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Memberships.
     * @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipCreateManyArgs>(args?: SelectSubset<T, MembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     * 
     */
    delete<T extends MembershipDeleteArgs>(args: SelectSubset<T, MembershipDeleteArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipUpdateArgs>(args: SelectSubset<T, MembershipUpdateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipDeleteManyArgs>(args?: SelectSubset<T, MembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipUpdateManyArgs>(args: SelectSubset<T, MembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships and returns the data updated in the database.
     * @param {MembershipUpdateManyAndReturnArgs} args - Arguments to update many Memberships.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUpsertArgs>(args: SelectSubset<T, MembershipUpsertArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipAggregateArgs>(args: Subset<T, MembershipAggregateArgs>): Prisma.PrismaPromise<GetMembershipAggregateType<T>>

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Membership model
   */
  readonly fields: MembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Membership model
   */
  interface MembershipFieldRefs {
    readonly id: FieldRef<"Membership", 'String'>
    readonly type: FieldRef<"Membership", 'MemberShipType'>
    readonly userID: FieldRef<"Membership", 'String'>
    readonly details: FieldRef<"Membership", 'String'>
    readonly price: FieldRef<"Membership", 'Float'>
    readonly isActive: FieldRef<"Membership", 'Boolean'>
    readonly expiresAt: FieldRef<"Membership", 'DateTime'>
    readonly createdAt: FieldRef<"Membership", 'DateTime'>
    readonly updatedAt: FieldRef<"Membership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Membership findUnique
   */
  export type MembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findFirst
   */
  export type MembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership create
   */
  export type MembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a Membership.
     */
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
  }

  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Membership createManyAndReturn
   */
  export type MembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership update
   */
  export type MembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a Membership.
     */
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
    /**
     * Choose, which Membership to update.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
  }

  /**
   * Membership updateManyAndReturn
   */
  export type MembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the Membership to update in case it exists.
     */
    where: MembershipWhereUniqueInput
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     */
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
  }

  /**
   * Membership delete
   */
  export type MembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter which Membership to delete.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to delete.
     */
    limit?: number
  }

  /**
   * Membership without action
   */
  export type MembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
  }


  /**
   * Model ReportBlog
   */

  export type AggregateReportBlog = {
    _count: ReportBlogCountAggregateOutputType | null
    _min: ReportBlogMinAggregateOutputType | null
    _max: ReportBlogMaxAggregateOutputType | null
  }

  export type ReportBlogMinAggregateOutputType = {
    id: string | null
    userID: string | null
    blogID: string | null
    type: $Enums.ReportMessage | null
    message: string | null
    createdAt: Date | null
  }

  export type ReportBlogMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    blogID: string | null
    type: $Enums.ReportMessage | null
    message: string | null
    createdAt: Date | null
  }

  export type ReportBlogCountAggregateOutputType = {
    id: number
    userID: number
    blogID: number
    type: number
    message: number
    createdAt: number
    _all: number
  }


  export type ReportBlogMinAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    type?: true
    message?: true
    createdAt?: true
  }

  export type ReportBlogMaxAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    type?: true
    message?: true
    createdAt?: true
  }

  export type ReportBlogCountAggregateInputType = {
    id?: true
    userID?: true
    blogID?: true
    type?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type ReportBlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportBlog to aggregate.
     */
    where?: ReportBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportBlogs to fetch.
     */
    orderBy?: ReportBlogOrderByWithRelationInput | ReportBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportBlogs
    **/
    _count?: true | ReportBlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportBlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportBlogMaxAggregateInputType
  }

  export type GetReportBlogAggregateType<T extends ReportBlogAggregateArgs> = {
        [P in keyof T & keyof AggregateReportBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportBlog[P]>
      : GetScalarType<T[P], AggregateReportBlog[P]>
  }




  export type ReportBlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportBlogWhereInput
    orderBy?: ReportBlogOrderByWithAggregationInput | ReportBlogOrderByWithAggregationInput[]
    by: ReportBlogScalarFieldEnum[] | ReportBlogScalarFieldEnum
    having?: ReportBlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportBlogCountAggregateInputType | true
    _min?: ReportBlogMinAggregateInputType
    _max?: ReportBlogMaxAggregateInputType
  }

  export type ReportBlogGroupByOutputType = {
    id: string
    userID: string
    blogID: string
    type: $Enums.ReportMessage
    message: string | null
    createdAt: Date
    _count: ReportBlogCountAggregateOutputType | null
    _min: ReportBlogMinAggregateOutputType | null
    _max: ReportBlogMaxAggregateOutputType | null
  }

  type GetReportBlogGroupByPayload<T extends ReportBlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportBlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportBlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportBlogGroupByOutputType[P]>
            : GetScalarType<T[P], ReportBlogGroupByOutputType[P]>
        }
      >
    >


  export type ReportBlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    type?: boolean
    message?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportBlog"]>

  export type ReportBlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    type?: boolean
    message?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportBlog"]>

  export type ReportBlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    blogID?: boolean
    type?: boolean
    message?: boolean
    createdAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportBlog"]>

  export type ReportBlogSelectScalar = {
    id?: boolean
    userID?: boolean
    blogID?: boolean
    type?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type ReportBlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "blogID" | "type" | "message" | "createdAt", ExtArgs["result"]["reportBlog"]>
  export type ReportBlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportBlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportBlogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportBlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportBlog"
    objects: {
      blog: Prisma.$BlogPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      blogID: string
      type: $Enums.ReportMessage
      message: string | null
      createdAt: Date
    }, ExtArgs["result"]["reportBlog"]>
    composites: {}
  }

  type ReportBlogGetPayload<S extends boolean | null | undefined | ReportBlogDefaultArgs> = $Result.GetResult<Prisma.$ReportBlogPayload, S>

  type ReportBlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportBlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportBlogCountAggregateInputType | true
    }

  export interface ReportBlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportBlog'], meta: { name: 'ReportBlog' } }
    /**
     * Find zero or one ReportBlog that matches the filter.
     * @param {ReportBlogFindUniqueArgs} args - Arguments to find a ReportBlog
     * @example
     * // Get one ReportBlog
     * const reportBlog = await prisma.reportBlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportBlogFindUniqueArgs>(args: SelectSubset<T, ReportBlogFindUniqueArgs<ExtArgs>>): Prisma__ReportBlogClient<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportBlog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportBlogFindUniqueOrThrowArgs} args - Arguments to find a ReportBlog
     * @example
     * // Get one ReportBlog
     * const reportBlog = await prisma.reportBlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportBlogFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportBlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportBlogClient<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportBlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportBlogFindFirstArgs} args - Arguments to find a ReportBlog
     * @example
     * // Get one ReportBlog
     * const reportBlog = await prisma.reportBlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportBlogFindFirstArgs>(args?: SelectSubset<T, ReportBlogFindFirstArgs<ExtArgs>>): Prisma__ReportBlogClient<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportBlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportBlogFindFirstOrThrowArgs} args - Arguments to find a ReportBlog
     * @example
     * // Get one ReportBlog
     * const reportBlog = await prisma.reportBlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportBlogFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportBlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportBlogClient<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportBlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportBlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportBlogs
     * const reportBlogs = await prisma.reportBlog.findMany()
     * 
     * // Get first 10 ReportBlogs
     * const reportBlogs = await prisma.reportBlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportBlogWithIdOnly = await prisma.reportBlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportBlogFindManyArgs>(args?: SelectSubset<T, ReportBlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportBlog.
     * @param {ReportBlogCreateArgs} args - Arguments to create a ReportBlog.
     * @example
     * // Create one ReportBlog
     * const ReportBlog = await prisma.reportBlog.create({
     *   data: {
     *     // ... data to create a ReportBlog
     *   }
     * })
     * 
     */
    create<T extends ReportBlogCreateArgs>(args: SelectSubset<T, ReportBlogCreateArgs<ExtArgs>>): Prisma__ReportBlogClient<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportBlogs.
     * @param {ReportBlogCreateManyArgs} args - Arguments to create many ReportBlogs.
     * @example
     * // Create many ReportBlogs
     * const reportBlog = await prisma.reportBlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportBlogCreateManyArgs>(args?: SelectSubset<T, ReportBlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportBlogs and returns the data saved in the database.
     * @param {ReportBlogCreateManyAndReturnArgs} args - Arguments to create many ReportBlogs.
     * @example
     * // Create many ReportBlogs
     * const reportBlog = await prisma.reportBlog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportBlogs and only return the `id`
     * const reportBlogWithIdOnly = await prisma.reportBlog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportBlogCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportBlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportBlog.
     * @param {ReportBlogDeleteArgs} args - Arguments to delete one ReportBlog.
     * @example
     * // Delete one ReportBlog
     * const ReportBlog = await prisma.reportBlog.delete({
     *   where: {
     *     // ... filter to delete one ReportBlog
     *   }
     * })
     * 
     */
    delete<T extends ReportBlogDeleteArgs>(args: SelectSubset<T, ReportBlogDeleteArgs<ExtArgs>>): Prisma__ReportBlogClient<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportBlog.
     * @param {ReportBlogUpdateArgs} args - Arguments to update one ReportBlog.
     * @example
     * // Update one ReportBlog
     * const reportBlog = await prisma.reportBlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportBlogUpdateArgs>(args: SelectSubset<T, ReportBlogUpdateArgs<ExtArgs>>): Prisma__ReportBlogClient<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportBlogs.
     * @param {ReportBlogDeleteManyArgs} args - Arguments to filter ReportBlogs to delete.
     * @example
     * // Delete a few ReportBlogs
     * const { count } = await prisma.reportBlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportBlogDeleteManyArgs>(args?: SelectSubset<T, ReportBlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportBlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportBlogs
     * const reportBlog = await prisma.reportBlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportBlogUpdateManyArgs>(args: SelectSubset<T, ReportBlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportBlogs and returns the data updated in the database.
     * @param {ReportBlogUpdateManyAndReturnArgs} args - Arguments to update many ReportBlogs.
     * @example
     * // Update many ReportBlogs
     * const reportBlog = await prisma.reportBlog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportBlogs and only return the `id`
     * const reportBlogWithIdOnly = await prisma.reportBlog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportBlogUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportBlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportBlog.
     * @param {ReportBlogUpsertArgs} args - Arguments to update or create a ReportBlog.
     * @example
     * // Update or create a ReportBlog
     * const reportBlog = await prisma.reportBlog.upsert({
     *   create: {
     *     // ... data to create a ReportBlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportBlog we want to update
     *   }
     * })
     */
    upsert<T extends ReportBlogUpsertArgs>(args: SelectSubset<T, ReportBlogUpsertArgs<ExtArgs>>): Prisma__ReportBlogClient<$Result.GetResult<Prisma.$ReportBlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportBlogCountArgs} args - Arguments to filter ReportBlogs to count.
     * @example
     * // Count the number of ReportBlogs
     * const count = await prisma.reportBlog.count({
     *   where: {
     *     // ... the filter for the ReportBlogs we want to count
     *   }
     * })
    **/
    count<T extends ReportBlogCountArgs>(
      args?: Subset<T, ReportBlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportBlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportBlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportBlogAggregateArgs>(args: Subset<T, ReportBlogAggregateArgs>): Prisma.PrismaPromise<GetReportBlogAggregateType<T>>

    /**
     * Group by ReportBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportBlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportBlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportBlogGroupByArgs['orderBy'] }
        : { orderBy?: ReportBlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportBlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportBlog model
   */
  readonly fields: ReportBlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportBlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportBlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportBlog model
   */
  interface ReportBlogFieldRefs {
    readonly id: FieldRef<"ReportBlog", 'String'>
    readonly userID: FieldRef<"ReportBlog", 'String'>
    readonly blogID: FieldRef<"ReportBlog", 'String'>
    readonly type: FieldRef<"ReportBlog", 'ReportMessage'>
    readonly message: FieldRef<"ReportBlog", 'String'>
    readonly createdAt: FieldRef<"ReportBlog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportBlog findUnique
   */
  export type ReportBlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * Filter, which ReportBlog to fetch.
     */
    where: ReportBlogWhereUniqueInput
  }

  /**
   * ReportBlog findUniqueOrThrow
   */
  export type ReportBlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * Filter, which ReportBlog to fetch.
     */
    where: ReportBlogWhereUniqueInput
  }

  /**
   * ReportBlog findFirst
   */
  export type ReportBlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * Filter, which ReportBlog to fetch.
     */
    where?: ReportBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportBlogs to fetch.
     */
    orderBy?: ReportBlogOrderByWithRelationInput | ReportBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportBlogs.
     */
    cursor?: ReportBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportBlogs.
     */
    distinct?: ReportBlogScalarFieldEnum | ReportBlogScalarFieldEnum[]
  }

  /**
   * ReportBlog findFirstOrThrow
   */
  export type ReportBlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * Filter, which ReportBlog to fetch.
     */
    where?: ReportBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportBlogs to fetch.
     */
    orderBy?: ReportBlogOrderByWithRelationInput | ReportBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportBlogs.
     */
    cursor?: ReportBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportBlogs.
     */
    distinct?: ReportBlogScalarFieldEnum | ReportBlogScalarFieldEnum[]
  }

  /**
   * ReportBlog findMany
   */
  export type ReportBlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * Filter, which ReportBlogs to fetch.
     */
    where?: ReportBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportBlogs to fetch.
     */
    orderBy?: ReportBlogOrderByWithRelationInput | ReportBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportBlogs.
     */
    cursor?: ReportBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportBlogs.
     */
    skip?: number
    distinct?: ReportBlogScalarFieldEnum | ReportBlogScalarFieldEnum[]
  }

  /**
   * ReportBlog create
   */
  export type ReportBlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportBlog.
     */
    data: XOR<ReportBlogCreateInput, ReportBlogUncheckedCreateInput>
  }

  /**
   * ReportBlog createMany
   */
  export type ReportBlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportBlogs.
     */
    data: ReportBlogCreateManyInput | ReportBlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportBlog createManyAndReturn
   */
  export type ReportBlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * The data used to create many ReportBlogs.
     */
    data: ReportBlogCreateManyInput | ReportBlogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportBlog update
   */
  export type ReportBlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportBlog.
     */
    data: XOR<ReportBlogUpdateInput, ReportBlogUncheckedUpdateInput>
    /**
     * Choose, which ReportBlog to update.
     */
    where: ReportBlogWhereUniqueInput
  }

  /**
   * ReportBlog updateMany
   */
  export type ReportBlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportBlogs.
     */
    data: XOR<ReportBlogUpdateManyMutationInput, ReportBlogUncheckedUpdateManyInput>
    /**
     * Filter which ReportBlogs to update
     */
    where?: ReportBlogWhereInput
    /**
     * Limit how many ReportBlogs to update.
     */
    limit?: number
  }

  /**
   * ReportBlog updateManyAndReturn
   */
  export type ReportBlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * The data used to update ReportBlogs.
     */
    data: XOR<ReportBlogUpdateManyMutationInput, ReportBlogUncheckedUpdateManyInput>
    /**
     * Filter which ReportBlogs to update
     */
    where?: ReportBlogWhereInput
    /**
     * Limit how many ReportBlogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportBlog upsert
   */
  export type ReportBlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportBlog to update in case it exists.
     */
    where: ReportBlogWhereUniqueInput
    /**
     * In case the ReportBlog found by the `where` argument doesn't exist, create a new ReportBlog with this data.
     */
    create: XOR<ReportBlogCreateInput, ReportBlogUncheckedCreateInput>
    /**
     * In case the ReportBlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportBlogUpdateInput, ReportBlogUncheckedUpdateInput>
  }

  /**
   * ReportBlog delete
   */
  export type ReportBlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
    /**
     * Filter which ReportBlog to delete.
     */
    where: ReportBlogWhereUniqueInput
  }

  /**
   * ReportBlog deleteMany
   */
  export type ReportBlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportBlogs to delete
     */
    where?: ReportBlogWhereInput
    /**
     * Limit how many ReportBlogs to delete.
     */
    limit?: number
  }

  /**
   * ReportBlog without action
   */
  export type ReportBlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportBlog
     */
    select?: ReportBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportBlog
     */
    omit?: ReportBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportBlogInclude<ExtArgs> | null
  }


  /**
   * Model CommentNotification
   */

  export type AggregateCommentNotification = {
    _count: CommentNotificationCountAggregateOutputType | null
    _min: CommentNotificationMinAggregateOutputType | null
    _max: CommentNotificationMaxAggregateOutputType | null
  }

  export type CommentNotificationMinAggregateOutputType = {
    id: string | null
    userID: string | null
    commentID: string | null
    isSeen: boolean | null
    createdAt: Date | null
  }

  export type CommentNotificationMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    commentID: string | null
    isSeen: boolean | null
    createdAt: Date | null
  }

  export type CommentNotificationCountAggregateOutputType = {
    id: number
    userID: number
    commentID: number
    isSeen: number
    createdAt: number
    _all: number
  }


  export type CommentNotificationMinAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    isSeen?: true
    createdAt?: true
  }

  export type CommentNotificationMaxAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    isSeen?: true
    createdAt?: true
  }

  export type CommentNotificationCountAggregateInputType = {
    id?: true
    userID?: true
    commentID?: true
    isSeen?: true
    createdAt?: true
    _all?: true
  }

  export type CommentNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentNotification to aggregate.
     */
    where?: CommentNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentNotifications to fetch.
     */
    orderBy?: CommentNotificationOrderByWithRelationInput | CommentNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentNotifications
    **/
    _count?: true | CommentNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentNotificationMaxAggregateInputType
  }

  export type GetCommentNotificationAggregateType<T extends CommentNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentNotification[P]>
      : GetScalarType<T[P], AggregateCommentNotification[P]>
  }




  export type CommentNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentNotificationWhereInput
    orderBy?: CommentNotificationOrderByWithAggregationInput | CommentNotificationOrderByWithAggregationInput[]
    by: CommentNotificationScalarFieldEnum[] | CommentNotificationScalarFieldEnum
    having?: CommentNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentNotificationCountAggregateInputType | true
    _min?: CommentNotificationMinAggregateInputType
    _max?: CommentNotificationMaxAggregateInputType
  }

  export type CommentNotificationGroupByOutputType = {
    id: string
    userID: string
    commentID: string
    isSeen: boolean
    createdAt: Date
    _count: CommentNotificationCountAggregateOutputType | null
    _min: CommentNotificationMinAggregateOutputType | null
    _max: CommentNotificationMaxAggregateOutputType | null
  }

  type GetCommentNotificationGroupByPayload<T extends CommentNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], CommentNotificationGroupByOutputType[P]>
        }
      >
    >


  export type CommentNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    isSeen?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentNotification"]>

  export type CommentNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    isSeen?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentNotification"]>

  export type CommentNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    commentID?: boolean
    isSeen?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentNotification"]>

  export type CommentNotificationSelectScalar = {
    id?: boolean
    userID?: boolean
    commentID?: boolean
    isSeen?: boolean
    createdAt?: boolean
  }

  export type CommentNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "commentID" | "isSeen" | "createdAt", ExtArgs["result"]["commentNotification"]>
  export type CommentNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentNotification"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      commentID: string
      isSeen: boolean
      createdAt: Date
    }, ExtArgs["result"]["commentNotification"]>
    composites: {}
  }

  type CommentNotificationGetPayload<S extends boolean | null | undefined | CommentNotificationDefaultArgs> = $Result.GetResult<Prisma.$CommentNotificationPayload, S>

  type CommentNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentNotificationCountAggregateInputType | true
    }

  export interface CommentNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentNotification'], meta: { name: 'CommentNotification' } }
    /**
     * Find zero or one CommentNotification that matches the filter.
     * @param {CommentNotificationFindUniqueArgs} args - Arguments to find a CommentNotification
     * @example
     * // Get one CommentNotification
     * const commentNotification = await prisma.commentNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentNotificationFindUniqueArgs>(args: SelectSubset<T, CommentNotificationFindUniqueArgs<ExtArgs>>): Prisma__CommentNotificationClient<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentNotificationFindUniqueOrThrowArgs} args - Arguments to find a CommentNotification
     * @example
     * // Get one CommentNotification
     * const commentNotification = await prisma.commentNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentNotificationClient<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNotificationFindFirstArgs} args - Arguments to find a CommentNotification
     * @example
     * // Get one CommentNotification
     * const commentNotification = await prisma.commentNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentNotificationFindFirstArgs>(args?: SelectSubset<T, CommentNotificationFindFirstArgs<ExtArgs>>): Prisma__CommentNotificationClient<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNotificationFindFirstOrThrowArgs} args - Arguments to find a CommentNotification
     * @example
     * // Get one CommentNotification
     * const commentNotification = await prisma.commentNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentNotificationClient<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentNotifications
     * const commentNotifications = await prisma.commentNotification.findMany()
     * 
     * // Get first 10 CommentNotifications
     * const commentNotifications = await prisma.commentNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentNotificationWithIdOnly = await prisma.commentNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentNotificationFindManyArgs>(args?: SelectSubset<T, CommentNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentNotification.
     * @param {CommentNotificationCreateArgs} args - Arguments to create a CommentNotification.
     * @example
     * // Create one CommentNotification
     * const CommentNotification = await prisma.commentNotification.create({
     *   data: {
     *     // ... data to create a CommentNotification
     *   }
     * })
     * 
     */
    create<T extends CommentNotificationCreateArgs>(args: SelectSubset<T, CommentNotificationCreateArgs<ExtArgs>>): Prisma__CommentNotificationClient<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentNotifications.
     * @param {CommentNotificationCreateManyArgs} args - Arguments to create many CommentNotifications.
     * @example
     * // Create many CommentNotifications
     * const commentNotification = await prisma.commentNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentNotificationCreateManyArgs>(args?: SelectSubset<T, CommentNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentNotifications and returns the data saved in the database.
     * @param {CommentNotificationCreateManyAndReturnArgs} args - Arguments to create many CommentNotifications.
     * @example
     * // Create many CommentNotifications
     * const commentNotification = await prisma.commentNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentNotifications and only return the `id`
     * const commentNotificationWithIdOnly = await prisma.commentNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentNotification.
     * @param {CommentNotificationDeleteArgs} args - Arguments to delete one CommentNotification.
     * @example
     * // Delete one CommentNotification
     * const CommentNotification = await prisma.commentNotification.delete({
     *   where: {
     *     // ... filter to delete one CommentNotification
     *   }
     * })
     * 
     */
    delete<T extends CommentNotificationDeleteArgs>(args: SelectSubset<T, CommentNotificationDeleteArgs<ExtArgs>>): Prisma__CommentNotificationClient<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentNotification.
     * @param {CommentNotificationUpdateArgs} args - Arguments to update one CommentNotification.
     * @example
     * // Update one CommentNotification
     * const commentNotification = await prisma.commentNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentNotificationUpdateArgs>(args: SelectSubset<T, CommentNotificationUpdateArgs<ExtArgs>>): Prisma__CommentNotificationClient<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentNotifications.
     * @param {CommentNotificationDeleteManyArgs} args - Arguments to filter CommentNotifications to delete.
     * @example
     * // Delete a few CommentNotifications
     * const { count } = await prisma.commentNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentNotificationDeleteManyArgs>(args?: SelectSubset<T, CommentNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentNotifications
     * const commentNotification = await prisma.commentNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentNotificationUpdateManyArgs>(args: SelectSubset<T, CommentNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentNotifications and returns the data updated in the database.
     * @param {CommentNotificationUpdateManyAndReturnArgs} args - Arguments to update many CommentNotifications.
     * @example
     * // Update many CommentNotifications
     * const commentNotification = await prisma.commentNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentNotifications and only return the `id`
     * const commentNotificationWithIdOnly = await prisma.commentNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentNotification.
     * @param {CommentNotificationUpsertArgs} args - Arguments to update or create a CommentNotification.
     * @example
     * // Update or create a CommentNotification
     * const commentNotification = await prisma.commentNotification.upsert({
     *   create: {
     *     // ... data to create a CommentNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentNotification we want to update
     *   }
     * })
     */
    upsert<T extends CommentNotificationUpsertArgs>(args: SelectSubset<T, CommentNotificationUpsertArgs<ExtArgs>>): Prisma__CommentNotificationClient<$Result.GetResult<Prisma.$CommentNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNotificationCountArgs} args - Arguments to filter CommentNotifications to count.
     * @example
     * // Count the number of CommentNotifications
     * const count = await prisma.commentNotification.count({
     *   where: {
     *     // ... the filter for the CommentNotifications we want to count
     *   }
     * })
    **/
    count<T extends CommentNotificationCountArgs>(
      args?: Subset<T, CommentNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentNotificationAggregateArgs>(args: Subset<T, CommentNotificationAggregateArgs>): Prisma.PrismaPromise<GetCommentNotificationAggregateType<T>>

    /**
     * Group by CommentNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentNotificationGroupByArgs['orderBy'] }
        : { orderBy?: CommentNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentNotification model
   */
  readonly fields: CommentNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentNotification model
   */
  interface CommentNotificationFieldRefs {
    readonly id: FieldRef<"CommentNotification", 'String'>
    readonly userID: FieldRef<"CommentNotification", 'String'>
    readonly commentID: FieldRef<"CommentNotification", 'String'>
    readonly isSeen: FieldRef<"CommentNotification", 'Boolean'>
    readonly createdAt: FieldRef<"CommentNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentNotification findUnique
   */
  export type CommentNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CommentNotification to fetch.
     */
    where: CommentNotificationWhereUniqueInput
  }

  /**
   * CommentNotification findUniqueOrThrow
   */
  export type CommentNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CommentNotification to fetch.
     */
    where: CommentNotificationWhereUniqueInput
  }

  /**
   * CommentNotification findFirst
   */
  export type CommentNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CommentNotification to fetch.
     */
    where?: CommentNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentNotifications to fetch.
     */
    orderBy?: CommentNotificationOrderByWithRelationInput | CommentNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentNotifications.
     */
    cursor?: CommentNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentNotifications.
     */
    distinct?: CommentNotificationScalarFieldEnum | CommentNotificationScalarFieldEnum[]
  }

  /**
   * CommentNotification findFirstOrThrow
   */
  export type CommentNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CommentNotification to fetch.
     */
    where?: CommentNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentNotifications to fetch.
     */
    orderBy?: CommentNotificationOrderByWithRelationInput | CommentNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentNotifications.
     */
    cursor?: CommentNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentNotifications.
     */
    distinct?: CommentNotificationScalarFieldEnum | CommentNotificationScalarFieldEnum[]
  }

  /**
   * CommentNotification findMany
   */
  export type CommentNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CommentNotifications to fetch.
     */
    where?: CommentNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentNotifications to fetch.
     */
    orderBy?: CommentNotificationOrderByWithRelationInput | CommentNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentNotifications.
     */
    cursor?: CommentNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentNotifications.
     */
    skip?: number
    distinct?: CommentNotificationScalarFieldEnum | CommentNotificationScalarFieldEnum[]
  }

  /**
   * CommentNotification create
   */
  export type CommentNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentNotification.
     */
    data: XOR<CommentNotificationCreateInput, CommentNotificationUncheckedCreateInput>
  }

  /**
   * CommentNotification createMany
   */
  export type CommentNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentNotifications.
     */
    data: CommentNotificationCreateManyInput | CommentNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentNotification createManyAndReturn
   */
  export type CommentNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many CommentNotifications.
     */
    data: CommentNotificationCreateManyInput | CommentNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentNotification update
   */
  export type CommentNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentNotification.
     */
    data: XOR<CommentNotificationUpdateInput, CommentNotificationUncheckedUpdateInput>
    /**
     * Choose, which CommentNotification to update.
     */
    where: CommentNotificationWhereUniqueInput
  }

  /**
   * CommentNotification updateMany
   */
  export type CommentNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentNotifications.
     */
    data: XOR<CommentNotificationUpdateManyMutationInput, CommentNotificationUncheckedUpdateManyInput>
    /**
     * Filter which CommentNotifications to update
     */
    where?: CommentNotificationWhereInput
    /**
     * Limit how many CommentNotifications to update.
     */
    limit?: number
  }

  /**
   * CommentNotification updateManyAndReturn
   */
  export type CommentNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * The data used to update CommentNotifications.
     */
    data: XOR<CommentNotificationUpdateManyMutationInput, CommentNotificationUncheckedUpdateManyInput>
    /**
     * Filter which CommentNotifications to update
     */
    where?: CommentNotificationWhereInput
    /**
     * Limit how many CommentNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentNotification upsert
   */
  export type CommentNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentNotification to update in case it exists.
     */
    where: CommentNotificationWhereUniqueInput
    /**
     * In case the CommentNotification found by the `where` argument doesn't exist, create a new CommentNotification with this data.
     */
    create: XOR<CommentNotificationCreateInput, CommentNotificationUncheckedCreateInput>
    /**
     * In case the CommentNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentNotificationUpdateInput, CommentNotificationUncheckedUpdateInput>
  }

  /**
   * CommentNotification delete
   */
  export type CommentNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
    /**
     * Filter which CommentNotification to delete.
     */
    where: CommentNotificationWhereUniqueInput
  }

  /**
   * CommentNotification deleteMany
   */
  export type CommentNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentNotifications to delete
     */
    where?: CommentNotificationWhereInput
    /**
     * Limit how many CommentNotifications to delete.
     */
    limit?: number
  }

  /**
   * CommentNotification without action
   */
  export type CommentNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentNotification
     */
    select?: CommentNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentNotification
     */
    omit?: CommentNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentNotificationInclude<ExtArgs> | null
  }


  /**
   * Model MessageNotification
   */

  export type AggregateMessageNotification = {
    _count: MessageNotificationCountAggregateOutputType | null
    _min: MessageNotificationMinAggregateOutputType | null
    _max: MessageNotificationMaxAggregateOutputType | null
  }

  export type MessageNotificationMinAggregateOutputType = {
    id: string | null
    receiverID: string | null
    senderID: string | null
    message: string | null
    isSeen: boolean | null
    createdAt: Date | null
  }

  export type MessageNotificationMaxAggregateOutputType = {
    id: string | null
    receiverID: string | null
    senderID: string | null
    message: string | null
    isSeen: boolean | null
    createdAt: Date | null
  }

  export type MessageNotificationCountAggregateOutputType = {
    id: number
    receiverID: number
    senderID: number
    message: number
    isSeen: number
    createdAt: number
    _all: number
  }


  export type MessageNotificationMinAggregateInputType = {
    id?: true
    receiverID?: true
    senderID?: true
    message?: true
    isSeen?: true
    createdAt?: true
  }

  export type MessageNotificationMaxAggregateInputType = {
    id?: true
    receiverID?: true
    senderID?: true
    message?: true
    isSeen?: true
    createdAt?: true
  }

  export type MessageNotificationCountAggregateInputType = {
    id?: true
    receiverID?: true
    senderID?: true
    message?: true
    isSeen?: true
    createdAt?: true
    _all?: true
  }

  export type MessageNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageNotification to aggregate.
     */
    where?: MessageNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageNotifications to fetch.
     */
    orderBy?: MessageNotificationOrderByWithRelationInput | MessageNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageNotifications
    **/
    _count?: true | MessageNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageNotificationMaxAggregateInputType
  }

  export type GetMessageNotificationAggregateType<T extends MessageNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageNotification[P]>
      : GetScalarType<T[P], AggregateMessageNotification[P]>
  }




  export type MessageNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageNotificationWhereInput
    orderBy?: MessageNotificationOrderByWithAggregationInput | MessageNotificationOrderByWithAggregationInput[]
    by: MessageNotificationScalarFieldEnum[] | MessageNotificationScalarFieldEnum
    having?: MessageNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageNotificationCountAggregateInputType | true
    _min?: MessageNotificationMinAggregateInputType
    _max?: MessageNotificationMaxAggregateInputType
  }

  export type MessageNotificationGroupByOutputType = {
    id: string
    receiverID: string
    senderID: string
    message: string
    isSeen: boolean
    createdAt: Date
    _count: MessageNotificationCountAggregateOutputType | null
    _min: MessageNotificationMinAggregateOutputType | null
    _max: MessageNotificationMaxAggregateOutputType | null
  }

  type GetMessageNotificationGroupByPayload<T extends MessageNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], MessageNotificationGroupByOutputType[P]>
        }
      >
    >


  export type MessageNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiverID?: boolean
    senderID?: boolean
    message?: boolean
    isSeen?: boolean
    createdAt?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageNotification"]>

  export type MessageNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiverID?: boolean
    senderID?: boolean
    message?: boolean
    isSeen?: boolean
    createdAt?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageNotification"]>

  export type MessageNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiverID?: boolean
    senderID?: boolean
    message?: boolean
    isSeen?: boolean
    createdAt?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageNotification"]>

  export type MessageNotificationSelectScalar = {
    id?: boolean
    receiverID?: boolean
    senderID?: boolean
    message?: boolean
    isSeen?: boolean
    createdAt?: boolean
  }

  export type MessageNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiverID" | "senderID" | "message" | "isSeen" | "createdAt", ExtArgs["result"]["messageNotification"]>
  export type MessageNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageNotification"
    objects: {
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiverID: string
      senderID: string
      message: string
      isSeen: boolean
      createdAt: Date
    }, ExtArgs["result"]["messageNotification"]>
    composites: {}
  }

  type MessageNotificationGetPayload<S extends boolean | null | undefined | MessageNotificationDefaultArgs> = $Result.GetResult<Prisma.$MessageNotificationPayload, S>

  type MessageNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageNotificationCountAggregateInputType | true
    }

  export interface MessageNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageNotification'], meta: { name: 'MessageNotification' } }
    /**
     * Find zero or one MessageNotification that matches the filter.
     * @param {MessageNotificationFindUniqueArgs} args - Arguments to find a MessageNotification
     * @example
     * // Get one MessageNotification
     * const messageNotification = await prisma.messageNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageNotificationFindUniqueArgs>(args: SelectSubset<T, MessageNotificationFindUniqueArgs<ExtArgs>>): Prisma__MessageNotificationClient<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageNotificationFindUniqueOrThrowArgs} args - Arguments to find a MessageNotification
     * @example
     * // Get one MessageNotification
     * const messageNotification = await prisma.messageNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageNotificationClient<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageNotificationFindFirstArgs} args - Arguments to find a MessageNotification
     * @example
     * // Get one MessageNotification
     * const messageNotification = await prisma.messageNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageNotificationFindFirstArgs>(args?: SelectSubset<T, MessageNotificationFindFirstArgs<ExtArgs>>): Prisma__MessageNotificationClient<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageNotificationFindFirstOrThrowArgs} args - Arguments to find a MessageNotification
     * @example
     * // Get one MessageNotification
     * const messageNotification = await prisma.messageNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageNotificationClient<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageNotifications
     * const messageNotifications = await prisma.messageNotification.findMany()
     * 
     * // Get first 10 MessageNotifications
     * const messageNotifications = await prisma.messageNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageNotificationWithIdOnly = await prisma.messageNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageNotificationFindManyArgs>(args?: SelectSubset<T, MessageNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageNotification.
     * @param {MessageNotificationCreateArgs} args - Arguments to create a MessageNotification.
     * @example
     * // Create one MessageNotification
     * const MessageNotification = await prisma.messageNotification.create({
     *   data: {
     *     // ... data to create a MessageNotification
     *   }
     * })
     * 
     */
    create<T extends MessageNotificationCreateArgs>(args: SelectSubset<T, MessageNotificationCreateArgs<ExtArgs>>): Prisma__MessageNotificationClient<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageNotifications.
     * @param {MessageNotificationCreateManyArgs} args - Arguments to create many MessageNotifications.
     * @example
     * // Create many MessageNotifications
     * const messageNotification = await prisma.messageNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageNotificationCreateManyArgs>(args?: SelectSubset<T, MessageNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageNotifications and returns the data saved in the database.
     * @param {MessageNotificationCreateManyAndReturnArgs} args - Arguments to create many MessageNotifications.
     * @example
     * // Create many MessageNotifications
     * const messageNotification = await prisma.messageNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageNotifications and only return the `id`
     * const messageNotificationWithIdOnly = await prisma.messageNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageNotification.
     * @param {MessageNotificationDeleteArgs} args - Arguments to delete one MessageNotification.
     * @example
     * // Delete one MessageNotification
     * const MessageNotification = await prisma.messageNotification.delete({
     *   where: {
     *     // ... filter to delete one MessageNotification
     *   }
     * })
     * 
     */
    delete<T extends MessageNotificationDeleteArgs>(args: SelectSubset<T, MessageNotificationDeleteArgs<ExtArgs>>): Prisma__MessageNotificationClient<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageNotification.
     * @param {MessageNotificationUpdateArgs} args - Arguments to update one MessageNotification.
     * @example
     * // Update one MessageNotification
     * const messageNotification = await prisma.messageNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageNotificationUpdateArgs>(args: SelectSubset<T, MessageNotificationUpdateArgs<ExtArgs>>): Prisma__MessageNotificationClient<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageNotifications.
     * @param {MessageNotificationDeleteManyArgs} args - Arguments to filter MessageNotifications to delete.
     * @example
     * // Delete a few MessageNotifications
     * const { count } = await prisma.messageNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageNotificationDeleteManyArgs>(args?: SelectSubset<T, MessageNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageNotifications
     * const messageNotification = await prisma.messageNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageNotificationUpdateManyArgs>(args: SelectSubset<T, MessageNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageNotifications and returns the data updated in the database.
     * @param {MessageNotificationUpdateManyAndReturnArgs} args - Arguments to update many MessageNotifications.
     * @example
     * // Update many MessageNotifications
     * const messageNotification = await prisma.messageNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageNotifications and only return the `id`
     * const messageNotificationWithIdOnly = await prisma.messageNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageNotification.
     * @param {MessageNotificationUpsertArgs} args - Arguments to update or create a MessageNotification.
     * @example
     * // Update or create a MessageNotification
     * const messageNotification = await prisma.messageNotification.upsert({
     *   create: {
     *     // ... data to create a MessageNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageNotification we want to update
     *   }
     * })
     */
    upsert<T extends MessageNotificationUpsertArgs>(args: SelectSubset<T, MessageNotificationUpsertArgs<ExtArgs>>): Prisma__MessageNotificationClient<$Result.GetResult<Prisma.$MessageNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageNotificationCountArgs} args - Arguments to filter MessageNotifications to count.
     * @example
     * // Count the number of MessageNotifications
     * const count = await prisma.messageNotification.count({
     *   where: {
     *     // ... the filter for the MessageNotifications we want to count
     *   }
     * })
    **/
    count<T extends MessageNotificationCountArgs>(
      args?: Subset<T, MessageNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageNotificationAggregateArgs>(args: Subset<T, MessageNotificationAggregateArgs>): Prisma.PrismaPromise<GetMessageNotificationAggregateType<T>>

    /**
     * Group by MessageNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageNotificationGroupByArgs['orderBy'] }
        : { orderBy?: MessageNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageNotification model
   */
  readonly fields: MessageNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageNotification model
   */
  interface MessageNotificationFieldRefs {
    readonly id: FieldRef<"MessageNotification", 'String'>
    readonly receiverID: FieldRef<"MessageNotification", 'String'>
    readonly senderID: FieldRef<"MessageNotification", 'String'>
    readonly message: FieldRef<"MessageNotification", 'String'>
    readonly isSeen: FieldRef<"MessageNotification", 'Boolean'>
    readonly createdAt: FieldRef<"MessageNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageNotification findUnique
   */
  export type MessageNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MessageNotification to fetch.
     */
    where: MessageNotificationWhereUniqueInput
  }

  /**
   * MessageNotification findUniqueOrThrow
   */
  export type MessageNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MessageNotification to fetch.
     */
    where: MessageNotificationWhereUniqueInput
  }

  /**
   * MessageNotification findFirst
   */
  export type MessageNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MessageNotification to fetch.
     */
    where?: MessageNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageNotifications to fetch.
     */
    orderBy?: MessageNotificationOrderByWithRelationInput | MessageNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageNotifications.
     */
    cursor?: MessageNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageNotifications.
     */
    distinct?: MessageNotificationScalarFieldEnum | MessageNotificationScalarFieldEnum[]
  }

  /**
   * MessageNotification findFirstOrThrow
   */
  export type MessageNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MessageNotification to fetch.
     */
    where?: MessageNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageNotifications to fetch.
     */
    orderBy?: MessageNotificationOrderByWithRelationInput | MessageNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageNotifications.
     */
    cursor?: MessageNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageNotifications.
     */
    distinct?: MessageNotificationScalarFieldEnum | MessageNotificationScalarFieldEnum[]
  }

  /**
   * MessageNotification findMany
   */
  export type MessageNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MessageNotifications to fetch.
     */
    where?: MessageNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageNotifications to fetch.
     */
    orderBy?: MessageNotificationOrderByWithRelationInput | MessageNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageNotifications.
     */
    cursor?: MessageNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageNotifications.
     */
    skip?: number
    distinct?: MessageNotificationScalarFieldEnum | MessageNotificationScalarFieldEnum[]
  }

  /**
   * MessageNotification create
   */
  export type MessageNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageNotification.
     */
    data: XOR<MessageNotificationCreateInput, MessageNotificationUncheckedCreateInput>
  }

  /**
   * MessageNotification createMany
   */
  export type MessageNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageNotifications.
     */
    data: MessageNotificationCreateManyInput | MessageNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageNotification createManyAndReturn
   */
  export type MessageNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many MessageNotifications.
     */
    data: MessageNotificationCreateManyInput | MessageNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageNotification update
   */
  export type MessageNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageNotification.
     */
    data: XOR<MessageNotificationUpdateInput, MessageNotificationUncheckedUpdateInput>
    /**
     * Choose, which MessageNotification to update.
     */
    where: MessageNotificationWhereUniqueInput
  }

  /**
   * MessageNotification updateMany
   */
  export type MessageNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageNotifications.
     */
    data: XOR<MessageNotificationUpdateManyMutationInput, MessageNotificationUncheckedUpdateManyInput>
    /**
     * Filter which MessageNotifications to update
     */
    where?: MessageNotificationWhereInput
    /**
     * Limit how many MessageNotifications to update.
     */
    limit?: number
  }

  /**
   * MessageNotification updateManyAndReturn
   */
  export type MessageNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * The data used to update MessageNotifications.
     */
    data: XOR<MessageNotificationUpdateManyMutationInput, MessageNotificationUncheckedUpdateManyInput>
    /**
     * Filter which MessageNotifications to update
     */
    where?: MessageNotificationWhereInput
    /**
     * Limit how many MessageNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageNotification upsert
   */
  export type MessageNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageNotification to update in case it exists.
     */
    where: MessageNotificationWhereUniqueInput
    /**
     * In case the MessageNotification found by the `where` argument doesn't exist, create a new MessageNotification with this data.
     */
    create: XOR<MessageNotificationCreateInput, MessageNotificationUncheckedCreateInput>
    /**
     * In case the MessageNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageNotificationUpdateInput, MessageNotificationUncheckedUpdateInput>
  }

  /**
   * MessageNotification delete
   */
  export type MessageNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
    /**
     * Filter which MessageNotification to delete.
     */
    where: MessageNotificationWhereUniqueInput
  }

  /**
   * MessageNotification deleteMany
   */
  export type MessageNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageNotifications to delete
     */
    where?: MessageNotificationWhereInput
    /**
     * Limit how many MessageNotifications to delete.
     */
    limit?: number
  }

  /**
   * MessageNotification without action
   */
  export type MessageNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageNotification
     */
    select?: MessageNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageNotification
     */
    omit?: MessageNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageNotificationInclude<ExtArgs> | null
  }


  /**
   * Model LikeNotification
   */

  export type AggregateLikeNotification = {
    _count: LikeNotificationCountAggregateOutputType | null
    _min: LikeNotificationMinAggregateOutputType | null
    _max: LikeNotificationMaxAggregateOutputType | null
  }

  export type LikeNotificationMinAggregateOutputType = {
    id: string | null
    userID: string | null
    isSeen: boolean | null
    blogLikedId: string | null
    createdAt: Date | null
  }

  export type LikeNotificationMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    isSeen: boolean | null
    blogLikedId: string | null
    createdAt: Date | null
  }

  export type LikeNotificationCountAggregateOutputType = {
    id: number
    userID: number
    isSeen: number
    blogLikedId: number
    createdAt: number
    _all: number
  }


  export type LikeNotificationMinAggregateInputType = {
    id?: true
    userID?: true
    isSeen?: true
    blogLikedId?: true
    createdAt?: true
  }

  export type LikeNotificationMaxAggregateInputType = {
    id?: true
    userID?: true
    isSeen?: true
    blogLikedId?: true
    createdAt?: true
  }

  export type LikeNotificationCountAggregateInputType = {
    id?: true
    userID?: true
    isSeen?: true
    blogLikedId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikeNotification to aggregate.
     */
    where?: LikeNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeNotifications to fetch.
     */
    orderBy?: LikeNotificationOrderByWithRelationInput | LikeNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LikeNotifications
    **/
    _count?: true | LikeNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeNotificationMaxAggregateInputType
  }

  export type GetLikeNotificationAggregateType<T extends LikeNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateLikeNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikeNotification[P]>
      : GetScalarType<T[P], AggregateLikeNotification[P]>
  }




  export type LikeNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeNotificationWhereInput
    orderBy?: LikeNotificationOrderByWithAggregationInput | LikeNotificationOrderByWithAggregationInput[]
    by: LikeNotificationScalarFieldEnum[] | LikeNotificationScalarFieldEnum
    having?: LikeNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeNotificationCountAggregateInputType | true
    _min?: LikeNotificationMinAggregateInputType
    _max?: LikeNotificationMaxAggregateInputType
  }

  export type LikeNotificationGroupByOutputType = {
    id: string
    userID: string
    isSeen: boolean
    blogLikedId: string
    createdAt: Date
    _count: LikeNotificationCountAggregateOutputType | null
    _min: LikeNotificationMinAggregateOutputType | null
    _max: LikeNotificationMaxAggregateOutputType | null
  }

  type GetLikeNotificationGroupByPayload<T extends LikeNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], LikeNotificationGroupByOutputType[P]>
        }
      >
    >


  export type LikeNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    isSeen?: boolean
    blogLikedId?: boolean
    createdAt?: boolean
    blog?: boolean | BlogLikeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeNotification"]>

  export type LikeNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    isSeen?: boolean
    blogLikedId?: boolean
    createdAt?: boolean
    blog?: boolean | BlogLikeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeNotification"]>

  export type LikeNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    isSeen?: boolean
    blogLikedId?: boolean
    createdAt?: boolean
    blog?: boolean | BlogLikeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeNotification"]>

  export type LikeNotificationSelectScalar = {
    id?: boolean
    userID?: boolean
    isSeen?: boolean
    blogLikedId?: boolean
    createdAt?: boolean
  }

  export type LikeNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userID" | "isSeen" | "blogLikedId" | "createdAt", ExtArgs["result"]["likeNotification"]>
  export type LikeNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogLikeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogLikeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogLikeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikeNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LikeNotification"
    objects: {
      blog: Prisma.$BlogLikePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      isSeen: boolean
      blogLikedId: string
      createdAt: Date
    }, ExtArgs["result"]["likeNotification"]>
    composites: {}
  }

  type LikeNotificationGetPayload<S extends boolean | null | undefined | LikeNotificationDefaultArgs> = $Result.GetResult<Prisma.$LikeNotificationPayload, S>

  type LikeNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeNotificationCountAggregateInputType | true
    }

  export interface LikeNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LikeNotification'], meta: { name: 'LikeNotification' } }
    /**
     * Find zero or one LikeNotification that matches the filter.
     * @param {LikeNotificationFindUniqueArgs} args - Arguments to find a LikeNotification
     * @example
     * // Get one LikeNotification
     * const likeNotification = await prisma.likeNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeNotificationFindUniqueArgs>(args: SelectSubset<T, LikeNotificationFindUniqueArgs<ExtArgs>>): Prisma__LikeNotificationClient<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LikeNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeNotificationFindUniqueOrThrowArgs} args - Arguments to find a LikeNotification
     * @example
     * // Get one LikeNotification
     * const likeNotification = await prisma.likeNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeNotificationClient<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikeNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeNotificationFindFirstArgs} args - Arguments to find a LikeNotification
     * @example
     * // Get one LikeNotification
     * const likeNotification = await prisma.likeNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeNotificationFindFirstArgs>(args?: SelectSubset<T, LikeNotificationFindFirstArgs<ExtArgs>>): Prisma__LikeNotificationClient<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikeNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeNotificationFindFirstOrThrowArgs} args - Arguments to find a LikeNotification
     * @example
     * // Get one LikeNotification
     * const likeNotification = await prisma.likeNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeNotificationClient<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LikeNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LikeNotifications
     * const likeNotifications = await prisma.likeNotification.findMany()
     * 
     * // Get first 10 LikeNotifications
     * const likeNotifications = await prisma.likeNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeNotificationWithIdOnly = await prisma.likeNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeNotificationFindManyArgs>(args?: SelectSubset<T, LikeNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LikeNotification.
     * @param {LikeNotificationCreateArgs} args - Arguments to create a LikeNotification.
     * @example
     * // Create one LikeNotification
     * const LikeNotification = await prisma.likeNotification.create({
     *   data: {
     *     // ... data to create a LikeNotification
     *   }
     * })
     * 
     */
    create<T extends LikeNotificationCreateArgs>(args: SelectSubset<T, LikeNotificationCreateArgs<ExtArgs>>): Prisma__LikeNotificationClient<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LikeNotifications.
     * @param {LikeNotificationCreateManyArgs} args - Arguments to create many LikeNotifications.
     * @example
     * // Create many LikeNotifications
     * const likeNotification = await prisma.likeNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeNotificationCreateManyArgs>(args?: SelectSubset<T, LikeNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LikeNotifications and returns the data saved in the database.
     * @param {LikeNotificationCreateManyAndReturnArgs} args - Arguments to create many LikeNotifications.
     * @example
     * // Create many LikeNotifications
     * const likeNotification = await prisma.likeNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LikeNotifications and only return the `id`
     * const likeNotificationWithIdOnly = await prisma.likeNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LikeNotification.
     * @param {LikeNotificationDeleteArgs} args - Arguments to delete one LikeNotification.
     * @example
     * // Delete one LikeNotification
     * const LikeNotification = await prisma.likeNotification.delete({
     *   where: {
     *     // ... filter to delete one LikeNotification
     *   }
     * })
     * 
     */
    delete<T extends LikeNotificationDeleteArgs>(args: SelectSubset<T, LikeNotificationDeleteArgs<ExtArgs>>): Prisma__LikeNotificationClient<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LikeNotification.
     * @param {LikeNotificationUpdateArgs} args - Arguments to update one LikeNotification.
     * @example
     * // Update one LikeNotification
     * const likeNotification = await prisma.likeNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeNotificationUpdateArgs>(args: SelectSubset<T, LikeNotificationUpdateArgs<ExtArgs>>): Prisma__LikeNotificationClient<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LikeNotifications.
     * @param {LikeNotificationDeleteManyArgs} args - Arguments to filter LikeNotifications to delete.
     * @example
     * // Delete a few LikeNotifications
     * const { count } = await prisma.likeNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeNotificationDeleteManyArgs>(args?: SelectSubset<T, LikeNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikeNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LikeNotifications
     * const likeNotification = await prisma.likeNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeNotificationUpdateManyArgs>(args: SelectSubset<T, LikeNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikeNotifications and returns the data updated in the database.
     * @param {LikeNotificationUpdateManyAndReturnArgs} args - Arguments to update many LikeNotifications.
     * @example
     * // Update many LikeNotifications
     * const likeNotification = await prisma.likeNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LikeNotifications and only return the `id`
     * const likeNotificationWithIdOnly = await prisma.likeNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LikeNotification.
     * @param {LikeNotificationUpsertArgs} args - Arguments to update or create a LikeNotification.
     * @example
     * // Update or create a LikeNotification
     * const likeNotification = await prisma.likeNotification.upsert({
     *   create: {
     *     // ... data to create a LikeNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LikeNotification we want to update
     *   }
     * })
     */
    upsert<T extends LikeNotificationUpsertArgs>(args: SelectSubset<T, LikeNotificationUpsertArgs<ExtArgs>>): Prisma__LikeNotificationClient<$Result.GetResult<Prisma.$LikeNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LikeNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeNotificationCountArgs} args - Arguments to filter LikeNotifications to count.
     * @example
     * // Count the number of LikeNotifications
     * const count = await prisma.likeNotification.count({
     *   where: {
     *     // ... the filter for the LikeNotifications we want to count
     *   }
     * })
    **/
    count<T extends LikeNotificationCountArgs>(
      args?: Subset<T, LikeNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LikeNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeNotificationAggregateArgs>(args: Subset<T, LikeNotificationAggregateArgs>): Prisma.PrismaPromise<GetLikeNotificationAggregateType<T>>

    /**
     * Group by LikeNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeNotificationGroupByArgs['orderBy'] }
        : { orderBy?: LikeNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LikeNotification model
   */
  readonly fields: LikeNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LikeNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog<T extends BlogLikeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogLikeDefaultArgs<ExtArgs>>): Prisma__BlogLikeClient<$Result.GetResult<Prisma.$BlogLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LikeNotification model
   */
  interface LikeNotificationFieldRefs {
    readonly id: FieldRef<"LikeNotification", 'String'>
    readonly userID: FieldRef<"LikeNotification", 'String'>
    readonly isSeen: FieldRef<"LikeNotification", 'Boolean'>
    readonly blogLikedId: FieldRef<"LikeNotification", 'String'>
    readonly createdAt: FieldRef<"LikeNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LikeNotification findUnique
   */
  export type LikeNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * Filter, which LikeNotification to fetch.
     */
    where: LikeNotificationWhereUniqueInput
  }

  /**
   * LikeNotification findUniqueOrThrow
   */
  export type LikeNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * Filter, which LikeNotification to fetch.
     */
    where: LikeNotificationWhereUniqueInput
  }

  /**
   * LikeNotification findFirst
   */
  export type LikeNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * Filter, which LikeNotification to fetch.
     */
    where?: LikeNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeNotifications to fetch.
     */
    orderBy?: LikeNotificationOrderByWithRelationInput | LikeNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikeNotifications.
     */
    cursor?: LikeNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikeNotifications.
     */
    distinct?: LikeNotificationScalarFieldEnum | LikeNotificationScalarFieldEnum[]
  }

  /**
   * LikeNotification findFirstOrThrow
   */
  export type LikeNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * Filter, which LikeNotification to fetch.
     */
    where?: LikeNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeNotifications to fetch.
     */
    orderBy?: LikeNotificationOrderByWithRelationInput | LikeNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikeNotifications.
     */
    cursor?: LikeNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikeNotifications.
     */
    distinct?: LikeNotificationScalarFieldEnum | LikeNotificationScalarFieldEnum[]
  }

  /**
   * LikeNotification findMany
   */
  export type LikeNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * Filter, which LikeNotifications to fetch.
     */
    where?: LikeNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeNotifications to fetch.
     */
    orderBy?: LikeNotificationOrderByWithRelationInput | LikeNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LikeNotifications.
     */
    cursor?: LikeNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeNotifications.
     */
    skip?: number
    distinct?: LikeNotificationScalarFieldEnum | LikeNotificationScalarFieldEnum[]
  }

  /**
   * LikeNotification create
   */
  export type LikeNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a LikeNotification.
     */
    data: XOR<LikeNotificationCreateInput, LikeNotificationUncheckedCreateInput>
  }

  /**
   * LikeNotification createMany
   */
  export type LikeNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LikeNotifications.
     */
    data: LikeNotificationCreateManyInput | LikeNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LikeNotification createManyAndReturn
   */
  export type LikeNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many LikeNotifications.
     */
    data: LikeNotificationCreateManyInput | LikeNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikeNotification update
   */
  export type LikeNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a LikeNotification.
     */
    data: XOR<LikeNotificationUpdateInput, LikeNotificationUncheckedUpdateInput>
    /**
     * Choose, which LikeNotification to update.
     */
    where: LikeNotificationWhereUniqueInput
  }

  /**
   * LikeNotification updateMany
   */
  export type LikeNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LikeNotifications.
     */
    data: XOR<LikeNotificationUpdateManyMutationInput, LikeNotificationUncheckedUpdateManyInput>
    /**
     * Filter which LikeNotifications to update
     */
    where?: LikeNotificationWhereInput
    /**
     * Limit how many LikeNotifications to update.
     */
    limit?: number
  }

  /**
   * LikeNotification updateManyAndReturn
   */
  export type LikeNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * The data used to update LikeNotifications.
     */
    data: XOR<LikeNotificationUpdateManyMutationInput, LikeNotificationUncheckedUpdateManyInput>
    /**
     * Filter which LikeNotifications to update
     */
    where?: LikeNotificationWhereInput
    /**
     * Limit how many LikeNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikeNotification upsert
   */
  export type LikeNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the LikeNotification to update in case it exists.
     */
    where: LikeNotificationWhereUniqueInput
    /**
     * In case the LikeNotification found by the `where` argument doesn't exist, create a new LikeNotification with this data.
     */
    create: XOR<LikeNotificationCreateInput, LikeNotificationUncheckedCreateInput>
    /**
     * In case the LikeNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeNotificationUpdateInput, LikeNotificationUncheckedUpdateInput>
  }

  /**
   * LikeNotification delete
   */
  export type LikeNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
    /**
     * Filter which LikeNotification to delete.
     */
    where: LikeNotificationWhereUniqueInput
  }

  /**
   * LikeNotification deleteMany
   */
  export type LikeNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikeNotifications to delete
     */
    where?: LikeNotificationWhereInput
    /**
     * Limit how many LikeNotifications to delete.
     */
    limit?: number
  }

  /**
   * LikeNotification without action
   */
  export type LikeNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeNotification
     */
    select?: LikeNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeNotification
     */
    omit?: LikeNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeNotificationInclude<ExtArgs> | null
  }


  /**
   * Model inboxes
   */

  export type AggregateInboxes = {
    _count: InboxesCountAggregateOutputType | null
    _min: InboxesMinAggregateOutputType | null
    _max: InboxesMaxAggregateOutputType | null
  }

  export type InboxesMinAggregateOutputType = {
    id: string | null
    senderID: string | null
    receiverID: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InboxesMaxAggregateOutputType = {
    id: string | null
    senderID: string | null
    receiverID: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InboxesCountAggregateOutputType = {
    id: number
    senderID: number
    receiverID: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InboxesMinAggregateInputType = {
    id?: true
    senderID?: true
    receiverID?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InboxesMaxAggregateInputType = {
    id?: true
    senderID?: true
    receiverID?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InboxesCountAggregateInputType = {
    id?: true
    senderID?: true
    receiverID?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InboxesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inboxes to aggregate.
     */
    where?: inboxesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inboxes to fetch.
     */
    orderBy?: inboxesOrderByWithRelationInput | inboxesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inboxesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inboxes
    **/
    _count?: true | InboxesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InboxesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InboxesMaxAggregateInputType
  }

  export type GetInboxesAggregateType<T extends InboxesAggregateArgs> = {
        [P in keyof T & keyof AggregateInboxes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInboxes[P]>
      : GetScalarType<T[P], AggregateInboxes[P]>
  }




  export type inboxesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inboxesWhereInput
    orderBy?: inboxesOrderByWithAggregationInput | inboxesOrderByWithAggregationInput[]
    by: InboxesScalarFieldEnum[] | InboxesScalarFieldEnum
    having?: inboxesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InboxesCountAggregateInputType | true
    _min?: InboxesMinAggregateInputType
    _max?: InboxesMaxAggregateInputType
  }

  export type InboxesGroupByOutputType = {
    id: string
    senderID: string
    receiverID: string
    message: string
    createdAt: Date
    updatedAt: Date
    _count: InboxesCountAggregateOutputType | null
    _min: InboxesMinAggregateOutputType | null
    _max: InboxesMaxAggregateOutputType | null
  }

  type GetInboxesGroupByPayload<T extends inboxesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InboxesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InboxesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InboxesGroupByOutputType[P]>
            : GetScalarType<T[P], InboxesGroupByOutputType[P]>
        }
      >
    >


  export type inboxesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderID?: boolean
    receiverID?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_inboxes_receiverIDTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_inboxes_senderIDTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inboxes"]>

  export type inboxesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderID?: boolean
    receiverID?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_inboxes_receiverIDTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_inboxes_senderIDTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inboxes"]>

  export type inboxesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderID?: boolean
    receiverID?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_inboxes_receiverIDTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_inboxes_senderIDTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inboxes"]>

  export type inboxesSelectScalar = {
    id?: boolean
    senderID?: boolean
    receiverID?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type inboxesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderID" | "receiverID" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["inboxes"]>
  export type inboxesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_inboxes_receiverIDTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_inboxes_senderIDTousers?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type inboxesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_inboxes_receiverIDTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_inboxes_senderIDTousers?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type inboxesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_inboxes_receiverIDTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_inboxes_senderIDTousers?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $inboxesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inboxes"
    objects: {
      users_inboxes_receiverIDTousers: Prisma.$UserPayload<ExtArgs>
      users_inboxes_senderIDTousers: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderID: string
      receiverID: string
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inboxes"]>
    composites: {}
  }

  type inboxesGetPayload<S extends boolean | null | undefined | inboxesDefaultArgs> = $Result.GetResult<Prisma.$inboxesPayload, S>

  type inboxesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inboxesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InboxesCountAggregateInputType | true
    }

  export interface inboxesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inboxes'], meta: { name: 'inboxes' } }
    /**
     * Find zero or one Inboxes that matches the filter.
     * @param {inboxesFindUniqueArgs} args - Arguments to find a Inboxes
     * @example
     * // Get one Inboxes
     * const inboxes = await prisma.inboxes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inboxesFindUniqueArgs>(args: SelectSubset<T, inboxesFindUniqueArgs<ExtArgs>>): Prisma__inboxesClient<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inboxes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inboxesFindUniqueOrThrowArgs} args - Arguments to find a Inboxes
     * @example
     * // Get one Inboxes
     * const inboxes = await prisma.inboxes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inboxesFindUniqueOrThrowArgs>(args: SelectSubset<T, inboxesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inboxesClient<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inboxesFindFirstArgs} args - Arguments to find a Inboxes
     * @example
     * // Get one Inboxes
     * const inboxes = await prisma.inboxes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inboxesFindFirstArgs>(args?: SelectSubset<T, inboxesFindFirstArgs<ExtArgs>>): Prisma__inboxesClient<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inboxes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inboxesFindFirstOrThrowArgs} args - Arguments to find a Inboxes
     * @example
     * // Get one Inboxes
     * const inboxes = await prisma.inboxes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inboxesFindFirstOrThrowArgs>(args?: SelectSubset<T, inboxesFindFirstOrThrowArgs<ExtArgs>>): Prisma__inboxesClient<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inboxesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inboxes
     * const inboxes = await prisma.inboxes.findMany()
     * 
     * // Get first 10 Inboxes
     * const inboxes = await prisma.inboxes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inboxesWithIdOnly = await prisma.inboxes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inboxesFindManyArgs>(args?: SelectSubset<T, inboxesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inboxes.
     * @param {inboxesCreateArgs} args - Arguments to create a Inboxes.
     * @example
     * // Create one Inboxes
     * const Inboxes = await prisma.inboxes.create({
     *   data: {
     *     // ... data to create a Inboxes
     *   }
     * })
     * 
     */
    create<T extends inboxesCreateArgs>(args: SelectSubset<T, inboxesCreateArgs<ExtArgs>>): Prisma__inboxesClient<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inboxes.
     * @param {inboxesCreateManyArgs} args - Arguments to create many Inboxes.
     * @example
     * // Create many Inboxes
     * const inboxes = await prisma.inboxes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inboxesCreateManyArgs>(args?: SelectSubset<T, inboxesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inboxes and returns the data saved in the database.
     * @param {inboxesCreateManyAndReturnArgs} args - Arguments to create many Inboxes.
     * @example
     * // Create many Inboxes
     * const inboxes = await prisma.inboxes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inboxes and only return the `id`
     * const inboxesWithIdOnly = await prisma.inboxes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inboxesCreateManyAndReturnArgs>(args?: SelectSubset<T, inboxesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inboxes.
     * @param {inboxesDeleteArgs} args - Arguments to delete one Inboxes.
     * @example
     * // Delete one Inboxes
     * const Inboxes = await prisma.inboxes.delete({
     *   where: {
     *     // ... filter to delete one Inboxes
     *   }
     * })
     * 
     */
    delete<T extends inboxesDeleteArgs>(args: SelectSubset<T, inboxesDeleteArgs<ExtArgs>>): Prisma__inboxesClient<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inboxes.
     * @param {inboxesUpdateArgs} args - Arguments to update one Inboxes.
     * @example
     * // Update one Inboxes
     * const inboxes = await prisma.inboxes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inboxesUpdateArgs>(args: SelectSubset<T, inboxesUpdateArgs<ExtArgs>>): Prisma__inboxesClient<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inboxes.
     * @param {inboxesDeleteManyArgs} args - Arguments to filter Inboxes to delete.
     * @example
     * // Delete a few Inboxes
     * const { count } = await prisma.inboxes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inboxesDeleteManyArgs>(args?: SelectSubset<T, inboxesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inboxesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inboxes
     * const inboxes = await prisma.inboxes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inboxesUpdateManyArgs>(args: SelectSubset<T, inboxesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inboxes and returns the data updated in the database.
     * @param {inboxesUpdateManyAndReturnArgs} args - Arguments to update many Inboxes.
     * @example
     * // Update many Inboxes
     * const inboxes = await prisma.inboxes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inboxes and only return the `id`
     * const inboxesWithIdOnly = await prisma.inboxes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inboxesUpdateManyAndReturnArgs>(args: SelectSubset<T, inboxesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inboxes.
     * @param {inboxesUpsertArgs} args - Arguments to update or create a Inboxes.
     * @example
     * // Update or create a Inboxes
     * const inboxes = await prisma.inboxes.upsert({
     *   create: {
     *     // ... data to create a Inboxes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inboxes we want to update
     *   }
     * })
     */
    upsert<T extends inboxesUpsertArgs>(args: SelectSubset<T, inboxesUpsertArgs<ExtArgs>>): Prisma__inboxesClient<$Result.GetResult<Prisma.$inboxesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inboxesCountArgs} args - Arguments to filter Inboxes to count.
     * @example
     * // Count the number of Inboxes
     * const count = await prisma.inboxes.count({
     *   where: {
     *     // ... the filter for the Inboxes we want to count
     *   }
     * })
    **/
    count<T extends inboxesCountArgs>(
      args?: Subset<T, inboxesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InboxesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboxesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InboxesAggregateArgs>(args: Subset<T, InboxesAggregateArgs>): Prisma.PrismaPromise<GetInboxesAggregateType<T>>

    /**
     * Group by Inboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inboxesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inboxesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inboxesGroupByArgs['orderBy'] }
        : { orderBy?: inboxesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inboxesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInboxesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inboxes model
   */
  readonly fields: inboxesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inboxes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inboxesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_inboxes_receiverIDTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_inboxes_senderIDTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inboxes model
   */
  interface inboxesFieldRefs {
    readonly id: FieldRef<"inboxes", 'String'>
    readonly senderID: FieldRef<"inboxes", 'String'>
    readonly receiverID: FieldRef<"inboxes", 'String'>
    readonly message: FieldRef<"inboxes", 'String'>
    readonly createdAt: FieldRef<"inboxes", 'DateTime'>
    readonly updatedAt: FieldRef<"inboxes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * inboxes findUnique
   */
  export type inboxesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * Filter, which inboxes to fetch.
     */
    where: inboxesWhereUniqueInput
  }

  /**
   * inboxes findUniqueOrThrow
   */
  export type inboxesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * Filter, which inboxes to fetch.
     */
    where: inboxesWhereUniqueInput
  }

  /**
   * inboxes findFirst
   */
  export type inboxesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * Filter, which inboxes to fetch.
     */
    where?: inboxesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inboxes to fetch.
     */
    orderBy?: inboxesOrderByWithRelationInput | inboxesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inboxes.
     */
    cursor?: inboxesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inboxes.
     */
    distinct?: InboxesScalarFieldEnum | InboxesScalarFieldEnum[]
  }

  /**
   * inboxes findFirstOrThrow
   */
  export type inboxesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * Filter, which inboxes to fetch.
     */
    where?: inboxesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inboxes to fetch.
     */
    orderBy?: inboxesOrderByWithRelationInput | inboxesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inboxes.
     */
    cursor?: inboxesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inboxes.
     */
    distinct?: InboxesScalarFieldEnum | InboxesScalarFieldEnum[]
  }

  /**
   * inboxes findMany
   */
  export type inboxesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * Filter, which inboxes to fetch.
     */
    where?: inboxesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inboxes to fetch.
     */
    orderBy?: inboxesOrderByWithRelationInput | inboxesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inboxes.
     */
    cursor?: inboxesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inboxes.
     */
    skip?: number
    distinct?: InboxesScalarFieldEnum | InboxesScalarFieldEnum[]
  }

  /**
   * inboxes create
   */
  export type inboxesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * The data needed to create a inboxes.
     */
    data: XOR<inboxesCreateInput, inboxesUncheckedCreateInput>
  }

  /**
   * inboxes createMany
   */
  export type inboxesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inboxes.
     */
    data: inboxesCreateManyInput | inboxesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inboxes createManyAndReturn
   */
  export type inboxesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * The data used to create many inboxes.
     */
    data: inboxesCreateManyInput | inboxesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inboxes update
   */
  export type inboxesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * The data needed to update a inboxes.
     */
    data: XOR<inboxesUpdateInput, inboxesUncheckedUpdateInput>
    /**
     * Choose, which inboxes to update.
     */
    where: inboxesWhereUniqueInput
  }

  /**
   * inboxes updateMany
   */
  export type inboxesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inboxes.
     */
    data: XOR<inboxesUpdateManyMutationInput, inboxesUncheckedUpdateManyInput>
    /**
     * Filter which inboxes to update
     */
    where?: inboxesWhereInput
    /**
     * Limit how many inboxes to update.
     */
    limit?: number
  }

  /**
   * inboxes updateManyAndReturn
   */
  export type inboxesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * The data used to update inboxes.
     */
    data: XOR<inboxesUpdateManyMutationInput, inboxesUncheckedUpdateManyInput>
    /**
     * Filter which inboxes to update
     */
    where?: inboxesWhereInput
    /**
     * Limit how many inboxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * inboxes upsert
   */
  export type inboxesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * The filter to search for the inboxes to update in case it exists.
     */
    where: inboxesWhereUniqueInput
    /**
     * In case the inboxes found by the `where` argument doesn't exist, create a new inboxes with this data.
     */
    create: XOR<inboxesCreateInput, inboxesUncheckedCreateInput>
    /**
     * In case the inboxes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inboxesUpdateInput, inboxesUncheckedUpdateInput>
  }

  /**
   * inboxes delete
   */
  export type inboxesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
    /**
     * Filter which inboxes to delete.
     */
    where: inboxesWhereUniqueInput
  }

  /**
   * inboxes deleteMany
   */
  export type inboxesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inboxes to delete
     */
    where?: inboxesWhereInput
    /**
     * Limit how many inboxes to delete.
     */
    limit?: number
  }

  /**
   * inboxes without action
   */
  export type inboxesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inboxes
     */
    select?: inboxesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inboxes
     */
    omit?: inboxesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inboxesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    age: 'age',
    about: 'about',
    experience: 'experience',
    interests: 'interests',
    field: 'field',
    password: 'password',
    shortBio: 'shortBio',
    profilePhoto: 'profilePhoto',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BlockedUserScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    blockedID: 'blockedID',
    createdAt: 'createdAt'
  };

  export type BlockedUserScalarFieldEnum = (typeof BlockedUserScalarFieldEnum)[keyof typeof BlockedUserScalarFieldEnum]


  export const ReportUserScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    reportedID: 'reportedID',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ReportUserScalarFieldEnum = (typeof ReportUserScalarFieldEnum)[keyof typeof ReportUserScalarFieldEnum]


  export const ReadHistoryScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    blogId: 'blogId',
    createdAt: 'createdAt'
  };

  export type ReadHistoryScalarFieldEnum = (typeof ReadHistoryScalarFieldEnum)[keyof typeof ReadHistoryScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    title: 'title',
    content: 'content',
    thumbnail: 'thumbnail',
    isMemberOnly: 'isMemberOnly',
    isPublished: 'isPublished',
    viewCount: 'viewCount',
    readCount: 'readCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const BlogLikeScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    blogID: 'blogID',
    createdAt: 'createdAt'
  };

  export type BlogLikeScalarFieldEnum = (typeof BlogLikeScalarFieldEnum)[keyof typeof BlogLikeScalarFieldEnum]


  export const BlogDisLikeScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    blogID: 'blogID',
    createdAt: 'createdAt'
  };

  export type BlogDisLikeScalarFieldEnum = (typeof BlogDisLikeScalarFieldEnum)[keyof typeof BlogDisLikeScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    topicName: 'topicName',
    slug: 'slug'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerID: 'followerID',
    followingID: 'followingID',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    blogId: 'blogId',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const LikeCommentScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    commentID: 'commentID',
    createdAt: 'createdAt'
  };

  export type LikeCommentScalarFieldEnum = (typeof LikeCommentScalarFieldEnum)[keyof typeof LikeCommentScalarFieldEnum]


  export const DisLikeCommentScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    commentID: 'commentID',
    createdAt: 'createdAt'
  };

  export type DisLikeCommentScalarFieldEnum = (typeof DisLikeCommentScalarFieldEnum)[keyof typeof DisLikeCommentScalarFieldEnum]


  export const CommentReplyScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    commentID: 'commentID',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentReplyScalarFieldEnum = (typeof CommentReplyScalarFieldEnum)[keyof typeof CommentReplyScalarFieldEnum]


  export const SavedBlogScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    blogID: 'blogID',
    createdAt: 'createdAt'
  };

  export type SavedBlogScalarFieldEnum = (typeof SavedBlogScalarFieldEnum)[keyof typeof SavedBlogScalarFieldEnum]


  export const MembershipScalarFieldEnum: {
    id: 'id',
    type: 'type',
    userID: 'userID',
    details: 'details',
    price: 'price',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipScalarFieldEnum = (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum]


  export const ReportBlogScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    blogID: 'blogID',
    type: 'type',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type ReportBlogScalarFieldEnum = (typeof ReportBlogScalarFieldEnum)[keyof typeof ReportBlogScalarFieldEnum]


  export const CommentNotificationScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    commentID: 'commentID',
    isSeen: 'isSeen',
    createdAt: 'createdAt'
  };

  export type CommentNotificationScalarFieldEnum = (typeof CommentNotificationScalarFieldEnum)[keyof typeof CommentNotificationScalarFieldEnum]


  export const MessageNotificationScalarFieldEnum: {
    id: 'id',
    receiverID: 'receiverID',
    senderID: 'senderID',
    message: 'message',
    isSeen: 'isSeen',
    createdAt: 'createdAt'
  };

  export type MessageNotificationScalarFieldEnum = (typeof MessageNotificationScalarFieldEnum)[keyof typeof MessageNotificationScalarFieldEnum]


  export const LikeNotificationScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    isSeen: 'isSeen',
    blogLikedId: 'blogLikedId',
    createdAt: 'createdAt'
  };

  export type LikeNotificationScalarFieldEnum = (typeof LikeNotificationScalarFieldEnum)[keyof typeof LikeNotificationScalarFieldEnum]


  export const InboxesScalarFieldEnum: {
    id: 'id',
    senderID: 'senderID',
    receiverID: 'receiverID',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InboxesScalarFieldEnum = (typeof InboxesScalarFieldEnum)[keyof typeof InboxesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'MemberShipType'
   */
  export type EnumMemberShipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberShipType'>
    


  /**
   * Reference to a field of type 'MemberShipType[]'
   */
  export type ListEnumMemberShipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberShipType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ReportMessage'
   */
  export type EnumReportMessageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportMessage'>
    


  /**
   * Reference to a field of type 'ReportMessage[]'
   */
  export type ListEnumReportMessageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportMessage[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    age?: IntNullableFilter<"User"> | number | null
    about?: StringNullableFilter<"User"> | string | null
    experience?: IntNullableFilter<"User"> | number | null
    interests?: StringNullableListFilter<"User">
    field?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    shortBio?: StringNullableFilter<"User"> | string | null
    profilePhoto?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    blockedByUsers?: BlockedUserListRelationFilter
    blockedUsers?: BlockedUserListRelationFilter
    blogDisLikes?: BlogDisLikeListRelationFilter
    blogLikes?: BlogLikeListRelationFilter
    reportedBlogs?: ReportBlogListRelationFilter
    blogs?: BlogListRelationFilter
    disLikeComments?: DisLikeCommentListRelationFilter
    likeComments?: LikeCommentListRelationFilter
    commentNotifications?: CommentNotificationListRelationFilter
    commentReplies?: CommentReplyListRelationFilter
    comments?: CommentListRelationFilter
    followings?: FollowListRelationFilter
    followers?: FollowListRelationFilter
    inboxes_inboxes_receiverIDTousers?: InboxesListRelationFilter
    inboxes_inboxes_senderIDTousers?: InboxesListRelationFilter
    likeNotifications?: LikeNotificationListRelationFilter
    membership?: XOR<MembershipNullableScalarRelationFilter, MembershipWhereInput> | null
    messageNotifications?: MessageNotificationListRelationFilter
    readHistories?: ReadHistoryListRelationFilter
    reportedUsers?: ReportUserListRelationFilter
    usersReported?: ReportUserListRelationFilter
    savedBlogs?: SavedBlogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    age?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    interests?: SortOrder
    field?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    shortBio?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockedByUsers?: BlockedUserOrderByRelationAggregateInput
    blockedUsers?: BlockedUserOrderByRelationAggregateInput
    blogDisLikes?: BlogDisLikeOrderByRelationAggregateInput
    blogLikes?: BlogLikeOrderByRelationAggregateInput
    reportedBlogs?: ReportBlogOrderByRelationAggregateInput
    blogs?: BlogOrderByRelationAggregateInput
    disLikeComments?: DisLikeCommentOrderByRelationAggregateInput
    likeComments?: LikeCommentOrderByRelationAggregateInput
    commentNotifications?: CommentNotificationOrderByRelationAggregateInput
    commentReplies?: CommentReplyOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    followings?: FollowOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    inboxes_inboxes_receiverIDTousers?: inboxesOrderByRelationAggregateInput
    inboxes_inboxes_senderIDTousers?: inboxesOrderByRelationAggregateInput
    likeNotifications?: LikeNotificationOrderByRelationAggregateInput
    membership?: MembershipOrderByWithRelationInput
    messageNotifications?: MessageNotificationOrderByRelationAggregateInput
    readHistories?: ReadHistoryOrderByRelationAggregateInput
    reportedUsers?: ReportUserOrderByRelationAggregateInput
    usersReported?: ReportUserOrderByRelationAggregateInput
    savedBlogs?: SavedBlogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    age?: IntNullableFilter<"User"> | number | null
    about?: StringNullableFilter<"User"> | string | null
    experience?: IntNullableFilter<"User"> | number | null
    interests?: StringNullableListFilter<"User">
    field?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    shortBio?: StringNullableFilter<"User"> | string | null
    profilePhoto?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    blockedByUsers?: BlockedUserListRelationFilter
    blockedUsers?: BlockedUserListRelationFilter
    blogDisLikes?: BlogDisLikeListRelationFilter
    blogLikes?: BlogLikeListRelationFilter
    reportedBlogs?: ReportBlogListRelationFilter
    blogs?: BlogListRelationFilter
    disLikeComments?: DisLikeCommentListRelationFilter
    likeComments?: LikeCommentListRelationFilter
    commentNotifications?: CommentNotificationListRelationFilter
    commentReplies?: CommentReplyListRelationFilter
    comments?: CommentListRelationFilter
    followings?: FollowListRelationFilter
    followers?: FollowListRelationFilter
    inboxes_inboxes_receiverIDTousers?: InboxesListRelationFilter
    inboxes_inboxes_senderIDTousers?: InboxesListRelationFilter
    likeNotifications?: LikeNotificationListRelationFilter
    membership?: XOR<MembershipNullableScalarRelationFilter, MembershipWhereInput> | null
    messageNotifications?: MessageNotificationListRelationFilter
    readHistories?: ReadHistoryListRelationFilter
    reportedUsers?: ReportUserListRelationFilter
    usersReported?: ReportUserListRelationFilter
    savedBlogs?: SavedBlogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    age?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    interests?: SortOrder
    field?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    shortBio?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
    about?: StringNullableWithAggregatesFilter<"User"> | string | null
    experience?: IntNullableWithAggregatesFilter<"User"> | number | null
    interests?: StringNullableListFilter<"User">
    field?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    shortBio?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePhoto?: StringNullableWithAggregatesFilter<"User"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type BlockedUserWhereInput = {
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    id?: StringFilter<"BlockedUser"> | string
    userID?: StringFilter<"BlockedUser"> | string
    blockedID?: StringFilter<"BlockedUser"> | string
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
    blockedUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlockedUserOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    blockedID?: SortOrder
    createdAt?: SortOrder
    blockedUser?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BlockedUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_blockedID?: BlockedUserUserIDBlockedIDCompoundUniqueInput
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    userID?: StringFilter<"BlockedUser"> | string
    blockedID?: StringFilter<"BlockedUser"> | string
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
    blockedUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID_blockedID">

  export type BlockedUserOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    blockedID?: SortOrder
    createdAt?: SortOrder
    _count?: BlockedUserCountOrderByAggregateInput
    _max?: BlockedUserMaxOrderByAggregateInput
    _min?: BlockedUserMinOrderByAggregateInput
  }

  export type BlockedUserScalarWhereWithAggregatesInput = {
    AND?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    OR?: BlockedUserScalarWhereWithAggregatesInput[]
    NOT?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockedUser"> | string
    userID?: StringWithAggregatesFilter<"BlockedUser"> | string
    blockedID?: StringWithAggregatesFilter<"BlockedUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlockedUser"> | Date | string
  }

  export type ReportUserWhereInput = {
    AND?: ReportUserWhereInput | ReportUserWhereInput[]
    OR?: ReportUserWhereInput[]
    NOT?: ReportUserWhereInput | ReportUserWhereInput[]
    id?: StringFilter<"ReportUser"> | string
    userID?: StringFilter<"ReportUser"> | string
    reportedID?: StringFilter<"ReportUser"> | string
    reason?: StringNullableFilter<"ReportUser"> | string | null
    createdAt?: DateTimeFilter<"ReportUser"> | Date | string
    reportedUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReportUserOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    reportedID?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reportedUser?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReportUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_reportedID?: ReportUserUserIDReportedIDCompoundUniqueInput
    AND?: ReportUserWhereInput | ReportUserWhereInput[]
    OR?: ReportUserWhereInput[]
    NOT?: ReportUserWhereInput | ReportUserWhereInput[]
    userID?: StringFilter<"ReportUser"> | string
    reportedID?: StringFilter<"ReportUser"> | string
    reason?: StringNullableFilter<"ReportUser"> | string | null
    createdAt?: DateTimeFilter<"ReportUser"> | Date | string
    reportedUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID_reportedID">

  export type ReportUserOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    reportedID?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReportUserCountOrderByAggregateInput
    _max?: ReportUserMaxOrderByAggregateInput
    _min?: ReportUserMinOrderByAggregateInput
  }

  export type ReportUserScalarWhereWithAggregatesInput = {
    AND?: ReportUserScalarWhereWithAggregatesInput | ReportUserScalarWhereWithAggregatesInput[]
    OR?: ReportUserScalarWhereWithAggregatesInput[]
    NOT?: ReportUserScalarWhereWithAggregatesInput | ReportUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportUser"> | string
    userID?: StringWithAggregatesFilter<"ReportUser"> | string
    reportedID?: StringWithAggregatesFilter<"ReportUser"> | string
    reason?: StringNullableWithAggregatesFilter<"ReportUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReportUser"> | Date | string
  }

  export type ReadHistoryWhereInput = {
    AND?: ReadHistoryWhereInput | ReadHistoryWhereInput[]
    OR?: ReadHistoryWhereInput[]
    NOT?: ReadHistoryWhereInput | ReadHistoryWhereInput[]
    id?: StringFilter<"ReadHistory"> | string
    userID?: StringFilter<"ReadHistory"> | string
    blogId?: StringFilter<"ReadHistory"> | string
    createdAt?: DateTimeFilter<"ReadHistory"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReadHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
    blog?: BlogOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReadHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_blogId?: ReadHistoryUserIDBlogIdCompoundUniqueInput
    AND?: ReadHistoryWhereInput | ReadHistoryWhereInput[]
    OR?: ReadHistoryWhereInput[]
    NOT?: ReadHistoryWhereInput | ReadHistoryWhereInput[]
    userID?: StringFilter<"ReadHistory"> | string
    blogId?: StringFilter<"ReadHistory"> | string
    createdAt?: DateTimeFilter<"ReadHistory"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID_blogId">

  export type ReadHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
    _count?: ReadHistoryCountOrderByAggregateInput
    _max?: ReadHistoryMaxOrderByAggregateInput
    _min?: ReadHistoryMinOrderByAggregateInput
  }

  export type ReadHistoryScalarWhereWithAggregatesInput = {
    AND?: ReadHistoryScalarWhereWithAggregatesInput | ReadHistoryScalarWhereWithAggregatesInput[]
    OR?: ReadHistoryScalarWhereWithAggregatesInput[]
    NOT?: ReadHistoryScalarWhereWithAggregatesInput | ReadHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReadHistory"> | string
    userID?: StringWithAggregatesFilter<"ReadHistory"> | string
    blogId?: StringWithAggregatesFilter<"ReadHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReadHistory"> | Date | string
  }

  export type BlogWhereInput = {
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    id?: StringFilter<"Blog"> | string
    userID?: StringFilter<"Blog"> | string
    title?: StringFilter<"Blog"> | string
    content?: StringFilter<"Blog"> | string
    thumbnail?: StringNullableFilter<"Blog"> | string | null
    isMemberOnly?: BoolFilter<"Blog"> | boolean
    isPublished?: BoolFilter<"Blog"> | boolean
    viewCount?: IntFilter<"Blog"> | number
    readCount?: IntFilter<"Blog"> | number
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    dislikes?: BlogDisLikeListRelationFilter
    likes?: BlogLikeListRelationFilter
    reports?: ReportBlogListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    readHistories?: ReadHistoryListRelationFilter
    savedBy?: SavedBlogListRelationFilter
    topics?: TopicListRelationFilter
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    isMemberOnly?: SortOrder
    isPublished?: SortOrder
    viewCount?: SortOrder
    readCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dislikes?: BlogDisLikeOrderByRelationAggregateInput
    likes?: BlogLikeOrderByRelationAggregateInput
    reports?: ReportBlogOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    readHistories?: ReadHistoryOrderByRelationAggregateInput
    savedBy?: SavedBlogOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
  }

  export type BlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    userID?: StringFilter<"Blog"> | string
    title?: StringFilter<"Blog"> | string
    content?: StringFilter<"Blog"> | string
    thumbnail?: StringNullableFilter<"Blog"> | string | null
    isMemberOnly?: BoolFilter<"Blog"> | boolean
    isPublished?: BoolFilter<"Blog"> | boolean
    viewCount?: IntFilter<"Blog"> | number
    readCount?: IntFilter<"Blog"> | number
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    dislikes?: BlogDisLikeListRelationFilter
    likes?: BlogLikeListRelationFilter
    reports?: ReportBlogListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    readHistories?: ReadHistoryListRelationFilter
    savedBy?: SavedBlogListRelationFilter
    topics?: TopicListRelationFilter
  }, "id">

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    isMemberOnly?: SortOrder
    isPublished?: SortOrder
    viewCount?: SortOrder
    readCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogCountOrderByAggregateInput
    _avg?: BlogAvgOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
    _sum?: BlogSumOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    OR?: BlogScalarWhereWithAggregatesInput[]
    NOT?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Blog"> | string
    userID?: StringWithAggregatesFilter<"Blog"> | string
    title?: StringWithAggregatesFilter<"Blog"> | string
    content?: StringWithAggregatesFilter<"Blog"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    isMemberOnly?: BoolWithAggregatesFilter<"Blog"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Blog"> | boolean
    viewCount?: IntWithAggregatesFilter<"Blog"> | number
    readCount?: IntWithAggregatesFilter<"Blog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
  }

  export type BlogLikeWhereInput = {
    AND?: BlogLikeWhereInput | BlogLikeWhereInput[]
    OR?: BlogLikeWhereInput[]
    NOT?: BlogLikeWhereInput | BlogLikeWhereInput[]
    id?: StringFilter<"BlogLike"> | string
    userID?: StringFilter<"BlogLike"> | string
    blogID?: StringFilter<"BlogLike"> | string
    createdAt?: DateTimeFilter<"BlogLike"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    likeNotifications?: LikeNotificationListRelationFilter
  }

  export type BlogLikeOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
    blog?: BlogOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    likeNotifications?: LikeNotificationOrderByRelationAggregateInput
  }

  export type BlogLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_blogID?: BlogLikeUserIDBlogIDCompoundUniqueInput
    AND?: BlogLikeWhereInput | BlogLikeWhereInput[]
    OR?: BlogLikeWhereInput[]
    NOT?: BlogLikeWhereInput | BlogLikeWhereInput[]
    userID?: StringFilter<"BlogLike"> | string
    blogID?: StringFilter<"BlogLike"> | string
    createdAt?: DateTimeFilter<"BlogLike"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    likeNotifications?: LikeNotificationListRelationFilter
  }, "id" | "userID_blogID">

  export type BlogLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
    _count?: BlogLikeCountOrderByAggregateInput
    _max?: BlogLikeMaxOrderByAggregateInput
    _min?: BlogLikeMinOrderByAggregateInput
  }

  export type BlogLikeScalarWhereWithAggregatesInput = {
    AND?: BlogLikeScalarWhereWithAggregatesInput | BlogLikeScalarWhereWithAggregatesInput[]
    OR?: BlogLikeScalarWhereWithAggregatesInput[]
    NOT?: BlogLikeScalarWhereWithAggregatesInput | BlogLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogLike"> | string
    userID?: StringWithAggregatesFilter<"BlogLike"> | string
    blogID?: StringWithAggregatesFilter<"BlogLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlogLike"> | Date | string
  }

  export type BlogDisLikeWhereInput = {
    AND?: BlogDisLikeWhereInput | BlogDisLikeWhereInput[]
    OR?: BlogDisLikeWhereInput[]
    NOT?: BlogDisLikeWhereInput | BlogDisLikeWhereInput[]
    id?: StringFilter<"BlogDisLike"> | string
    userID?: StringFilter<"BlogDisLike"> | string
    blogID?: StringFilter<"BlogDisLike"> | string
    createdAt?: DateTimeFilter<"BlogDisLike"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlogDisLikeOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
    blog?: BlogOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BlogDisLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_blogID?: BlogDisLikeUserIDBlogIDCompoundUniqueInput
    AND?: BlogDisLikeWhereInput | BlogDisLikeWhereInput[]
    OR?: BlogDisLikeWhereInput[]
    NOT?: BlogDisLikeWhereInput | BlogDisLikeWhereInput[]
    userID?: StringFilter<"BlogDisLike"> | string
    blogID?: StringFilter<"BlogDisLike"> | string
    createdAt?: DateTimeFilter<"BlogDisLike"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID_blogID">

  export type BlogDisLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
    _count?: BlogDisLikeCountOrderByAggregateInput
    _max?: BlogDisLikeMaxOrderByAggregateInput
    _min?: BlogDisLikeMinOrderByAggregateInput
  }

  export type BlogDisLikeScalarWhereWithAggregatesInput = {
    AND?: BlogDisLikeScalarWhereWithAggregatesInput | BlogDisLikeScalarWhereWithAggregatesInput[]
    OR?: BlogDisLikeScalarWhereWithAggregatesInput[]
    NOT?: BlogDisLikeScalarWhereWithAggregatesInput | BlogDisLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogDisLike"> | string
    userID?: StringWithAggregatesFilter<"BlogDisLike"> | string
    blogID?: StringWithAggregatesFilter<"BlogDisLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlogDisLike"> | Date | string
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: StringFilter<"Topic"> | string
    topicName?: StringFilter<"Topic"> | string
    slug?: StringFilter<"Topic"> | string
    blogs?: BlogListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    topicName?: SortOrder
    slug?: SortOrder
    blogs?: BlogOrderByRelationAggregateInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    topicName?: string
    slug?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    blogs?: BlogListRelationFilter
  }, "id" | "topicName" | "slug">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    topicName?: SortOrder
    slug?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topic"> | string
    topicName?: StringWithAggregatesFilter<"Topic"> | string
    slug?: StringWithAggregatesFilter<"Topic"> | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerID?: StringFilter<"Follow"> | string
    followingID?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerID?: SortOrder
    followingID?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerID_followingID?: FollowFollowerIDFollowingIDCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerID?: StringFilter<"Follow"> | string
    followingID?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "followerID_followingID">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerID?: SortOrder
    followingID?: SortOrder
    createdAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerID?: StringWithAggregatesFilter<"Follow"> | string
    followingID?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    userID?: StringFilter<"Comment"> | string
    blogId?: StringFilter<"Comment"> | string
    message?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    disLikeComments?: DisLikeCommentListRelationFilter
    likeComments?: LikeCommentListRelationFilter
    commentNotifications?: CommentNotificationListRelationFilter
    replies?: CommentReplyListRelationFilter
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disLikeComments?: DisLikeCommentOrderByRelationAggregateInput
    likeComments?: LikeCommentOrderByRelationAggregateInput
    commentNotifications?: CommentNotificationOrderByRelationAggregateInput
    replies?: CommentReplyOrderByRelationAggregateInput
    blog?: BlogOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    userID?: StringFilter<"Comment"> | string
    blogId?: StringFilter<"Comment"> | string
    message?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    disLikeComments?: DisLikeCommentListRelationFilter
    likeComments?: LikeCommentListRelationFilter
    commentNotifications?: CommentNotificationListRelationFilter
    replies?: CommentReplyListRelationFilter
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    userID?: StringWithAggregatesFilter<"Comment"> | string
    blogId?: StringWithAggregatesFilter<"Comment"> | string
    message?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type LikeCommentWhereInput = {
    AND?: LikeCommentWhereInput | LikeCommentWhereInput[]
    OR?: LikeCommentWhereInput[]
    NOT?: LikeCommentWhereInput | LikeCommentWhereInput[]
    id?: StringFilter<"LikeComment"> | string
    userID?: StringFilter<"LikeComment"> | string
    commentID?: StringFilter<"LikeComment"> | string
    createdAt?: DateTimeFilter<"LikeComment"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LikeCommentOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LikeCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_commentID?: LikeCommentUserIDCommentIDCompoundUniqueInput
    AND?: LikeCommentWhereInput | LikeCommentWhereInput[]
    OR?: LikeCommentWhereInput[]
    NOT?: LikeCommentWhereInput | LikeCommentWhereInput[]
    userID?: StringFilter<"LikeComment"> | string
    commentID?: StringFilter<"LikeComment"> | string
    createdAt?: DateTimeFilter<"LikeComment"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID_commentID">

  export type LikeCommentOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
    _count?: LikeCommentCountOrderByAggregateInput
    _max?: LikeCommentMaxOrderByAggregateInput
    _min?: LikeCommentMinOrderByAggregateInput
  }

  export type LikeCommentScalarWhereWithAggregatesInput = {
    AND?: LikeCommentScalarWhereWithAggregatesInput | LikeCommentScalarWhereWithAggregatesInput[]
    OR?: LikeCommentScalarWhereWithAggregatesInput[]
    NOT?: LikeCommentScalarWhereWithAggregatesInput | LikeCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LikeComment"> | string
    userID?: StringWithAggregatesFilter<"LikeComment"> | string
    commentID?: StringWithAggregatesFilter<"LikeComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LikeComment"> | Date | string
  }

  export type DisLikeCommentWhereInput = {
    AND?: DisLikeCommentWhereInput | DisLikeCommentWhereInput[]
    OR?: DisLikeCommentWhereInput[]
    NOT?: DisLikeCommentWhereInput | DisLikeCommentWhereInput[]
    id?: StringFilter<"DisLikeComment"> | string
    userID?: StringFilter<"DisLikeComment"> | string
    commentID?: StringFilter<"DisLikeComment"> | string
    createdAt?: DateTimeFilter<"DisLikeComment"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DisLikeCommentOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DisLikeCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_commentID?: DisLikeCommentUserIDCommentIDCompoundUniqueInput
    AND?: DisLikeCommentWhereInput | DisLikeCommentWhereInput[]
    OR?: DisLikeCommentWhereInput[]
    NOT?: DisLikeCommentWhereInput | DisLikeCommentWhereInput[]
    userID?: StringFilter<"DisLikeComment"> | string
    commentID?: StringFilter<"DisLikeComment"> | string
    createdAt?: DateTimeFilter<"DisLikeComment"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID_commentID">

  export type DisLikeCommentOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
    _count?: DisLikeCommentCountOrderByAggregateInput
    _max?: DisLikeCommentMaxOrderByAggregateInput
    _min?: DisLikeCommentMinOrderByAggregateInput
  }

  export type DisLikeCommentScalarWhereWithAggregatesInput = {
    AND?: DisLikeCommentScalarWhereWithAggregatesInput | DisLikeCommentScalarWhereWithAggregatesInput[]
    OR?: DisLikeCommentScalarWhereWithAggregatesInput[]
    NOT?: DisLikeCommentScalarWhereWithAggregatesInput | DisLikeCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisLikeComment"> | string
    userID?: StringWithAggregatesFilter<"DisLikeComment"> | string
    commentID?: StringWithAggregatesFilter<"DisLikeComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DisLikeComment"> | Date | string
  }

  export type CommentReplyWhereInput = {
    AND?: CommentReplyWhereInput | CommentReplyWhereInput[]
    OR?: CommentReplyWhereInput[]
    NOT?: CommentReplyWhereInput | CommentReplyWhereInput[]
    id?: StringFilter<"CommentReply"> | string
    userID?: StringFilter<"CommentReply"> | string
    commentID?: StringFilter<"CommentReply"> | string
    message?: StringFilter<"CommentReply"> | string
    createdAt?: DateTimeFilter<"CommentReply"> | Date | string
    updatedAt?: DateTimeFilter<"CommentReply"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentReplyOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentReplyWhereInput | CommentReplyWhereInput[]
    OR?: CommentReplyWhereInput[]
    NOT?: CommentReplyWhereInput | CommentReplyWhereInput[]
    userID?: StringFilter<"CommentReply"> | string
    commentID?: StringFilter<"CommentReply"> | string
    message?: StringFilter<"CommentReply"> | string
    createdAt?: DateTimeFilter<"CommentReply"> | Date | string
    updatedAt?: DateTimeFilter<"CommentReply"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentReplyOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentReplyCountOrderByAggregateInput
    _max?: CommentReplyMaxOrderByAggregateInput
    _min?: CommentReplyMinOrderByAggregateInput
  }

  export type CommentReplyScalarWhereWithAggregatesInput = {
    AND?: CommentReplyScalarWhereWithAggregatesInput | CommentReplyScalarWhereWithAggregatesInput[]
    OR?: CommentReplyScalarWhereWithAggregatesInput[]
    NOT?: CommentReplyScalarWhereWithAggregatesInput | CommentReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentReply"> | string
    userID?: StringWithAggregatesFilter<"CommentReply"> | string
    commentID?: StringWithAggregatesFilter<"CommentReply"> | string
    message?: StringWithAggregatesFilter<"CommentReply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommentReply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommentReply"> | Date | string
  }

  export type SavedBlogWhereInput = {
    AND?: SavedBlogWhereInput | SavedBlogWhereInput[]
    OR?: SavedBlogWhereInput[]
    NOT?: SavedBlogWhereInput | SavedBlogWhereInput[]
    id?: StringFilter<"SavedBlog"> | string
    userID?: StringFilter<"SavedBlog"> | string
    blogID?: StringFilter<"SavedBlog"> | string
    createdAt?: DateTimeFilter<"SavedBlog"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SavedBlogOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
    blog?: BlogOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SavedBlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_blogID?: SavedBlogUserIDBlogIDCompoundUniqueInput
    AND?: SavedBlogWhereInput | SavedBlogWhereInput[]
    OR?: SavedBlogWhereInput[]
    NOT?: SavedBlogWhereInput | SavedBlogWhereInput[]
    userID?: StringFilter<"SavedBlog"> | string
    blogID?: StringFilter<"SavedBlog"> | string
    createdAt?: DateTimeFilter<"SavedBlog"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID_blogID">

  export type SavedBlogOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
    _count?: SavedBlogCountOrderByAggregateInput
    _max?: SavedBlogMaxOrderByAggregateInput
    _min?: SavedBlogMinOrderByAggregateInput
  }

  export type SavedBlogScalarWhereWithAggregatesInput = {
    AND?: SavedBlogScalarWhereWithAggregatesInput | SavedBlogScalarWhereWithAggregatesInput[]
    OR?: SavedBlogScalarWhereWithAggregatesInput[]
    NOT?: SavedBlogScalarWhereWithAggregatesInput | SavedBlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedBlog"> | string
    userID?: StringWithAggregatesFilter<"SavedBlog"> | string
    blogID?: StringWithAggregatesFilter<"SavedBlog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SavedBlog"> | Date | string
  }

  export type MembershipWhereInput = {
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    id?: StringFilter<"Membership"> | string
    type?: EnumMemberShipTypeFilter<"Membership"> | $Enums.MemberShipType
    userID?: StringFilter<"Membership"> | string
    details?: StringNullableFilter<"Membership"> | string | null
    price?: FloatFilter<"Membership"> | number
    isActive?: BoolFilter<"Membership"> | boolean
    expiresAt?: DateTimeFilter<"Membership"> | Date | string
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    updatedAt?: DateTimeFilter<"Membership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    userID?: SortOrder
    details?: SortOrderInput | SortOrder
    price?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID?: string
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    type?: EnumMemberShipTypeFilter<"Membership"> | $Enums.MemberShipType
    details?: StringNullableFilter<"Membership"> | string | null
    price?: FloatFilter<"Membership"> | number
    isActive?: BoolFilter<"Membership"> | boolean
    expiresAt?: DateTimeFilter<"Membership"> | Date | string
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    updatedAt?: DateTimeFilter<"Membership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID">

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    userID?: SortOrder
    details?: SortOrderInput | SortOrder
    price?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipCountOrderByAggregateInput
    _avg?: MembershipAvgOrderByAggregateInput
    _max?: MembershipMaxOrderByAggregateInput
    _min?: MembershipMinOrderByAggregateInput
    _sum?: MembershipSumOrderByAggregateInput
  }

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    OR?: MembershipScalarWhereWithAggregatesInput[]
    NOT?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Membership"> | string
    type?: EnumMemberShipTypeWithAggregatesFilter<"Membership"> | $Enums.MemberShipType
    userID?: StringWithAggregatesFilter<"Membership"> | string
    details?: StringNullableWithAggregatesFilter<"Membership"> | string | null
    price?: FloatWithAggregatesFilter<"Membership"> | number
    isActive?: BoolWithAggregatesFilter<"Membership"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
  }

  export type ReportBlogWhereInput = {
    AND?: ReportBlogWhereInput | ReportBlogWhereInput[]
    OR?: ReportBlogWhereInput[]
    NOT?: ReportBlogWhereInput | ReportBlogWhereInput[]
    id?: StringFilter<"ReportBlog"> | string
    userID?: StringFilter<"ReportBlog"> | string
    blogID?: StringFilter<"ReportBlog"> | string
    type?: EnumReportMessageFilter<"ReportBlog"> | $Enums.ReportMessage
    message?: StringNullableFilter<"ReportBlog"> | string | null
    createdAt?: DateTimeFilter<"ReportBlog"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReportBlogOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    blog?: BlogOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReportBlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userID_blogID?: ReportBlogUserIDBlogIDCompoundUniqueInput
    AND?: ReportBlogWhereInput | ReportBlogWhereInput[]
    OR?: ReportBlogWhereInput[]
    NOT?: ReportBlogWhereInput | ReportBlogWhereInput[]
    userID?: StringFilter<"ReportBlog"> | string
    blogID?: StringFilter<"ReportBlog"> | string
    type?: EnumReportMessageFilter<"ReportBlog"> | $Enums.ReportMessage
    message?: StringNullableFilter<"ReportBlog"> | string | null
    createdAt?: DateTimeFilter<"ReportBlog"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userID_blogID">

  export type ReportBlogOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReportBlogCountOrderByAggregateInput
    _max?: ReportBlogMaxOrderByAggregateInput
    _min?: ReportBlogMinOrderByAggregateInput
  }

  export type ReportBlogScalarWhereWithAggregatesInput = {
    AND?: ReportBlogScalarWhereWithAggregatesInput | ReportBlogScalarWhereWithAggregatesInput[]
    OR?: ReportBlogScalarWhereWithAggregatesInput[]
    NOT?: ReportBlogScalarWhereWithAggregatesInput | ReportBlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportBlog"> | string
    userID?: StringWithAggregatesFilter<"ReportBlog"> | string
    blogID?: StringWithAggregatesFilter<"ReportBlog"> | string
    type?: EnumReportMessageWithAggregatesFilter<"ReportBlog"> | $Enums.ReportMessage
    message?: StringNullableWithAggregatesFilter<"ReportBlog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReportBlog"> | Date | string
  }

  export type CommentNotificationWhereInput = {
    AND?: CommentNotificationWhereInput | CommentNotificationWhereInput[]
    OR?: CommentNotificationWhereInput[]
    NOT?: CommentNotificationWhereInput | CommentNotificationWhereInput[]
    id?: StringFilter<"CommentNotification"> | string
    userID?: StringFilter<"CommentNotification"> | string
    commentID?: StringFilter<"CommentNotification"> | string
    isSeen?: BoolFilter<"CommentNotification"> | boolean
    createdAt?: DateTimeFilter<"CommentNotification"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentNotificationWhereInput | CommentNotificationWhereInput[]
    OR?: CommentNotificationWhereInput[]
    NOT?: CommentNotificationWhereInput | CommentNotificationWhereInput[]
    userID?: StringFilter<"CommentNotification"> | string
    commentID?: StringFilter<"CommentNotification"> | string
    isSeen?: BoolFilter<"CommentNotification"> | boolean
    createdAt?: DateTimeFilter<"CommentNotification"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
    _count?: CommentNotificationCountOrderByAggregateInput
    _max?: CommentNotificationMaxOrderByAggregateInput
    _min?: CommentNotificationMinOrderByAggregateInput
  }

  export type CommentNotificationScalarWhereWithAggregatesInput = {
    AND?: CommentNotificationScalarWhereWithAggregatesInput | CommentNotificationScalarWhereWithAggregatesInput[]
    OR?: CommentNotificationScalarWhereWithAggregatesInput[]
    NOT?: CommentNotificationScalarWhereWithAggregatesInput | CommentNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentNotification"> | string
    userID?: StringWithAggregatesFilter<"CommentNotification"> | string
    commentID?: StringWithAggregatesFilter<"CommentNotification"> | string
    isSeen?: BoolWithAggregatesFilter<"CommentNotification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CommentNotification"> | Date | string
  }

  export type MessageNotificationWhereInput = {
    AND?: MessageNotificationWhereInput | MessageNotificationWhereInput[]
    OR?: MessageNotificationWhereInput[]
    NOT?: MessageNotificationWhereInput | MessageNotificationWhereInput[]
    id?: StringFilter<"MessageNotification"> | string
    receiverID?: StringFilter<"MessageNotification"> | string
    senderID?: StringFilter<"MessageNotification"> | string
    message?: StringFilter<"MessageNotification"> | string
    isSeen?: BoolFilter<"MessageNotification"> | boolean
    createdAt?: DateTimeFilter<"MessageNotification"> | Date | string
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageNotificationOrderByWithRelationInput = {
    id?: SortOrder
    receiverID?: SortOrder
    senderID?: SortOrder
    message?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
    receiver?: UserOrderByWithRelationInput
  }

  export type MessageNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageNotificationWhereInput | MessageNotificationWhereInput[]
    OR?: MessageNotificationWhereInput[]
    NOT?: MessageNotificationWhereInput | MessageNotificationWhereInput[]
    receiverID?: StringFilter<"MessageNotification"> | string
    senderID?: StringFilter<"MessageNotification"> | string
    message?: StringFilter<"MessageNotification"> | string
    isSeen?: BoolFilter<"MessageNotification"> | boolean
    createdAt?: DateTimeFilter<"MessageNotification"> | Date | string
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    receiverID?: SortOrder
    senderID?: SortOrder
    message?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
    _count?: MessageNotificationCountOrderByAggregateInput
    _max?: MessageNotificationMaxOrderByAggregateInput
    _min?: MessageNotificationMinOrderByAggregateInput
  }

  export type MessageNotificationScalarWhereWithAggregatesInput = {
    AND?: MessageNotificationScalarWhereWithAggregatesInput | MessageNotificationScalarWhereWithAggregatesInput[]
    OR?: MessageNotificationScalarWhereWithAggregatesInput[]
    NOT?: MessageNotificationScalarWhereWithAggregatesInput | MessageNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageNotification"> | string
    receiverID?: StringWithAggregatesFilter<"MessageNotification"> | string
    senderID?: StringWithAggregatesFilter<"MessageNotification"> | string
    message?: StringWithAggregatesFilter<"MessageNotification"> | string
    isSeen?: BoolWithAggregatesFilter<"MessageNotification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MessageNotification"> | Date | string
  }

  export type LikeNotificationWhereInput = {
    AND?: LikeNotificationWhereInput | LikeNotificationWhereInput[]
    OR?: LikeNotificationWhereInput[]
    NOT?: LikeNotificationWhereInput | LikeNotificationWhereInput[]
    id?: StringFilter<"LikeNotification"> | string
    userID?: StringFilter<"LikeNotification"> | string
    isSeen?: BoolFilter<"LikeNotification"> | boolean
    blogLikedId?: StringFilter<"LikeNotification"> | string
    createdAt?: DateTimeFilter<"LikeNotification"> | Date | string
    blog?: XOR<BlogLikeScalarRelationFilter, BlogLikeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LikeNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    isSeen?: SortOrder
    blogLikedId?: SortOrder
    createdAt?: SortOrder
    blog?: BlogLikeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LikeNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LikeNotificationWhereInput | LikeNotificationWhereInput[]
    OR?: LikeNotificationWhereInput[]
    NOT?: LikeNotificationWhereInput | LikeNotificationWhereInput[]
    userID?: StringFilter<"LikeNotification"> | string
    isSeen?: BoolFilter<"LikeNotification"> | boolean
    blogLikedId?: StringFilter<"LikeNotification"> | string
    createdAt?: DateTimeFilter<"LikeNotification"> | Date | string
    blog?: XOR<BlogLikeScalarRelationFilter, BlogLikeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LikeNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    isSeen?: SortOrder
    blogLikedId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeNotificationCountOrderByAggregateInput
    _max?: LikeNotificationMaxOrderByAggregateInput
    _min?: LikeNotificationMinOrderByAggregateInput
  }

  export type LikeNotificationScalarWhereWithAggregatesInput = {
    AND?: LikeNotificationScalarWhereWithAggregatesInput | LikeNotificationScalarWhereWithAggregatesInput[]
    OR?: LikeNotificationScalarWhereWithAggregatesInput[]
    NOT?: LikeNotificationScalarWhereWithAggregatesInput | LikeNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LikeNotification"> | string
    userID?: StringWithAggregatesFilter<"LikeNotification"> | string
    isSeen?: BoolWithAggregatesFilter<"LikeNotification"> | boolean
    blogLikedId?: StringWithAggregatesFilter<"LikeNotification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LikeNotification"> | Date | string
  }

  export type inboxesWhereInput = {
    AND?: inboxesWhereInput | inboxesWhereInput[]
    OR?: inboxesWhereInput[]
    NOT?: inboxesWhereInput | inboxesWhereInput[]
    id?: StringFilter<"inboxes"> | string
    senderID?: StringFilter<"inboxes"> | string
    receiverID?: StringFilter<"inboxes"> | string
    message?: StringFilter<"inboxes"> | string
    createdAt?: DateTimeFilter<"inboxes"> | Date | string
    updatedAt?: DateTimeFilter<"inboxes"> | Date | string
    users_inboxes_receiverIDTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
    users_inboxes_senderIDTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type inboxesOrderByWithRelationInput = {
    id?: SortOrder
    senderID?: SortOrder
    receiverID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_inboxes_receiverIDTousers?: UserOrderByWithRelationInput
    users_inboxes_senderIDTousers?: UserOrderByWithRelationInput
  }

  export type inboxesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: inboxesWhereInput | inboxesWhereInput[]
    OR?: inboxesWhereInput[]
    NOT?: inboxesWhereInput | inboxesWhereInput[]
    senderID?: StringFilter<"inboxes"> | string
    receiverID?: StringFilter<"inboxes"> | string
    message?: StringFilter<"inboxes"> | string
    createdAt?: DateTimeFilter<"inboxes"> | Date | string
    updatedAt?: DateTimeFilter<"inboxes"> | Date | string
    users_inboxes_receiverIDTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
    users_inboxes_senderIDTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type inboxesOrderByWithAggregationInput = {
    id?: SortOrder
    senderID?: SortOrder
    receiverID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: inboxesCountOrderByAggregateInput
    _max?: inboxesMaxOrderByAggregateInput
    _min?: inboxesMinOrderByAggregateInput
  }

  export type inboxesScalarWhereWithAggregatesInput = {
    AND?: inboxesScalarWhereWithAggregatesInput | inboxesScalarWhereWithAggregatesInput[]
    OR?: inboxesScalarWhereWithAggregatesInput[]
    NOT?: inboxesScalarWhereWithAggregatesInput | inboxesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"inboxes"> | string
    senderID?: StringWithAggregatesFilter<"inboxes"> | string
    receiverID?: StringWithAggregatesFilter<"inboxes"> | string
    message?: StringWithAggregatesFilter<"inboxes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"inboxes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"inboxes"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateInput = {
    id?: string
    createdAt?: Date | string
    blockedUser: UserCreateNestedOneWithoutBlockedByUsersInput
    user: UserCreateNestedOneWithoutBlockedUsersInput
  }

  export type BlockedUserUncheckedCreateInput = {
    id?: string
    userID: string
    blockedID: string
    createdAt?: Date | string
  }

  export type BlockedUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedUser?: UserUpdateOneRequiredWithoutBlockedByUsersNestedInput
    user?: UserUpdateOneRequiredWithoutBlockedUsersNestedInput
  }

  export type BlockedUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blockedID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateManyInput = {
    id?: string
    userID: string
    blockedID: string
    createdAt?: Date | string
  }

  export type BlockedUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blockedID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserCreateInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    reportedUser: UserCreateNestedOneWithoutReportedUsersInput
    user: UserCreateNestedOneWithoutUsersReportedInput
  }

  export type ReportUserUncheckedCreateInput = {
    id?: string
    userID: string
    reportedID: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReportUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUser?: UserUpdateOneRequiredWithoutReportedUsersNestedInput
    user?: UserUpdateOneRequiredWithoutUsersReportedNestedInput
  }

  export type ReportUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    reportedID?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserCreateManyInput = {
    id?: string
    userID: string
    reportedID: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReportUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    reportedID?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadHistoryCreateInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutReadHistoriesInput
    user: UserCreateNestedOneWithoutReadHistoriesInput
  }

  export type ReadHistoryUncheckedCreateInput = {
    id?: string
    userID: string
    blogId: string
    createdAt?: Date | string
  }

  export type ReadHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutReadHistoriesNestedInput
    user?: UserUpdateOneRequiredWithoutReadHistoriesNestedInput
  }

  export type ReadHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadHistoryCreateManyInput = {
    id?: string
    userID: string
    blogId: string
    createdAt?: Date | string
  }

  export type ReadHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeCreateNestedManyWithoutBlogInput
    likes?: BlogLikeCreateNestedManyWithoutBlogInput
    reports?: ReportBlogCreateNestedManyWithoutBlogInput
    user: UserCreateNestedOneWithoutBlogsInput
    comments?: CommentCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogCreateNestedManyWithoutBlogInput
    topics?: TopicCreateNestedManyWithoutBlogsInput
  }

  export type BlogUncheckedCreateInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput
    likes?: BlogLikeUncheckedCreateNestedManyWithoutBlogInput
    reports?: ReportBlogUncheckedCreateNestedManyWithoutBlogInput
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogUncheckedCreateNestedManyWithoutBlogInput
    topics?: TopicUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type BlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUpdateManyWithoutBlogNestedInput
    user?: UserUpdateOneRequiredWithoutBlogsNestedInput
    comments?: CommentUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUpdateManyWithoutBlogNestedInput
    topics?: TopicUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUncheckedUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUncheckedUpdateManyWithoutBlogNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUncheckedUpdateManyWithoutBlogNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBlogsNestedInput
  }

  export type BlogCreateManyInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutBlogLikesInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutBlogInput
  }

  export type BlogLikeUncheckedCreateInput = {
    id?: string
    userID: string
    blogID: string
    createdAt?: Date | string
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutBlogLikesNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutBlogNestedInput
  }

  export type BlogLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogLikeCreateManyInput = {
    id?: string
    userID: string
    blogID: string
    createdAt?: Date | string
  }

  export type BlogLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogDisLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutDislikesInput
    user: UserCreateNestedOneWithoutBlogDisLikesInput
  }

  export type BlogDisLikeUncheckedCreateInput = {
    id?: string
    userID: string
    blogID: string
    createdAt?: Date | string
  }

  export type BlogDisLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutDislikesNestedInput
    user?: UserUpdateOneRequiredWithoutBlogDisLikesNestedInput
  }

  export type BlogDisLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogDisLikeCreateManyInput = {
    id?: string
    userID: string
    blogID: string
    createdAt?: Date | string
  }

  export type BlogDisLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogDisLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateInput = {
    id?: string
    topicName: string
    slug: string
    blogs?: BlogCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateInput = {
    id?: string
    topicName: string
    slug: string
    blogs?: BlogUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    blogs?: BlogUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    blogs?: BlogUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicCreateManyInput = {
    id?: string
    topicName: string
    slug: string
  }

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingsInput
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerID: string
    followingID: string
    createdAt?: Date | string
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingsNestedInput
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerID?: StringFieldUpdateOperationsInput | string
    followingID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerID: string
    followingID: string
    createdAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerID?: StringFieldUpdateOperationsInput | string
    followingID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    blog: BlogCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    userID: string
    blogId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    blog?: BlogUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    userID: string
    blogId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCommentCreateInput = {
    id?: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutLikeCommentsInput
    user: UserCreateNestedOneWithoutLikeCommentsInput
  }

  export type LikeCommentUncheckedCreateInput = {
    id?: string
    userID: string
    commentID: string
    createdAt?: Date | string
  }

  export type LikeCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutLikeCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutLikeCommentsNestedInput
  }

  export type LikeCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCommentCreateManyInput = {
    id?: string
    userID: string
    commentID: string
    createdAt?: Date | string
  }

  export type LikeCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisLikeCommentCreateInput = {
    id?: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutDisLikeCommentsInput
    user: UserCreateNestedOneWithoutDisLikeCommentsInput
  }

  export type DisLikeCommentUncheckedCreateInput = {
    id?: string
    userID: string
    commentID: string
    createdAt?: Date | string
  }

  export type DisLikeCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutDisLikeCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutDisLikeCommentsNestedInput
  }

  export type DisLikeCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisLikeCommentCreateManyInput = {
    id?: string
    userID: string
    commentID: string
    createdAt?: Date | string
  }

  export type DisLikeCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisLikeCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReplyCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comment: CommentCreateNestedOneWithoutRepliesInput
    user: UserCreateNestedOneWithoutCommentRepliesInput
  }

  export type CommentReplyUncheckedCreateInput = {
    id?: string
    userID: string
    commentID: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
    user?: UserUpdateOneRequiredWithoutCommentRepliesNestedInput
  }

  export type CommentReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReplyCreateManyInput = {
    id?: string
    userID: string
    commentID: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedBlogCreateInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutSavedByInput
    user: UserCreateNestedOneWithoutSavedBlogsInput
  }

  export type SavedBlogUncheckedCreateInput = {
    id?: string
    userID: string
    blogID: string
    createdAt?: Date | string
  }

  export type SavedBlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutSavedByNestedInput
    user?: UserUpdateOneRequiredWithoutSavedBlogsNestedInput
  }

  export type SavedBlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedBlogCreateManyInput = {
    id?: string
    userID: string
    blogID: string
    createdAt?: Date | string
  }

  export type SavedBlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedBlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateInput = {
    id?: string
    type: $Enums.MemberShipType
    details?: string | null
    price: number
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipInput
  }

  export type MembershipUncheckedCreateInput = {
    id?: string
    type: $Enums.MemberShipType
    userID: string
    details?: string | null
    price: number
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipNestedInput
  }

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    userID?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateManyInput = {
    id?: string
    type: $Enums.MemberShipType
    userID: string
    details?: string | null
    price: number
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    userID?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportBlogCreateInput = {
    id?: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutReportsInput
    user: UserCreateNestedOneWithoutReportedBlogsInput
  }

  export type ReportBlogUncheckedCreateInput = {
    id?: string
    userID: string
    blogID: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
  }

  export type ReportBlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutReportsNestedInput
    user?: UserUpdateOneRequiredWithoutReportedBlogsNestedInput
  }

  export type ReportBlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportBlogCreateManyInput = {
    id?: string
    userID: string
    blogID: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
  }

  export type ReportBlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportBlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentNotificationCreateInput = {
    id?: string
    isSeen?: boolean
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutCommentNotificationsInput
    user: UserCreateNestedOneWithoutCommentNotificationsInput
  }

  export type CommentNotificationUncheckedCreateInput = {
    id?: string
    userID: string
    commentID: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type CommentNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutCommentNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentNotificationsNestedInput
  }

  export type CommentNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentNotificationCreateManyInput = {
    id?: string
    userID: string
    commentID: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type CommentNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageNotificationCreateInput = {
    id?: string
    senderID: string
    message: string
    isSeen?: boolean
    createdAt?: Date | string
    receiver: UserCreateNestedOneWithoutMessageNotificationsInput
  }

  export type MessageNotificationUncheckedCreateInput = {
    id?: string
    receiverID: string
    senderID: string
    message: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type MessageNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutMessageNotificationsNestedInput
  }

  export type MessageNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverID?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageNotificationCreateManyInput = {
    id?: string
    receiverID: string
    senderID: string
    message: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type MessageNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverID?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeNotificationCreateInput = {
    id?: string
    isSeen?: boolean
    createdAt?: Date | string
    blog: BlogLikeCreateNestedOneWithoutLikeNotificationsInput
    user: UserCreateNestedOneWithoutLikeNotificationsInput
  }

  export type LikeNotificationUncheckedCreateInput = {
    id?: string
    userID: string
    isSeen?: boolean
    blogLikedId: string
    createdAt?: Date | string
  }

  export type LikeNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogLikeUpdateOneRequiredWithoutLikeNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutLikeNotificationsNestedInput
  }

  export type LikeNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    blogLikedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeNotificationCreateManyInput = {
    id?: string
    userID: string
    isSeen?: boolean
    blogLikedId: string
    createdAt?: Date | string
  }

  export type LikeNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    blogLikedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inboxesCreateInput = {
    id: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
    users_inboxes_receiverIDTousers: UserCreateNestedOneWithoutInboxes_inboxes_receiverIDTousersInput
    users_inboxes_senderIDTousers: UserCreateNestedOneWithoutInboxes_inboxes_senderIDTousersInput
  }

  export type inboxesUncheckedCreateInput = {
    id: string
    senderID: string
    receiverID: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type inboxesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_inboxes_receiverIDTousers?: UserUpdateOneRequiredWithoutInboxes_inboxes_receiverIDTousersNestedInput
    users_inboxes_senderIDTousers?: UserUpdateOneRequiredWithoutInboxes_inboxes_senderIDTousersNestedInput
  }

  export type inboxesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    receiverID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inboxesCreateManyInput = {
    id: string
    senderID: string
    receiverID: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type inboxesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inboxesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    receiverID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BlockedUserListRelationFilter = {
    every?: BlockedUserWhereInput
    some?: BlockedUserWhereInput
    none?: BlockedUserWhereInput
  }

  export type BlogDisLikeListRelationFilter = {
    every?: BlogDisLikeWhereInput
    some?: BlogDisLikeWhereInput
    none?: BlogDisLikeWhereInput
  }

  export type BlogLikeListRelationFilter = {
    every?: BlogLikeWhereInput
    some?: BlogLikeWhereInput
    none?: BlogLikeWhereInput
  }

  export type ReportBlogListRelationFilter = {
    every?: ReportBlogWhereInput
    some?: ReportBlogWhereInput
    none?: ReportBlogWhereInput
  }

  export type BlogListRelationFilter = {
    every?: BlogWhereInput
    some?: BlogWhereInput
    none?: BlogWhereInput
  }

  export type DisLikeCommentListRelationFilter = {
    every?: DisLikeCommentWhereInput
    some?: DisLikeCommentWhereInput
    none?: DisLikeCommentWhereInput
  }

  export type LikeCommentListRelationFilter = {
    every?: LikeCommentWhereInput
    some?: LikeCommentWhereInput
    none?: LikeCommentWhereInput
  }

  export type CommentNotificationListRelationFilter = {
    every?: CommentNotificationWhereInput
    some?: CommentNotificationWhereInput
    none?: CommentNotificationWhereInput
  }

  export type CommentReplyListRelationFilter = {
    every?: CommentReplyWhereInput
    some?: CommentReplyWhereInput
    none?: CommentReplyWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type InboxesListRelationFilter = {
    every?: inboxesWhereInput
    some?: inboxesWhereInput
    none?: inboxesWhereInput
  }

  export type LikeNotificationListRelationFilter = {
    every?: LikeNotificationWhereInput
    some?: LikeNotificationWhereInput
    none?: LikeNotificationWhereInput
  }

  export type MembershipNullableScalarRelationFilter = {
    is?: MembershipWhereInput | null
    isNot?: MembershipWhereInput | null
  }

  export type MessageNotificationListRelationFilter = {
    every?: MessageNotificationWhereInput
    some?: MessageNotificationWhereInput
    none?: MessageNotificationWhereInput
  }

  export type ReadHistoryListRelationFilter = {
    every?: ReadHistoryWhereInput
    some?: ReadHistoryWhereInput
    none?: ReadHistoryWhereInput
  }

  export type ReportUserListRelationFilter = {
    every?: ReportUserWhereInput
    some?: ReportUserWhereInput
    none?: ReportUserWhereInput
  }

  export type SavedBlogListRelationFilter = {
    every?: SavedBlogWhereInput
    some?: SavedBlogWhereInput
    none?: SavedBlogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BlockedUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogDisLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportBlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisLikeCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type inboxesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReadHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedBlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    age?: SortOrder
    about?: SortOrder
    experience?: SortOrder
    interests?: SortOrder
    field?: SortOrder
    password?: SortOrder
    shortBio?: SortOrder
    profilePhoto?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    age?: SortOrder
    experience?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    age?: SortOrder
    about?: SortOrder
    experience?: SortOrder
    field?: SortOrder
    password?: SortOrder
    shortBio?: SortOrder
    profilePhoto?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    age?: SortOrder
    about?: SortOrder
    experience?: SortOrder
    field?: SortOrder
    password?: SortOrder
    shortBio?: SortOrder
    profilePhoto?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    age?: SortOrder
    experience?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BlockedUserUserIDBlockedIDCompoundUniqueInput = {
    userID: string
    blockedID: string
  }

  export type BlockedUserCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blockedID?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blockedID?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blockedID?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportUserUserIDReportedIDCompoundUniqueInput = {
    userID: string
    reportedID: string
  }

  export type ReportUserCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    reportedID?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    reportedID?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportUserMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    reportedID?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogScalarRelationFilter = {
    is?: BlogWhereInput
    isNot?: BlogWhereInput
  }

  export type ReadHistoryUserIDBlogIdCompoundUniqueInput = {
    userID: string
    blogId: string
  }

  export type ReadHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReadHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReadHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    thumbnail?: SortOrder
    isMemberOnly?: SortOrder
    isPublished?: SortOrder
    viewCount?: SortOrder
    readCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    readCount?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    thumbnail?: SortOrder
    isMemberOnly?: SortOrder
    isPublished?: SortOrder
    viewCount?: SortOrder
    readCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    thumbnail?: SortOrder
    isMemberOnly?: SortOrder
    isPublished?: SortOrder
    viewCount?: SortOrder
    readCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogSumOrderByAggregateInput = {
    viewCount?: SortOrder
    readCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BlogLikeUserIDBlogIDCompoundUniqueInput = {
    userID: string
    blogID: string
  }

  export type BlogLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogDisLikeUserIDBlogIDCompoundUniqueInput = {
    userID: string
    blogID: string
  }

  export type BlogDisLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogDisLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogDisLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    slug?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    slug?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    slug?: SortOrder
  }

  export type FollowFollowerIDFollowingIDCompoundUniqueInput = {
    followerID: string
    followingID: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerID?: SortOrder
    followingID?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerID?: SortOrder
    followingID?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerID?: SortOrder
    followingID?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type LikeCommentUserIDCommentIDCompoundUniqueInput = {
    userID: string
    commentID: string
  }

  export type LikeCommentCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeCommentMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
  }

  export type DisLikeCommentUserIDCommentIDCompoundUniqueInput = {
    userID: string
    commentID: string
  }

  export type DisLikeCommentCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
  }

  export type DisLikeCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
  }

  export type DisLikeCommentMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentReplyCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentReplyMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedBlogUserIDBlogIDCompoundUniqueInput = {
    userID: string
    blogID: string
  }

  export type SavedBlogCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedBlogMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedBlogMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMemberShipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberShipType | EnumMemberShipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberShipTypeFilter<$PrismaModel> | $Enums.MemberShipType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userID?: SortOrder
    details?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userID?: SortOrder
    details?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userID?: SortOrder
    details?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumMemberShipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberShipType | EnumMemberShipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberShipTypeWithAggregatesFilter<$PrismaModel> | $Enums.MemberShipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberShipTypeFilter<$PrismaModel>
    _max?: NestedEnumMemberShipTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumReportMessageFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportMessage | EnumReportMessageFieldRefInput<$PrismaModel>
    in?: $Enums.ReportMessage[] | ListEnumReportMessageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportMessage[] | ListEnumReportMessageFieldRefInput<$PrismaModel>
    not?: NestedEnumReportMessageFilter<$PrismaModel> | $Enums.ReportMessage
  }

  export type ReportBlogUserIDBlogIDCompoundUniqueInput = {
    userID: string
    blogID: string
  }

  export type ReportBlogCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportBlogMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportBlogMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    blogID?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReportMessageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportMessage | EnumReportMessageFieldRefInput<$PrismaModel>
    in?: $Enums.ReportMessage[] | ListEnumReportMessageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportMessage[] | ListEnumReportMessageFieldRefInput<$PrismaModel>
    not?: NestedEnumReportMessageWithAggregatesFilter<$PrismaModel> | $Enums.ReportMessage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportMessageFilter<$PrismaModel>
    _max?: NestedEnumReportMessageFilter<$PrismaModel>
  }

  export type CommentNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    commentID?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    receiverID?: SortOrder
    senderID?: SortOrder
    message?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    receiverID?: SortOrder
    senderID?: SortOrder
    message?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    receiverID?: SortOrder
    senderID?: SortOrder
    message?: SortOrder
    isSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogLikeScalarRelationFilter = {
    is?: BlogLikeWhereInput
    isNot?: BlogLikeWhereInput
  }

  export type LikeNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    isSeen?: SortOrder
    blogLikedId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    isSeen?: SortOrder
    blogLikedId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    isSeen?: SortOrder
    blogLikedId?: SortOrder
    createdAt?: SortOrder
  }

  export type inboxesCountOrderByAggregateInput = {
    id?: SortOrder
    senderID?: SortOrder
    receiverID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type inboxesMaxOrderByAggregateInput = {
    id?: SortOrder
    senderID?: SortOrder
    receiverID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type inboxesMinOrderByAggregateInput = {
    id?: SortOrder
    senderID?: SortOrder
    receiverID?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateinterestsInput = {
    set: string[]
  }

  export type BlockedUserCreateNestedManyWithoutBlockedUserInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedUserInput, BlockedUserUncheckedCreateWithoutBlockedUserInput> | BlockedUserCreateWithoutBlockedUserInput[] | BlockedUserUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedUserInput | BlockedUserCreateOrConnectWithoutBlockedUserInput[]
    createMany?: BlockedUserCreateManyBlockedUserInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlockedUserCreateNestedManyWithoutUserInput = {
    create?: XOR<BlockedUserCreateWithoutUserInput, BlockedUserUncheckedCreateWithoutUserInput> | BlockedUserCreateWithoutUserInput[] | BlockedUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutUserInput | BlockedUserCreateOrConnectWithoutUserInput[]
    createMany?: BlockedUserCreateManyUserInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlogDisLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogDisLikeCreateWithoutUserInput, BlogDisLikeUncheckedCreateWithoutUserInput> | BlogDisLikeCreateWithoutUserInput[] | BlogDisLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogDisLikeCreateOrConnectWithoutUserInput | BlogDisLikeCreateOrConnectWithoutUserInput[]
    createMany?: BlogDisLikeCreateManyUserInputEnvelope
    connect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
  }

  export type BlogLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogLikeCreateWithoutUserInput, BlogLikeUncheckedCreateWithoutUserInput> | BlogLikeCreateWithoutUserInput[] | BlogLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogLikeCreateOrConnectWithoutUserInput | BlogLikeCreateOrConnectWithoutUserInput[]
    createMany?: BlogLikeCreateManyUserInputEnvelope
    connect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
  }

  export type ReportBlogCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportBlogCreateWithoutUserInput, ReportBlogUncheckedCreateWithoutUserInput> | ReportBlogCreateWithoutUserInput[] | ReportBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportBlogCreateOrConnectWithoutUserInput | ReportBlogCreateOrConnectWithoutUserInput[]
    createMany?: ReportBlogCreateManyUserInputEnvelope
    connect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
  }

  export type BlogCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput> | BlogCreateWithoutUserInput[] | BlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutUserInput | BlogCreateOrConnectWithoutUserInput[]
    createMany?: BlogCreateManyUserInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type DisLikeCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<DisLikeCommentCreateWithoutUserInput, DisLikeCommentUncheckedCreateWithoutUserInput> | DisLikeCommentCreateWithoutUserInput[] | DisLikeCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DisLikeCommentCreateOrConnectWithoutUserInput | DisLikeCommentCreateOrConnectWithoutUserInput[]
    createMany?: DisLikeCommentCreateManyUserInputEnvelope
    connect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
  }

  export type LikeCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCommentCreateWithoutUserInput, LikeCommentUncheckedCreateWithoutUserInput> | LikeCommentCreateWithoutUserInput[] | LikeCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCommentCreateOrConnectWithoutUserInput | LikeCommentCreateOrConnectWithoutUserInput[]
    createMany?: LikeCommentCreateManyUserInputEnvelope
    connect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
  }

  export type CommentNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentNotificationCreateWithoutUserInput, CommentNotificationUncheckedCreateWithoutUserInput> | CommentNotificationCreateWithoutUserInput[] | CommentNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentNotificationCreateOrConnectWithoutUserInput | CommentNotificationCreateOrConnectWithoutUserInput[]
    createMany?: CommentNotificationCreateManyUserInputEnvelope
    connect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
  }

  export type CommentReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentReplyCreateWithoutUserInput, CommentReplyUncheckedCreateWithoutUserInput> | CommentReplyCreateWithoutUserInput[] | CommentReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutUserInput | CommentReplyCreateOrConnectWithoutUserInput[]
    createMany?: CommentReplyCreateManyUserInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput = {
    create?: XOR<inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput> | inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput[] | inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput[]
    connectOrCreate?: inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput | inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput[]
    createMany?: inboxesCreateManyUsers_inboxes_receiverIDTousersInputEnvelope
    connect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
  }

  export type inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput = {
    create?: XOR<inboxesCreateWithoutUsers_inboxes_senderIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput> | inboxesCreateWithoutUsers_inboxes_senderIDTousersInput[] | inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput[]
    connectOrCreate?: inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput | inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput[]
    createMany?: inboxesCreateManyUsers_inboxes_senderIDTousersInputEnvelope
    connect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
  }

  export type LikeNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeNotificationCreateWithoutUserInput, LikeNotificationUncheckedCreateWithoutUserInput> | LikeNotificationCreateWithoutUserInput[] | LikeNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeNotificationCreateOrConnectWithoutUserInput | LikeNotificationCreateOrConnectWithoutUserInput[]
    createMany?: LikeNotificationCreateManyUserInputEnvelope
    connect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
  }

  export type MembershipCreateNestedOneWithoutUserInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput
    connect?: MembershipWhereUniqueInput
  }

  export type MessageNotificationCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageNotificationCreateWithoutReceiverInput, MessageNotificationUncheckedCreateWithoutReceiverInput> | MessageNotificationCreateWithoutReceiverInput[] | MessageNotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageNotificationCreateOrConnectWithoutReceiverInput | MessageNotificationCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageNotificationCreateManyReceiverInputEnvelope
    connect?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
  }

  export type ReadHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ReadHistoryCreateWithoutUserInput, ReadHistoryUncheckedCreateWithoutUserInput> | ReadHistoryCreateWithoutUserInput[] | ReadHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadHistoryCreateOrConnectWithoutUserInput | ReadHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ReadHistoryCreateManyUserInputEnvelope
    connect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
  }

  export type ReportUserCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportUserCreateWithoutReportedUserInput, ReportUserUncheckedCreateWithoutReportedUserInput> | ReportUserCreateWithoutReportedUserInput[] | ReportUserUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutReportedUserInput | ReportUserCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportUserCreateManyReportedUserInputEnvelope
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
  }

  export type ReportUserCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportUserCreateWithoutUserInput, ReportUserUncheckedCreateWithoutUserInput> | ReportUserCreateWithoutUserInput[] | ReportUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutUserInput | ReportUserCreateOrConnectWithoutUserInput[]
    createMany?: ReportUserCreateManyUserInputEnvelope
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
  }

  export type SavedBlogCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedBlogCreateWithoutUserInput, SavedBlogUncheckedCreateWithoutUserInput> | SavedBlogCreateWithoutUserInput[] | SavedBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedBlogCreateOrConnectWithoutUserInput | SavedBlogCreateOrConnectWithoutUserInput[]
    createMany?: SavedBlogCreateManyUserInputEnvelope
    connect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
  }

  export type BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedUserInput, BlockedUserUncheckedCreateWithoutBlockedUserInput> | BlockedUserCreateWithoutBlockedUserInput[] | BlockedUserUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedUserInput | BlockedUserCreateOrConnectWithoutBlockedUserInput[]
    createMany?: BlockedUserCreateManyBlockedUserInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlockedUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlockedUserCreateWithoutUserInput, BlockedUserUncheckedCreateWithoutUserInput> | BlockedUserCreateWithoutUserInput[] | BlockedUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutUserInput | BlockedUserCreateOrConnectWithoutUserInput[]
    createMany?: BlockedUserCreateManyUserInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlogDisLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogDisLikeCreateWithoutUserInput, BlogDisLikeUncheckedCreateWithoutUserInput> | BlogDisLikeCreateWithoutUserInput[] | BlogDisLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogDisLikeCreateOrConnectWithoutUserInput | BlogDisLikeCreateOrConnectWithoutUserInput[]
    createMany?: BlogDisLikeCreateManyUserInputEnvelope
    connect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
  }

  export type BlogLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogLikeCreateWithoutUserInput, BlogLikeUncheckedCreateWithoutUserInput> | BlogLikeCreateWithoutUserInput[] | BlogLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogLikeCreateOrConnectWithoutUserInput | BlogLikeCreateOrConnectWithoutUserInput[]
    createMany?: BlogLikeCreateManyUserInputEnvelope
    connect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
  }

  export type ReportBlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportBlogCreateWithoutUserInput, ReportBlogUncheckedCreateWithoutUserInput> | ReportBlogCreateWithoutUserInput[] | ReportBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportBlogCreateOrConnectWithoutUserInput | ReportBlogCreateOrConnectWithoutUserInput[]
    createMany?: ReportBlogCreateManyUserInputEnvelope
    connect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
  }

  export type BlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput> | BlogCreateWithoutUserInput[] | BlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutUserInput | BlogCreateOrConnectWithoutUserInput[]
    createMany?: BlogCreateManyUserInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type DisLikeCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DisLikeCommentCreateWithoutUserInput, DisLikeCommentUncheckedCreateWithoutUserInput> | DisLikeCommentCreateWithoutUserInput[] | DisLikeCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DisLikeCommentCreateOrConnectWithoutUserInput | DisLikeCommentCreateOrConnectWithoutUserInput[]
    createMany?: DisLikeCommentCreateManyUserInputEnvelope
    connect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
  }

  export type LikeCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCommentCreateWithoutUserInput, LikeCommentUncheckedCreateWithoutUserInput> | LikeCommentCreateWithoutUserInput[] | LikeCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCommentCreateOrConnectWithoutUserInput | LikeCommentCreateOrConnectWithoutUserInput[]
    createMany?: LikeCommentCreateManyUserInputEnvelope
    connect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
  }

  export type CommentNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentNotificationCreateWithoutUserInput, CommentNotificationUncheckedCreateWithoutUserInput> | CommentNotificationCreateWithoutUserInput[] | CommentNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentNotificationCreateOrConnectWithoutUserInput | CommentNotificationCreateOrConnectWithoutUserInput[]
    createMany?: CommentNotificationCreateManyUserInputEnvelope
    connect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
  }

  export type CommentReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentReplyCreateWithoutUserInput, CommentReplyUncheckedCreateWithoutUserInput> | CommentReplyCreateWithoutUserInput[] | CommentReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutUserInput | CommentReplyCreateOrConnectWithoutUserInput[]
    createMany?: CommentReplyCreateManyUserInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput = {
    create?: XOR<inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput> | inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput[] | inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput[]
    connectOrCreate?: inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput | inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput[]
    createMany?: inboxesCreateManyUsers_inboxes_receiverIDTousersInputEnvelope
    connect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
  }

  export type inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput = {
    create?: XOR<inboxesCreateWithoutUsers_inboxes_senderIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput> | inboxesCreateWithoutUsers_inboxes_senderIDTousersInput[] | inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput[]
    connectOrCreate?: inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput | inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput[]
    createMany?: inboxesCreateManyUsers_inboxes_senderIDTousersInputEnvelope
    connect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
  }

  export type LikeNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeNotificationCreateWithoutUserInput, LikeNotificationUncheckedCreateWithoutUserInput> | LikeNotificationCreateWithoutUserInput[] | LikeNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeNotificationCreateOrConnectWithoutUserInput | LikeNotificationCreateOrConnectWithoutUserInput[]
    createMany?: LikeNotificationCreateManyUserInputEnvelope
    connect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
  }

  export type MembershipUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput
    connect?: MembershipWhereUniqueInput
  }

  export type MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageNotificationCreateWithoutReceiverInput, MessageNotificationUncheckedCreateWithoutReceiverInput> | MessageNotificationCreateWithoutReceiverInput[] | MessageNotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageNotificationCreateOrConnectWithoutReceiverInput | MessageNotificationCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageNotificationCreateManyReceiverInputEnvelope
    connect?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
  }

  export type ReadHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReadHistoryCreateWithoutUserInput, ReadHistoryUncheckedCreateWithoutUserInput> | ReadHistoryCreateWithoutUserInput[] | ReadHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadHistoryCreateOrConnectWithoutUserInput | ReadHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ReadHistoryCreateManyUserInputEnvelope
    connect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
  }

  export type ReportUserUncheckedCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportUserCreateWithoutReportedUserInput, ReportUserUncheckedCreateWithoutReportedUserInput> | ReportUserCreateWithoutReportedUserInput[] | ReportUserUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutReportedUserInput | ReportUserCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportUserCreateManyReportedUserInputEnvelope
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
  }

  export type ReportUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportUserCreateWithoutUserInput, ReportUserUncheckedCreateWithoutUserInput> | ReportUserCreateWithoutUserInput[] | ReportUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutUserInput | ReportUserCreateOrConnectWithoutUserInput[]
    createMany?: ReportUserCreateManyUserInputEnvelope
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
  }

  export type SavedBlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedBlogCreateWithoutUserInput, SavedBlogUncheckedCreateWithoutUserInput> | SavedBlogCreateWithoutUserInput[] | SavedBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedBlogCreateOrConnectWithoutUserInput | SavedBlogCreateOrConnectWithoutUserInput[]
    createMany?: SavedBlogCreateManyUserInputEnvelope
    connect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BlockedUserUpdateManyWithoutBlockedUserNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedUserInput, BlockedUserUncheckedCreateWithoutBlockedUserInput> | BlockedUserCreateWithoutBlockedUserInput[] | BlockedUserUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedUserInput | BlockedUserCreateOrConnectWithoutBlockedUserInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockedUserInput | BlockedUserUpsertWithWhereUniqueWithoutBlockedUserInput[]
    createMany?: BlockedUserCreateManyBlockedUserInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockedUserInput | BlockedUserUpdateWithWhereUniqueWithoutBlockedUserInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockedUserInput | BlockedUserUpdateManyWithWhereWithoutBlockedUserInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlockedUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlockedUserCreateWithoutUserInput, BlockedUserUncheckedCreateWithoutUserInput> | BlockedUserCreateWithoutUserInput[] | BlockedUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutUserInput | BlockedUserCreateOrConnectWithoutUserInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutUserInput | BlockedUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlockedUserCreateManyUserInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutUserInput | BlockedUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutUserInput | BlockedUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlogDisLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogDisLikeCreateWithoutUserInput, BlogDisLikeUncheckedCreateWithoutUserInput> | BlogDisLikeCreateWithoutUserInput[] | BlogDisLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogDisLikeCreateOrConnectWithoutUserInput | BlogDisLikeCreateOrConnectWithoutUserInput[]
    upsert?: BlogDisLikeUpsertWithWhereUniqueWithoutUserInput | BlogDisLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogDisLikeCreateManyUserInputEnvelope
    set?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    disconnect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    delete?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    connect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    update?: BlogDisLikeUpdateWithWhereUniqueWithoutUserInput | BlogDisLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogDisLikeUpdateManyWithWhereWithoutUserInput | BlogDisLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogDisLikeScalarWhereInput | BlogDisLikeScalarWhereInput[]
  }

  export type BlogLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogLikeCreateWithoutUserInput, BlogLikeUncheckedCreateWithoutUserInput> | BlogLikeCreateWithoutUserInput[] | BlogLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogLikeCreateOrConnectWithoutUserInput | BlogLikeCreateOrConnectWithoutUserInput[]
    upsert?: BlogLikeUpsertWithWhereUniqueWithoutUserInput | BlogLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogLikeCreateManyUserInputEnvelope
    set?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    disconnect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    delete?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    connect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    update?: BlogLikeUpdateWithWhereUniqueWithoutUserInput | BlogLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogLikeUpdateManyWithWhereWithoutUserInput | BlogLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogLikeScalarWhereInput | BlogLikeScalarWhereInput[]
  }

  export type ReportBlogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportBlogCreateWithoutUserInput, ReportBlogUncheckedCreateWithoutUserInput> | ReportBlogCreateWithoutUserInput[] | ReportBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportBlogCreateOrConnectWithoutUserInput | ReportBlogCreateOrConnectWithoutUserInput[]
    upsert?: ReportBlogUpsertWithWhereUniqueWithoutUserInput | ReportBlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportBlogCreateManyUserInputEnvelope
    set?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    disconnect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    delete?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    connect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    update?: ReportBlogUpdateWithWhereUniqueWithoutUserInput | ReportBlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportBlogUpdateManyWithWhereWithoutUserInput | ReportBlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportBlogScalarWhereInput | ReportBlogScalarWhereInput[]
  }

  export type BlogUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput> | BlogCreateWithoutUserInput[] | BlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutUserInput | BlogCreateOrConnectWithoutUserInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutUserInput | BlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCreateManyUserInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutUserInput | BlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutUserInput | BlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type DisLikeCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DisLikeCommentCreateWithoutUserInput, DisLikeCommentUncheckedCreateWithoutUserInput> | DisLikeCommentCreateWithoutUserInput[] | DisLikeCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DisLikeCommentCreateOrConnectWithoutUserInput | DisLikeCommentCreateOrConnectWithoutUserInput[]
    upsert?: DisLikeCommentUpsertWithWhereUniqueWithoutUserInput | DisLikeCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DisLikeCommentCreateManyUserInputEnvelope
    set?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    disconnect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    delete?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    connect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    update?: DisLikeCommentUpdateWithWhereUniqueWithoutUserInput | DisLikeCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DisLikeCommentUpdateManyWithWhereWithoutUserInput | DisLikeCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DisLikeCommentScalarWhereInput | DisLikeCommentScalarWhereInput[]
  }

  export type LikeCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCommentCreateWithoutUserInput, LikeCommentUncheckedCreateWithoutUserInput> | LikeCommentCreateWithoutUserInput[] | LikeCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCommentCreateOrConnectWithoutUserInput | LikeCommentCreateOrConnectWithoutUserInput[]
    upsert?: LikeCommentUpsertWithWhereUniqueWithoutUserInput | LikeCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCommentCreateManyUserInputEnvelope
    set?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    disconnect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    delete?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    connect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    update?: LikeCommentUpdateWithWhereUniqueWithoutUserInput | LikeCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeCommentUpdateManyWithWhereWithoutUserInput | LikeCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeCommentScalarWhereInput | LikeCommentScalarWhereInput[]
  }

  export type CommentNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentNotificationCreateWithoutUserInput, CommentNotificationUncheckedCreateWithoutUserInput> | CommentNotificationCreateWithoutUserInput[] | CommentNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentNotificationCreateOrConnectWithoutUserInput | CommentNotificationCreateOrConnectWithoutUserInput[]
    upsert?: CommentNotificationUpsertWithWhereUniqueWithoutUserInput | CommentNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentNotificationCreateManyUserInputEnvelope
    set?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    disconnect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    delete?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    connect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    update?: CommentNotificationUpdateWithWhereUniqueWithoutUserInput | CommentNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentNotificationUpdateManyWithWhereWithoutUserInput | CommentNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentNotificationScalarWhereInput | CommentNotificationScalarWhereInput[]
  }

  export type CommentReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentReplyCreateWithoutUserInput, CommentReplyUncheckedCreateWithoutUserInput> | CommentReplyCreateWithoutUserInput[] | CommentReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutUserInput | CommentReplyCreateOrConnectWithoutUserInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutUserInput | CommentReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentReplyCreateManyUserInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutUserInput | CommentReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutUserInput | CommentReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput = {
    create?: XOR<inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput> | inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput[] | inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput[]
    connectOrCreate?: inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput | inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput[]
    upsert?: inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput | inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput[]
    createMany?: inboxesCreateManyUsers_inboxes_receiverIDTousersInputEnvelope
    set?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    disconnect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    delete?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    connect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    update?: inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput | inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput[]
    updateMany?: inboxesUpdateManyWithWhereWithoutUsers_inboxes_receiverIDTousersInput | inboxesUpdateManyWithWhereWithoutUsers_inboxes_receiverIDTousersInput[]
    deleteMany?: inboxesScalarWhereInput | inboxesScalarWhereInput[]
  }

  export type inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput = {
    create?: XOR<inboxesCreateWithoutUsers_inboxes_senderIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput> | inboxesCreateWithoutUsers_inboxes_senderIDTousersInput[] | inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput[]
    connectOrCreate?: inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput | inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput[]
    upsert?: inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput | inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput[]
    createMany?: inboxesCreateManyUsers_inboxes_senderIDTousersInputEnvelope
    set?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    disconnect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    delete?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    connect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    update?: inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput | inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput[]
    updateMany?: inboxesUpdateManyWithWhereWithoutUsers_inboxes_senderIDTousersInput | inboxesUpdateManyWithWhereWithoutUsers_inboxes_senderIDTousersInput[]
    deleteMany?: inboxesScalarWhereInput | inboxesScalarWhereInput[]
  }

  export type LikeNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeNotificationCreateWithoutUserInput, LikeNotificationUncheckedCreateWithoutUserInput> | LikeNotificationCreateWithoutUserInput[] | LikeNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeNotificationCreateOrConnectWithoutUserInput | LikeNotificationCreateOrConnectWithoutUserInput[]
    upsert?: LikeNotificationUpsertWithWhereUniqueWithoutUserInput | LikeNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeNotificationCreateManyUserInputEnvelope
    set?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    disconnect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    delete?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    connect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    update?: LikeNotificationUpdateWithWhereUniqueWithoutUserInput | LikeNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeNotificationUpdateManyWithWhereWithoutUserInput | LikeNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeNotificationScalarWhereInput | LikeNotificationScalarWhereInput[]
  }

  export type MembershipUpdateOneWithoutUserNestedInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput
    upsert?: MembershipUpsertWithoutUserInput
    disconnect?: MembershipWhereInput | boolean
    delete?: MembershipWhereInput | boolean
    connect?: MembershipWhereUniqueInput
    update?: XOR<XOR<MembershipUpdateToOneWithWhereWithoutUserInput, MembershipUpdateWithoutUserInput>, MembershipUncheckedUpdateWithoutUserInput>
  }

  export type MessageNotificationUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageNotificationCreateWithoutReceiverInput, MessageNotificationUncheckedCreateWithoutReceiverInput> | MessageNotificationCreateWithoutReceiverInput[] | MessageNotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageNotificationCreateOrConnectWithoutReceiverInput | MessageNotificationCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageNotificationUpsertWithWhereUniqueWithoutReceiverInput | MessageNotificationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageNotificationCreateManyReceiverInputEnvelope
    set?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
    disconnect?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
    delete?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
    connect?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
    update?: MessageNotificationUpdateWithWhereUniqueWithoutReceiverInput | MessageNotificationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageNotificationUpdateManyWithWhereWithoutReceiverInput | MessageNotificationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageNotificationScalarWhereInput | MessageNotificationScalarWhereInput[]
  }

  export type ReadHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReadHistoryCreateWithoutUserInput, ReadHistoryUncheckedCreateWithoutUserInput> | ReadHistoryCreateWithoutUserInput[] | ReadHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadHistoryCreateOrConnectWithoutUserInput | ReadHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ReadHistoryUpsertWithWhereUniqueWithoutUserInput | ReadHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReadHistoryCreateManyUserInputEnvelope
    set?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    disconnect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    delete?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    connect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    update?: ReadHistoryUpdateWithWhereUniqueWithoutUserInput | ReadHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReadHistoryUpdateManyWithWhereWithoutUserInput | ReadHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReadHistoryScalarWhereInput | ReadHistoryScalarWhereInput[]
  }

  export type ReportUserUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportUserCreateWithoutReportedUserInput, ReportUserUncheckedCreateWithoutReportedUserInput> | ReportUserCreateWithoutReportedUserInput[] | ReportUserUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutReportedUserInput | ReportUserCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUserUpsertWithWhereUniqueWithoutReportedUserInput | ReportUserUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportUserCreateManyReportedUserInputEnvelope
    set?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    disconnect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    delete?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    update?: ReportUserUpdateWithWhereUniqueWithoutReportedUserInput | ReportUserUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUserUpdateManyWithWhereWithoutReportedUserInput | ReportUserUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
  }

  export type ReportUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportUserCreateWithoutUserInput, ReportUserUncheckedCreateWithoutUserInput> | ReportUserCreateWithoutUserInput[] | ReportUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutUserInput | ReportUserCreateOrConnectWithoutUserInput[]
    upsert?: ReportUserUpsertWithWhereUniqueWithoutUserInput | ReportUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportUserCreateManyUserInputEnvelope
    set?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    disconnect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    delete?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    update?: ReportUserUpdateWithWhereUniqueWithoutUserInput | ReportUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUserUpdateManyWithWhereWithoutUserInput | ReportUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
  }

  export type SavedBlogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedBlogCreateWithoutUserInput, SavedBlogUncheckedCreateWithoutUserInput> | SavedBlogCreateWithoutUserInput[] | SavedBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedBlogCreateOrConnectWithoutUserInput | SavedBlogCreateOrConnectWithoutUserInput[]
    upsert?: SavedBlogUpsertWithWhereUniqueWithoutUserInput | SavedBlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedBlogCreateManyUserInputEnvelope
    set?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    disconnect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    delete?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    connect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    update?: SavedBlogUpdateWithWhereUniqueWithoutUserInput | SavedBlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedBlogUpdateManyWithWhereWithoutUserInput | SavedBlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedBlogScalarWhereInput | SavedBlogScalarWhereInput[]
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedUserInput, BlockedUserUncheckedCreateWithoutBlockedUserInput> | BlockedUserCreateWithoutBlockedUserInput[] | BlockedUserUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedUserInput | BlockedUserCreateOrConnectWithoutBlockedUserInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockedUserInput | BlockedUserUpsertWithWhereUniqueWithoutBlockedUserInput[]
    createMany?: BlockedUserCreateManyBlockedUserInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockedUserInput | BlockedUserUpdateWithWhereUniqueWithoutBlockedUserInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockedUserInput | BlockedUserUpdateManyWithWhereWithoutBlockedUserInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlockedUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlockedUserCreateWithoutUserInput, BlockedUserUncheckedCreateWithoutUserInput> | BlockedUserCreateWithoutUserInput[] | BlockedUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutUserInput | BlockedUserCreateOrConnectWithoutUserInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutUserInput | BlockedUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlockedUserCreateManyUserInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutUserInput | BlockedUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutUserInput | BlockedUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogDisLikeCreateWithoutUserInput, BlogDisLikeUncheckedCreateWithoutUserInput> | BlogDisLikeCreateWithoutUserInput[] | BlogDisLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogDisLikeCreateOrConnectWithoutUserInput | BlogDisLikeCreateOrConnectWithoutUserInput[]
    upsert?: BlogDisLikeUpsertWithWhereUniqueWithoutUserInput | BlogDisLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogDisLikeCreateManyUserInputEnvelope
    set?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    disconnect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    delete?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    connect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    update?: BlogDisLikeUpdateWithWhereUniqueWithoutUserInput | BlogDisLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogDisLikeUpdateManyWithWhereWithoutUserInput | BlogDisLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogDisLikeScalarWhereInput | BlogDisLikeScalarWhereInput[]
  }

  export type BlogLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogLikeCreateWithoutUserInput, BlogLikeUncheckedCreateWithoutUserInput> | BlogLikeCreateWithoutUserInput[] | BlogLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogLikeCreateOrConnectWithoutUserInput | BlogLikeCreateOrConnectWithoutUserInput[]
    upsert?: BlogLikeUpsertWithWhereUniqueWithoutUserInput | BlogLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogLikeCreateManyUserInputEnvelope
    set?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    disconnect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    delete?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    connect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    update?: BlogLikeUpdateWithWhereUniqueWithoutUserInput | BlogLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogLikeUpdateManyWithWhereWithoutUserInput | BlogLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogLikeScalarWhereInput | BlogLikeScalarWhereInput[]
  }

  export type ReportBlogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportBlogCreateWithoutUserInput, ReportBlogUncheckedCreateWithoutUserInput> | ReportBlogCreateWithoutUserInput[] | ReportBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportBlogCreateOrConnectWithoutUserInput | ReportBlogCreateOrConnectWithoutUserInput[]
    upsert?: ReportBlogUpsertWithWhereUniqueWithoutUserInput | ReportBlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportBlogCreateManyUserInputEnvelope
    set?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    disconnect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    delete?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    connect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    update?: ReportBlogUpdateWithWhereUniqueWithoutUserInput | ReportBlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportBlogUpdateManyWithWhereWithoutUserInput | ReportBlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportBlogScalarWhereInput | ReportBlogScalarWhereInput[]
  }

  export type BlogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput> | BlogCreateWithoutUserInput[] | BlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutUserInput | BlogCreateOrConnectWithoutUserInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutUserInput | BlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCreateManyUserInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutUserInput | BlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutUserInput | BlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DisLikeCommentCreateWithoutUserInput, DisLikeCommentUncheckedCreateWithoutUserInput> | DisLikeCommentCreateWithoutUserInput[] | DisLikeCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DisLikeCommentCreateOrConnectWithoutUserInput | DisLikeCommentCreateOrConnectWithoutUserInput[]
    upsert?: DisLikeCommentUpsertWithWhereUniqueWithoutUserInput | DisLikeCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DisLikeCommentCreateManyUserInputEnvelope
    set?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    disconnect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    delete?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    connect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    update?: DisLikeCommentUpdateWithWhereUniqueWithoutUserInput | DisLikeCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DisLikeCommentUpdateManyWithWhereWithoutUserInput | DisLikeCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DisLikeCommentScalarWhereInput | DisLikeCommentScalarWhereInput[]
  }

  export type LikeCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCommentCreateWithoutUserInput, LikeCommentUncheckedCreateWithoutUserInput> | LikeCommentCreateWithoutUserInput[] | LikeCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCommentCreateOrConnectWithoutUserInput | LikeCommentCreateOrConnectWithoutUserInput[]
    upsert?: LikeCommentUpsertWithWhereUniqueWithoutUserInput | LikeCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCommentCreateManyUserInputEnvelope
    set?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    disconnect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    delete?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    connect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    update?: LikeCommentUpdateWithWhereUniqueWithoutUserInput | LikeCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeCommentUpdateManyWithWhereWithoutUserInput | LikeCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeCommentScalarWhereInput | LikeCommentScalarWhereInput[]
  }

  export type CommentNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentNotificationCreateWithoutUserInput, CommentNotificationUncheckedCreateWithoutUserInput> | CommentNotificationCreateWithoutUserInput[] | CommentNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentNotificationCreateOrConnectWithoutUserInput | CommentNotificationCreateOrConnectWithoutUserInput[]
    upsert?: CommentNotificationUpsertWithWhereUniqueWithoutUserInput | CommentNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentNotificationCreateManyUserInputEnvelope
    set?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    disconnect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    delete?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    connect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    update?: CommentNotificationUpdateWithWhereUniqueWithoutUserInput | CommentNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentNotificationUpdateManyWithWhereWithoutUserInput | CommentNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentNotificationScalarWhereInput | CommentNotificationScalarWhereInput[]
  }

  export type CommentReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentReplyCreateWithoutUserInput, CommentReplyUncheckedCreateWithoutUserInput> | CommentReplyCreateWithoutUserInput[] | CommentReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutUserInput | CommentReplyCreateOrConnectWithoutUserInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutUserInput | CommentReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentReplyCreateManyUserInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutUserInput | CommentReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutUserInput | CommentReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput = {
    create?: XOR<inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput> | inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput[] | inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput[]
    connectOrCreate?: inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput | inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput[]
    upsert?: inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput | inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput[]
    createMany?: inboxesCreateManyUsers_inboxes_receiverIDTousersInputEnvelope
    set?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    disconnect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    delete?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    connect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    update?: inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput | inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput[]
    updateMany?: inboxesUpdateManyWithWhereWithoutUsers_inboxes_receiverIDTousersInput | inboxesUpdateManyWithWhereWithoutUsers_inboxes_receiverIDTousersInput[]
    deleteMany?: inboxesScalarWhereInput | inboxesScalarWhereInput[]
  }

  export type inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput = {
    create?: XOR<inboxesCreateWithoutUsers_inboxes_senderIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput> | inboxesCreateWithoutUsers_inboxes_senderIDTousersInput[] | inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput[]
    connectOrCreate?: inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput | inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput[]
    upsert?: inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput | inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput[]
    createMany?: inboxesCreateManyUsers_inboxes_senderIDTousersInputEnvelope
    set?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    disconnect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    delete?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    connect?: inboxesWhereUniqueInput | inboxesWhereUniqueInput[]
    update?: inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput | inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput[]
    updateMany?: inboxesUpdateManyWithWhereWithoutUsers_inboxes_senderIDTousersInput | inboxesUpdateManyWithWhereWithoutUsers_inboxes_senderIDTousersInput[]
    deleteMany?: inboxesScalarWhereInput | inboxesScalarWhereInput[]
  }

  export type LikeNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeNotificationCreateWithoutUserInput, LikeNotificationUncheckedCreateWithoutUserInput> | LikeNotificationCreateWithoutUserInput[] | LikeNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeNotificationCreateOrConnectWithoutUserInput | LikeNotificationCreateOrConnectWithoutUserInput[]
    upsert?: LikeNotificationUpsertWithWhereUniqueWithoutUserInput | LikeNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeNotificationCreateManyUserInputEnvelope
    set?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    disconnect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    delete?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    connect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    update?: LikeNotificationUpdateWithWhereUniqueWithoutUserInput | LikeNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeNotificationUpdateManyWithWhereWithoutUserInput | LikeNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeNotificationScalarWhereInput | LikeNotificationScalarWhereInput[]
  }

  export type MembershipUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput
    upsert?: MembershipUpsertWithoutUserInput
    disconnect?: MembershipWhereInput | boolean
    delete?: MembershipWhereInput | boolean
    connect?: MembershipWhereUniqueInput
    update?: XOR<XOR<MembershipUpdateToOneWithWhereWithoutUserInput, MembershipUpdateWithoutUserInput>, MembershipUncheckedUpdateWithoutUserInput>
  }

  export type MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageNotificationCreateWithoutReceiverInput, MessageNotificationUncheckedCreateWithoutReceiverInput> | MessageNotificationCreateWithoutReceiverInput[] | MessageNotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageNotificationCreateOrConnectWithoutReceiverInput | MessageNotificationCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageNotificationUpsertWithWhereUniqueWithoutReceiverInput | MessageNotificationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageNotificationCreateManyReceiverInputEnvelope
    set?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
    disconnect?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
    delete?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
    connect?: MessageNotificationWhereUniqueInput | MessageNotificationWhereUniqueInput[]
    update?: MessageNotificationUpdateWithWhereUniqueWithoutReceiverInput | MessageNotificationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageNotificationUpdateManyWithWhereWithoutReceiverInput | MessageNotificationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageNotificationScalarWhereInput | MessageNotificationScalarWhereInput[]
  }

  export type ReadHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReadHistoryCreateWithoutUserInput, ReadHistoryUncheckedCreateWithoutUserInput> | ReadHistoryCreateWithoutUserInput[] | ReadHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadHistoryCreateOrConnectWithoutUserInput | ReadHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ReadHistoryUpsertWithWhereUniqueWithoutUserInput | ReadHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReadHistoryCreateManyUserInputEnvelope
    set?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    disconnect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    delete?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    connect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    update?: ReadHistoryUpdateWithWhereUniqueWithoutUserInput | ReadHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReadHistoryUpdateManyWithWhereWithoutUserInput | ReadHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReadHistoryScalarWhereInput | ReadHistoryScalarWhereInput[]
  }

  export type ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportUserCreateWithoutReportedUserInput, ReportUserUncheckedCreateWithoutReportedUserInput> | ReportUserCreateWithoutReportedUserInput[] | ReportUserUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutReportedUserInput | ReportUserCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUserUpsertWithWhereUniqueWithoutReportedUserInput | ReportUserUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportUserCreateManyReportedUserInputEnvelope
    set?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    disconnect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    delete?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    update?: ReportUserUpdateWithWhereUniqueWithoutReportedUserInput | ReportUserUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUserUpdateManyWithWhereWithoutReportedUserInput | ReportUserUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
  }

  export type ReportUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportUserCreateWithoutUserInput, ReportUserUncheckedCreateWithoutUserInput> | ReportUserCreateWithoutUserInput[] | ReportUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutUserInput | ReportUserCreateOrConnectWithoutUserInput[]
    upsert?: ReportUserUpsertWithWhereUniqueWithoutUserInput | ReportUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportUserCreateManyUserInputEnvelope
    set?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    disconnect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    delete?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    update?: ReportUserUpdateWithWhereUniqueWithoutUserInput | ReportUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUserUpdateManyWithWhereWithoutUserInput | ReportUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
  }

  export type SavedBlogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedBlogCreateWithoutUserInput, SavedBlogUncheckedCreateWithoutUserInput> | SavedBlogCreateWithoutUserInput[] | SavedBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedBlogCreateOrConnectWithoutUserInput | SavedBlogCreateOrConnectWithoutUserInput[]
    upsert?: SavedBlogUpsertWithWhereUniqueWithoutUserInput | SavedBlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedBlogCreateManyUserInputEnvelope
    set?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    disconnect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    delete?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    connect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    update?: SavedBlogUpdateWithWhereUniqueWithoutUserInput | SavedBlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedBlogUpdateManyWithWhereWithoutUserInput | SavedBlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedBlogScalarWhereInput | SavedBlogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBlockedByUsersInput = {
    create?: XOR<UserCreateWithoutBlockedByUsersInput, UserUncheckedCreateWithoutBlockedByUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlockedUsersInput = {
    create?: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlockedByUsersNestedInput = {
    create?: XOR<UserCreateWithoutBlockedByUsersInput, UserUncheckedCreateWithoutBlockedByUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByUsersInput
    upsert?: UserUpsertWithoutBlockedByUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedByUsersInput, UserUpdateWithoutBlockedByUsersInput>, UserUncheckedUpdateWithoutBlockedByUsersInput>
  }

  export type UserUpdateOneRequiredWithoutBlockedUsersNestedInput = {
    create?: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedUsersInput
    upsert?: UserUpsertWithoutBlockedUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedUsersInput, UserUpdateWithoutBlockedUsersInput>, UserUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type UserCreateNestedOneWithoutReportedUsersInput = {
    create?: XOR<UserCreateWithoutReportedUsersInput, UserUncheckedCreateWithoutReportedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUsersReportedInput = {
    create?: XOR<UserCreateWithoutUsersReportedInput, UserUncheckedCreateWithoutUsersReportedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersReportedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReportedUsersNestedInput = {
    create?: XOR<UserCreateWithoutReportedUsersInput, UserUncheckedCreateWithoutReportedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedUsersInput
    upsert?: UserUpsertWithoutReportedUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedUsersInput, UserUpdateWithoutReportedUsersInput>, UserUncheckedUpdateWithoutReportedUsersInput>
  }

  export type UserUpdateOneRequiredWithoutUsersReportedNestedInput = {
    create?: XOR<UserCreateWithoutUsersReportedInput, UserUncheckedCreateWithoutUsersReportedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersReportedInput
    upsert?: UserUpsertWithoutUsersReportedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsersReportedInput, UserUpdateWithoutUsersReportedInput>, UserUncheckedUpdateWithoutUsersReportedInput>
  }

  export type BlogCreateNestedOneWithoutReadHistoriesInput = {
    create?: XOR<BlogCreateWithoutReadHistoriesInput, BlogUncheckedCreateWithoutReadHistoriesInput>
    connectOrCreate?: BlogCreateOrConnectWithoutReadHistoriesInput
    connect?: BlogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReadHistoriesInput = {
    create?: XOR<UserCreateWithoutReadHistoriesInput, UserUncheckedCreateWithoutReadHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadHistoriesInput
    connect?: UserWhereUniqueInput
  }

  export type BlogUpdateOneRequiredWithoutReadHistoriesNestedInput = {
    create?: XOR<BlogCreateWithoutReadHistoriesInput, BlogUncheckedCreateWithoutReadHistoriesInput>
    connectOrCreate?: BlogCreateOrConnectWithoutReadHistoriesInput
    upsert?: BlogUpsertWithoutReadHistoriesInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutReadHistoriesInput, BlogUpdateWithoutReadHistoriesInput>, BlogUncheckedUpdateWithoutReadHistoriesInput>
  }

  export type UserUpdateOneRequiredWithoutReadHistoriesNestedInput = {
    create?: XOR<UserCreateWithoutReadHistoriesInput, UserUncheckedCreateWithoutReadHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadHistoriesInput
    upsert?: UserUpsertWithoutReadHistoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReadHistoriesInput, UserUpdateWithoutReadHistoriesInput>, UserUncheckedUpdateWithoutReadHistoriesInput>
  }

  export type BlogDisLikeCreateNestedManyWithoutBlogInput = {
    create?: XOR<BlogDisLikeCreateWithoutBlogInput, BlogDisLikeUncheckedCreateWithoutBlogInput> | BlogDisLikeCreateWithoutBlogInput[] | BlogDisLikeUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: BlogDisLikeCreateOrConnectWithoutBlogInput | BlogDisLikeCreateOrConnectWithoutBlogInput[]
    createMany?: BlogDisLikeCreateManyBlogInputEnvelope
    connect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
  }

  export type BlogLikeCreateNestedManyWithoutBlogInput = {
    create?: XOR<BlogLikeCreateWithoutBlogInput, BlogLikeUncheckedCreateWithoutBlogInput> | BlogLikeCreateWithoutBlogInput[] | BlogLikeUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: BlogLikeCreateOrConnectWithoutBlogInput | BlogLikeCreateOrConnectWithoutBlogInput[]
    createMany?: BlogLikeCreateManyBlogInputEnvelope
    connect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
  }

  export type ReportBlogCreateNestedManyWithoutBlogInput = {
    create?: XOR<ReportBlogCreateWithoutBlogInput, ReportBlogUncheckedCreateWithoutBlogInput> | ReportBlogCreateWithoutBlogInput[] | ReportBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ReportBlogCreateOrConnectWithoutBlogInput | ReportBlogCreateOrConnectWithoutBlogInput[]
    createMany?: ReportBlogCreateManyBlogInputEnvelope
    connect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBlogsInput = {
    create?: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutBlogInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReadHistoryCreateNestedManyWithoutBlogInput = {
    create?: XOR<ReadHistoryCreateWithoutBlogInput, ReadHistoryUncheckedCreateWithoutBlogInput> | ReadHistoryCreateWithoutBlogInput[] | ReadHistoryUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ReadHistoryCreateOrConnectWithoutBlogInput | ReadHistoryCreateOrConnectWithoutBlogInput[]
    createMany?: ReadHistoryCreateManyBlogInputEnvelope
    connect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
  }

  export type SavedBlogCreateNestedManyWithoutBlogInput = {
    create?: XOR<SavedBlogCreateWithoutBlogInput, SavedBlogUncheckedCreateWithoutBlogInput> | SavedBlogCreateWithoutBlogInput[] | SavedBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: SavedBlogCreateOrConnectWithoutBlogInput | SavedBlogCreateOrConnectWithoutBlogInput[]
    createMany?: SavedBlogCreateManyBlogInputEnvelope
    connect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutBlogsInput = {
    create?: XOR<TopicCreateWithoutBlogsInput, TopicUncheckedCreateWithoutBlogsInput> | TopicCreateWithoutBlogsInput[] | TopicUncheckedCreateWithoutBlogsInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBlogsInput | TopicCreateOrConnectWithoutBlogsInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<BlogDisLikeCreateWithoutBlogInput, BlogDisLikeUncheckedCreateWithoutBlogInput> | BlogDisLikeCreateWithoutBlogInput[] | BlogDisLikeUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: BlogDisLikeCreateOrConnectWithoutBlogInput | BlogDisLikeCreateOrConnectWithoutBlogInput[]
    createMany?: BlogDisLikeCreateManyBlogInputEnvelope
    connect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
  }

  export type BlogLikeUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<BlogLikeCreateWithoutBlogInput, BlogLikeUncheckedCreateWithoutBlogInput> | BlogLikeCreateWithoutBlogInput[] | BlogLikeUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: BlogLikeCreateOrConnectWithoutBlogInput | BlogLikeCreateOrConnectWithoutBlogInput[]
    createMany?: BlogLikeCreateManyBlogInputEnvelope
    connect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
  }

  export type ReportBlogUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<ReportBlogCreateWithoutBlogInput, ReportBlogUncheckedCreateWithoutBlogInput> | ReportBlogCreateWithoutBlogInput[] | ReportBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ReportBlogCreateOrConnectWithoutBlogInput | ReportBlogCreateOrConnectWithoutBlogInput[]
    createMany?: ReportBlogCreateManyBlogInputEnvelope
    connect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReadHistoryUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<ReadHistoryCreateWithoutBlogInput, ReadHistoryUncheckedCreateWithoutBlogInput> | ReadHistoryCreateWithoutBlogInput[] | ReadHistoryUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ReadHistoryCreateOrConnectWithoutBlogInput | ReadHistoryCreateOrConnectWithoutBlogInput[]
    createMany?: ReadHistoryCreateManyBlogInputEnvelope
    connect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
  }

  export type SavedBlogUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<SavedBlogCreateWithoutBlogInput, SavedBlogUncheckedCreateWithoutBlogInput> | SavedBlogCreateWithoutBlogInput[] | SavedBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: SavedBlogCreateOrConnectWithoutBlogInput | SavedBlogCreateOrConnectWithoutBlogInput[]
    createMany?: SavedBlogCreateManyBlogInputEnvelope
    connect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutBlogsInput = {
    create?: XOR<TopicCreateWithoutBlogsInput, TopicUncheckedCreateWithoutBlogsInput> | TopicCreateWithoutBlogsInput[] | TopicUncheckedCreateWithoutBlogsInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBlogsInput | TopicCreateOrConnectWithoutBlogsInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BlogDisLikeUpdateManyWithoutBlogNestedInput = {
    create?: XOR<BlogDisLikeCreateWithoutBlogInput, BlogDisLikeUncheckedCreateWithoutBlogInput> | BlogDisLikeCreateWithoutBlogInput[] | BlogDisLikeUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: BlogDisLikeCreateOrConnectWithoutBlogInput | BlogDisLikeCreateOrConnectWithoutBlogInput[]
    upsert?: BlogDisLikeUpsertWithWhereUniqueWithoutBlogInput | BlogDisLikeUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: BlogDisLikeCreateManyBlogInputEnvelope
    set?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    disconnect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    delete?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    connect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    update?: BlogDisLikeUpdateWithWhereUniqueWithoutBlogInput | BlogDisLikeUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: BlogDisLikeUpdateManyWithWhereWithoutBlogInput | BlogDisLikeUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: BlogDisLikeScalarWhereInput | BlogDisLikeScalarWhereInput[]
  }

  export type BlogLikeUpdateManyWithoutBlogNestedInput = {
    create?: XOR<BlogLikeCreateWithoutBlogInput, BlogLikeUncheckedCreateWithoutBlogInput> | BlogLikeCreateWithoutBlogInput[] | BlogLikeUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: BlogLikeCreateOrConnectWithoutBlogInput | BlogLikeCreateOrConnectWithoutBlogInput[]
    upsert?: BlogLikeUpsertWithWhereUniqueWithoutBlogInput | BlogLikeUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: BlogLikeCreateManyBlogInputEnvelope
    set?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    disconnect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    delete?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    connect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    update?: BlogLikeUpdateWithWhereUniqueWithoutBlogInput | BlogLikeUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: BlogLikeUpdateManyWithWhereWithoutBlogInput | BlogLikeUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: BlogLikeScalarWhereInput | BlogLikeScalarWhereInput[]
  }

  export type ReportBlogUpdateManyWithoutBlogNestedInput = {
    create?: XOR<ReportBlogCreateWithoutBlogInput, ReportBlogUncheckedCreateWithoutBlogInput> | ReportBlogCreateWithoutBlogInput[] | ReportBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ReportBlogCreateOrConnectWithoutBlogInput | ReportBlogCreateOrConnectWithoutBlogInput[]
    upsert?: ReportBlogUpsertWithWhereUniqueWithoutBlogInput | ReportBlogUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: ReportBlogCreateManyBlogInputEnvelope
    set?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    disconnect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    delete?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    connect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    update?: ReportBlogUpdateWithWhereUniqueWithoutBlogInput | ReportBlogUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: ReportBlogUpdateManyWithWhereWithoutBlogInput | ReportBlogUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: ReportBlogScalarWhereInput | ReportBlogScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutBlogsNestedInput = {
    create?: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogsInput
    upsert?: UserUpsertWithoutBlogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogsInput, UserUpdateWithoutBlogsInput>, UserUncheckedUpdateWithoutBlogsInput>
  }

  export type CommentUpdateManyWithoutBlogNestedInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutBlogInput | CommentUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutBlogInput | CommentUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutBlogInput | CommentUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReadHistoryUpdateManyWithoutBlogNestedInput = {
    create?: XOR<ReadHistoryCreateWithoutBlogInput, ReadHistoryUncheckedCreateWithoutBlogInput> | ReadHistoryCreateWithoutBlogInput[] | ReadHistoryUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ReadHistoryCreateOrConnectWithoutBlogInput | ReadHistoryCreateOrConnectWithoutBlogInput[]
    upsert?: ReadHistoryUpsertWithWhereUniqueWithoutBlogInput | ReadHistoryUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: ReadHistoryCreateManyBlogInputEnvelope
    set?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    disconnect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    delete?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    connect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    update?: ReadHistoryUpdateWithWhereUniqueWithoutBlogInput | ReadHistoryUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: ReadHistoryUpdateManyWithWhereWithoutBlogInput | ReadHistoryUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: ReadHistoryScalarWhereInput | ReadHistoryScalarWhereInput[]
  }

  export type SavedBlogUpdateManyWithoutBlogNestedInput = {
    create?: XOR<SavedBlogCreateWithoutBlogInput, SavedBlogUncheckedCreateWithoutBlogInput> | SavedBlogCreateWithoutBlogInput[] | SavedBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: SavedBlogCreateOrConnectWithoutBlogInput | SavedBlogCreateOrConnectWithoutBlogInput[]
    upsert?: SavedBlogUpsertWithWhereUniqueWithoutBlogInput | SavedBlogUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: SavedBlogCreateManyBlogInputEnvelope
    set?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    disconnect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    delete?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    connect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    update?: SavedBlogUpdateWithWhereUniqueWithoutBlogInput | SavedBlogUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: SavedBlogUpdateManyWithWhereWithoutBlogInput | SavedBlogUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: SavedBlogScalarWhereInput | SavedBlogScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutBlogsNestedInput = {
    create?: XOR<TopicCreateWithoutBlogsInput, TopicUncheckedCreateWithoutBlogsInput> | TopicCreateWithoutBlogsInput[] | TopicUncheckedCreateWithoutBlogsInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBlogsInput | TopicCreateOrConnectWithoutBlogsInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutBlogsInput | TopicUpsertWithWhereUniqueWithoutBlogsInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutBlogsInput | TopicUpdateWithWhereUniqueWithoutBlogsInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutBlogsInput | TopicUpdateManyWithWhereWithoutBlogsInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<BlogDisLikeCreateWithoutBlogInput, BlogDisLikeUncheckedCreateWithoutBlogInput> | BlogDisLikeCreateWithoutBlogInput[] | BlogDisLikeUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: BlogDisLikeCreateOrConnectWithoutBlogInput | BlogDisLikeCreateOrConnectWithoutBlogInput[]
    upsert?: BlogDisLikeUpsertWithWhereUniqueWithoutBlogInput | BlogDisLikeUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: BlogDisLikeCreateManyBlogInputEnvelope
    set?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    disconnect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    delete?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    connect?: BlogDisLikeWhereUniqueInput | BlogDisLikeWhereUniqueInput[]
    update?: BlogDisLikeUpdateWithWhereUniqueWithoutBlogInput | BlogDisLikeUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: BlogDisLikeUpdateManyWithWhereWithoutBlogInput | BlogDisLikeUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: BlogDisLikeScalarWhereInput | BlogDisLikeScalarWhereInput[]
  }

  export type BlogLikeUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<BlogLikeCreateWithoutBlogInput, BlogLikeUncheckedCreateWithoutBlogInput> | BlogLikeCreateWithoutBlogInput[] | BlogLikeUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: BlogLikeCreateOrConnectWithoutBlogInput | BlogLikeCreateOrConnectWithoutBlogInput[]
    upsert?: BlogLikeUpsertWithWhereUniqueWithoutBlogInput | BlogLikeUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: BlogLikeCreateManyBlogInputEnvelope
    set?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    disconnect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    delete?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    connect?: BlogLikeWhereUniqueInput | BlogLikeWhereUniqueInput[]
    update?: BlogLikeUpdateWithWhereUniqueWithoutBlogInput | BlogLikeUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: BlogLikeUpdateManyWithWhereWithoutBlogInput | BlogLikeUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: BlogLikeScalarWhereInput | BlogLikeScalarWhereInput[]
  }

  export type ReportBlogUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<ReportBlogCreateWithoutBlogInput, ReportBlogUncheckedCreateWithoutBlogInput> | ReportBlogCreateWithoutBlogInput[] | ReportBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ReportBlogCreateOrConnectWithoutBlogInput | ReportBlogCreateOrConnectWithoutBlogInput[]
    upsert?: ReportBlogUpsertWithWhereUniqueWithoutBlogInput | ReportBlogUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: ReportBlogCreateManyBlogInputEnvelope
    set?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    disconnect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    delete?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    connect?: ReportBlogWhereUniqueInput | ReportBlogWhereUniqueInput[]
    update?: ReportBlogUpdateWithWhereUniqueWithoutBlogInput | ReportBlogUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: ReportBlogUpdateManyWithWhereWithoutBlogInput | ReportBlogUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: ReportBlogScalarWhereInput | ReportBlogScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutBlogInput | CommentUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutBlogInput | CommentUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutBlogInput | CommentUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<ReadHistoryCreateWithoutBlogInput, ReadHistoryUncheckedCreateWithoutBlogInput> | ReadHistoryCreateWithoutBlogInput[] | ReadHistoryUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ReadHistoryCreateOrConnectWithoutBlogInput | ReadHistoryCreateOrConnectWithoutBlogInput[]
    upsert?: ReadHistoryUpsertWithWhereUniqueWithoutBlogInput | ReadHistoryUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: ReadHistoryCreateManyBlogInputEnvelope
    set?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    disconnect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    delete?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    connect?: ReadHistoryWhereUniqueInput | ReadHistoryWhereUniqueInput[]
    update?: ReadHistoryUpdateWithWhereUniqueWithoutBlogInput | ReadHistoryUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: ReadHistoryUpdateManyWithWhereWithoutBlogInput | ReadHistoryUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: ReadHistoryScalarWhereInput | ReadHistoryScalarWhereInput[]
  }

  export type SavedBlogUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<SavedBlogCreateWithoutBlogInput, SavedBlogUncheckedCreateWithoutBlogInput> | SavedBlogCreateWithoutBlogInput[] | SavedBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: SavedBlogCreateOrConnectWithoutBlogInput | SavedBlogCreateOrConnectWithoutBlogInput[]
    upsert?: SavedBlogUpsertWithWhereUniqueWithoutBlogInput | SavedBlogUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: SavedBlogCreateManyBlogInputEnvelope
    set?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    disconnect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    delete?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    connect?: SavedBlogWhereUniqueInput | SavedBlogWhereUniqueInput[]
    update?: SavedBlogUpdateWithWhereUniqueWithoutBlogInput | SavedBlogUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: SavedBlogUpdateManyWithWhereWithoutBlogInput | SavedBlogUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: SavedBlogScalarWhereInput | SavedBlogScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutBlogsNestedInput = {
    create?: XOR<TopicCreateWithoutBlogsInput, TopicUncheckedCreateWithoutBlogsInput> | TopicCreateWithoutBlogsInput[] | TopicUncheckedCreateWithoutBlogsInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBlogsInput | TopicCreateOrConnectWithoutBlogsInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutBlogsInput | TopicUpsertWithWhereUniqueWithoutBlogsInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutBlogsInput | TopicUpdateWithWhereUniqueWithoutBlogsInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutBlogsInput | TopicUpdateManyWithWhereWithoutBlogsInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type BlogCreateNestedOneWithoutLikesInput = {
    create?: XOR<BlogCreateWithoutLikesInput, BlogUncheckedCreateWithoutLikesInput>
    connectOrCreate?: BlogCreateOrConnectWithoutLikesInput
    connect?: BlogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlogLikesInput = {
    create?: XOR<UserCreateWithoutBlogLikesInput, UserUncheckedCreateWithoutBlogLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogLikesInput
    connect?: UserWhereUniqueInput
  }

  export type LikeNotificationCreateNestedManyWithoutBlogInput = {
    create?: XOR<LikeNotificationCreateWithoutBlogInput, LikeNotificationUncheckedCreateWithoutBlogInput> | LikeNotificationCreateWithoutBlogInput[] | LikeNotificationUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LikeNotificationCreateOrConnectWithoutBlogInput | LikeNotificationCreateOrConnectWithoutBlogInput[]
    createMany?: LikeNotificationCreateManyBlogInputEnvelope
    connect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
  }

  export type LikeNotificationUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<LikeNotificationCreateWithoutBlogInput, LikeNotificationUncheckedCreateWithoutBlogInput> | LikeNotificationCreateWithoutBlogInput[] | LikeNotificationUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LikeNotificationCreateOrConnectWithoutBlogInput | LikeNotificationCreateOrConnectWithoutBlogInput[]
    createMany?: LikeNotificationCreateManyBlogInputEnvelope
    connect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
  }

  export type BlogUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<BlogCreateWithoutLikesInput, BlogUncheckedCreateWithoutLikesInput>
    connectOrCreate?: BlogCreateOrConnectWithoutLikesInput
    upsert?: BlogUpsertWithoutLikesInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutLikesInput, BlogUpdateWithoutLikesInput>, BlogUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutBlogLikesNestedInput = {
    create?: XOR<UserCreateWithoutBlogLikesInput, UserUncheckedCreateWithoutBlogLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogLikesInput
    upsert?: UserUpsertWithoutBlogLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogLikesInput, UserUpdateWithoutBlogLikesInput>, UserUncheckedUpdateWithoutBlogLikesInput>
  }

  export type LikeNotificationUpdateManyWithoutBlogNestedInput = {
    create?: XOR<LikeNotificationCreateWithoutBlogInput, LikeNotificationUncheckedCreateWithoutBlogInput> | LikeNotificationCreateWithoutBlogInput[] | LikeNotificationUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LikeNotificationCreateOrConnectWithoutBlogInput | LikeNotificationCreateOrConnectWithoutBlogInput[]
    upsert?: LikeNotificationUpsertWithWhereUniqueWithoutBlogInput | LikeNotificationUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: LikeNotificationCreateManyBlogInputEnvelope
    set?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    disconnect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    delete?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    connect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    update?: LikeNotificationUpdateWithWhereUniqueWithoutBlogInput | LikeNotificationUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: LikeNotificationUpdateManyWithWhereWithoutBlogInput | LikeNotificationUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: LikeNotificationScalarWhereInput | LikeNotificationScalarWhereInput[]
  }

  export type LikeNotificationUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<LikeNotificationCreateWithoutBlogInput, LikeNotificationUncheckedCreateWithoutBlogInput> | LikeNotificationCreateWithoutBlogInput[] | LikeNotificationUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LikeNotificationCreateOrConnectWithoutBlogInput | LikeNotificationCreateOrConnectWithoutBlogInput[]
    upsert?: LikeNotificationUpsertWithWhereUniqueWithoutBlogInput | LikeNotificationUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: LikeNotificationCreateManyBlogInputEnvelope
    set?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    disconnect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    delete?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    connect?: LikeNotificationWhereUniqueInput | LikeNotificationWhereUniqueInput[]
    update?: LikeNotificationUpdateWithWhereUniqueWithoutBlogInput | LikeNotificationUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: LikeNotificationUpdateManyWithWhereWithoutBlogInput | LikeNotificationUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: LikeNotificationScalarWhereInput | LikeNotificationScalarWhereInput[]
  }

  export type BlogCreateNestedOneWithoutDislikesInput = {
    create?: XOR<BlogCreateWithoutDislikesInput, BlogUncheckedCreateWithoutDislikesInput>
    connectOrCreate?: BlogCreateOrConnectWithoutDislikesInput
    connect?: BlogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlogDisLikesInput = {
    create?: XOR<UserCreateWithoutBlogDisLikesInput, UserUncheckedCreateWithoutBlogDisLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogDisLikesInput
    connect?: UserWhereUniqueInput
  }

  export type BlogUpdateOneRequiredWithoutDislikesNestedInput = {
    create?: XOR<BlogCreateWithoutDislikesInput, BlogUncheckedCreateWithoutDislikesInput>
    connectOrCreate?: BlogCreateOrConnectWithoutDislikesInput
    upsert?: BlogUpsertWithoutDislikesInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutDislikesInput, BlogUpdateWithoutDislikesInput>, BlogUncheckedUpdateWithoutDislikesInput>
  }

  export type UserUpdateOneRequiredWithoutBlogDisLikesNestedInput = {
    create?: XOR<UserCreateWithoutBlogDisLikesInput, UserUncheckedCreateWithoutBlogDisLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogDisLikesInput
    upsert?: UserUpsertWithoutBlogDisLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogDisLikesInput, UserUpdateWithoutBlogDisLikesInput>, UserUncheckedUpdateWithoutBlogDisLikesInput>
  }

  export type BlogCreateNestedManyWithoutTopicsInput = {
    create?: XOR<BlogCreateWithoutTopicsInput, BlogUncheckedCreateWithoutTopicsInput> | BlogCreateWithoutTopicsInput[] | BlogUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutTopicsInput | BlogCreateOrConnectWithoutTopicsInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type BlogUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<BlogCreateWithoutTopicsInput, BlogUncheckedCreateWithoutTopicsInput> | BlogCreateWithoutTopicsInput[] | BlogUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutTopicsInput | BlogCreateOrConnectWithoutTopicsInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type BlogUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<BlogCreateWithoutTopicsInput, BlogUncheckedCreateWithoutTopicsInput> | BlogCreateWithoutTopicsInput[] | BlogUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutTopicsInput | BlogCreateOrConnectWithoutTopicsInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutTopicsInput | BlogUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutTopicsInput | BlogUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutTopicsInput | BlogUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type BlogUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<BlogCreateWithoutTopicsInput, BlogUncheckedCreateWithoutTopicsInput> | BlogCreateWithoutTopicsInput[] | BlogUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutTopicsInput | BlogCreateOrConnectWithoutTopicsInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutTopicsInput | BlogUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutTopicsInput | BlogUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutTopicsInput | BlogUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFollowingsInput = {
    create?: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingsNestedInput = {
    create?: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingsInput
    upsert?: UserUpsertWithoutFollowingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingsInput, UserUpdateWithoutFollowingsInput>, UserUncheckedUpdateWithoutFollowingsInput>
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type DisLikeCommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<DisLikeCommentCreateWithoutCommentInput, DisLikeCommentUncheckedCreateWithoutCommentInput> | DisLikeCommentCreateWithoutCommentInput[] | DisLikeCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: DisLikeCommentCreateOrConnectWithoutCommentInput | DisLikeCommentCreateOrConnectWithoutCommentInput[]
    createMany?: DisLikeCommentCreateManyCommentInputEnvelope
    connect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
  }

  export type LikeCommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<LikeCommentCreateWithoutCommentInput, LikeCommentUncheckedCreateWithoutCommentInput> | LikeCommentCreateWithoutCommentInput[] | LikeCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LikeCommentCreateOrConnectWithoutCommentInput | LikeCommentCreateOrConnectWithoutCommentInput[]
    createMany?: LikeCommentCreateManyCommentInputEnvelope
    connect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
  }

  export type CommentNotificationCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentNotificationCreateWithoutCommentInput, CommentNotificationUncheckedCreateWithoutCommentInput> | CommentNotificationCreateWithoutCommentInput[] | CommentNotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentNotificationCreateOrConnectWithoutCommentInput | CommentNotificationCreateOrConnectWithoutCommentInput[]
    createMany?: CommentNotificationCreateManyCommentInputEnvelope
    connect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
  }

  export type CommentReplyCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type BlogCreateNestedOneWithoutCommentsInput = {
    create?: XOR<BlogCreateWithoutCommentsInput, BlogUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogCreateOrConnectWithoutCommentsInput
    connect?: BlogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type DisLikeCommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<DisLikeCommentCreateWithoutCommentInput, DisLikeCommentUncheckedCreateWithoutCommentInput> | DisLikeCommentCreateWithoutCommentInput[] | DisLikeCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: DisLikeCommentCreateOrConnectWithoutCommentInput | DisLikeCommentCreateOrConnectWithoutCommentInput[]
    createMany?: DisLikeCommentCreateManyCommentInputEnvelope
    connect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
  }

  export type LikeCommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<LikeCommentCreateWithoutCommentInput, LikeCommentUncheckedCreateWithoutCommentInput> | LikeCommentCreateWithoutCommentInput[] | LikeCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LikeCommentCreateOrConnectWithoutCommentInput | LikeCommentCreateOrConnectWithoutCommentInput[]
    createMany?: LikeCommentCreateManyCommentInputEnvelope
    connect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
  }

  export type CommentNotificationUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentNotificationCreateWithoutCommentInput, CommentNotificationUncheckedCreateWithoutCommentInput> | CommentNotificationCreateWithoutCommentInput[] | CommentNotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentNotificationCreateOrConnectWithoutCommentInput | CommentNotificationCreateOrConnectWithoutCommentInput[]
    createMany?: CommentNotificationCreateManyCommentInputEnvelope
    connect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
  }

  export type CommentReplyUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type DisLikeCommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<DisLikeCommentCreateWithoutCommentInput, DisLikeCommentUncheckedCreateWithoutCommentInput> | DisLikeCommentCreateWithoutCommentInput[] | DisLikeCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: DisLikeCommentCreateOrConnectWithoutCommentInput | DisLikeCommentCreateOrConnectWithoutCommentInput[]
    upsert?: DisLikeCommentUpsertWithWhereUniqueWithoutCommentInput | DisLikeCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: DisLikeCommentCreateManyCommentInputEnvelope
    set?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    disconnect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    delete?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    connect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    update?: DisLikeCommentUpdateWithWhereUniqueWithoutCommentInput | DisLikeCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: DisLikeCommentUpdateManyWithWhereWithoutCommentInput | DisLikeCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: DisLikeCommentScalarWhereInput | DisLikeCommentScalarWhereInput[]
  }

  export type LikeCommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<LikeCommentCreateWithoutCommentInput, LikeCommentUncheckedCreateWithoutCommentInput> | LikeCommentCreateWithoutCommentInput[] | LikeCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LikeCommentCreateOrConnectWithoutCommentInput | LikeCommentCreateOrConnectWithoutCommentInput[]
    upsert?: LikeCommentUpsertWithWhereUniqueWithoutCommentInput | LikeCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: LikeCommentCreateManyCommentInputEnvelope
    set?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    disconnect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    delete?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    connect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    update?: LikeCommentUpdateWithWhereUniqueWithoutCommentInput | LikeCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: LikeCommentUpdateManyWithWhereWithoutCommentInput | LikeCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: LikeCommentScalarWhereInput | LikeCommentScalarWhereInput[]
  }

  export type CommentNotificationUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentNotificationCreateWithoutCommentInput, CommentNotificationUncheckedCreateWithoutCommentInput> | CommentNotificationCreateWithoutCommentInput[] | CommentNotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentNotificationCreateOrConnectWithoutCommentInput | CommentNotificationCreateOrConnectWithoutCommentInput[]
    upsert?: CommentNotificationUpsertWithWhereUniqueWithoutCommentInput | CommentNotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentNotificationCreateManyCommentInputEnvelope
    set?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    disconnect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    delete?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    connect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    update?: CommentNotificationUpdateWithWhereUniqueWithoutCommentInput | CommentNotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentNotificationUpdateManyWithWhereWithoutCommentInput | CommentNotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentNotificationScalarWhereInput | CommentNotificationScalarWhereInput[]
  }

  export type CommentReplyUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutCommentInput | CommentReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutCommentInput | CommentReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutCommentInput | CommentReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type BlogUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<BlogCreateWithoutCommentsInput, BlogUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogCreateOrConnectWithoutCommentsInput
    upsert?: BlogUpsertWithoutCommentsInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutCommentsInput, BlogUpdateWithoutCommentsInput>, BlogUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type DisLikeCommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<DisLikeCommentCreateWithoutCommentInput, DisLikeCommentUncheckedCreateWithoutCommentInput> | DisLikeCommentCreateWithoutCommentInput[] | DisLikeCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: DisLikeCommentCreateOrConnectWithoutCommentInput | DisLikeCommentCreateOrConnectWithoutCommentInput[]
    upsert?: DisLikeCommentUpsertWithWhereUniqueWithoutCommentInput | DisLikeCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: DisLikeCommentCreateManyCommentInputEnvelope
    set?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    disconnect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    delete?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    connect?: DisLikeCommentWhereUniqueInput | DisLikeCommentWhereUniqueInput[]
    update?: DisLikeCommentUpdateWithWhereUniqueWithoutCommentInput | DisLikeCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: DisLikeCommentUpdateManyWithWhereWithoutCommentInput | DisLikeCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: DisLikeCommentScalarWhereInput | DisLikeCommentScalarWhereInput[]
  }

  export type LikeCommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<LikeCommentCreateWithoutCommentInput, LikeCommentUncheckedCreateWithoutCommentInput> | LikeCommentCreateWithoutCommentInput[] | LikeCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LikeCommentCreateOrConnectWithoutCommentInput | LikeCommentCreateOrConnectWithoutCommentInput[]
    upsert?: LikeCommentUpsertWithWhereUniqueWithoutCommentInput | LikeCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: LikeCommentCreateManyCommentInputEnvelope
    set?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    disconnect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    delete?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    connect?: LikeCommentWhereUniqueInput | LikeCommentWhereUniqueInput[]
    update?: LikeCommentUpdateWithWhereUniqueWithoutCommentInput | LikeCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: LikeCommentUpdateManyWithWhereWithoutCommentInput | LikeCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: LikeCommentScalarWhereInput | LikeCommentScalarWhereInput[]
  }

  export type CommentNotificationUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentNotificationCreateWithoutCommentInput, CommentNotificationUncheckedCreateWithoutCommentInput> | CommentNotificationCreateWithoutCommentInput[] | CommentNotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentNotificationCreateOrConnectWithoutCommentInput | CommentNotificationCreateOrConnectWithoutCommentInput[]
    upsert?: CommentNotificationUpsertWithWhereUniqueWithoutCommentInput | CommentNotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentNotificationCreateManyCommentInputEnvelope
    set?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    disconnect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    delete?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    connect?: CommentNotificationWhereUniqueInput | CommentNotificationWhereUniqueInput[]
    update?: CommentNotificationUpdateWithWhereUniqueWithoutCommentInput | CommentNotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentNotificationUpdateManyWithWhereWithoutCommentInput | CommentNotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentNotificationScalarWhereInput | CommentNotificationScalarWhereInput[]
  }

  export type CommentReplyUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutCommentInput | CommentReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutCommentInput | CommentReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutCommentInput | CommentReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type CommentCreateNestedOneWithoutLikeCommentsInput = {
    create?: XOR<CommentCreateWithoutLikeCommentsInput, CommentUncheckedCreateWithoutLikeCommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutLikeCommentsInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikeCommentsInput = {
    create?: XOR<UserCreateWithoutLikeCommentsInput, UserUncheckedCreateWithoutLikeCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikeCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutLikeCommentsNestedInput = {
    create?: XOR<CommentCreateWithoutLikeCommentsInput, CommentUncheckedCreateWithoutLikeCommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutLikeCommentsInput
    upsert?: CommentUpsertWithoutLikeCommentsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutLikeCommentsInput, CommentUpdateWithoutLikeCommentsInput>, CommentUncheckedUpdateWithoutLikeCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutLikeCommentsNestedInput = {
    create?: XOR<UserCreateWithoutLikeCommentsInput, UserUncheckedCreateWithoutLikeCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikeCommentsInput
    upsert?: UserUpsertWithoutLikeCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikeCommentsInput, UserUpdateWithoutLikeCommentsInput>, UserUncheckedUpdateWithoutLikeCommentsInput>
  }

  export type CommentCreateNestedOneWithoutDisLikeCommentsInput = {
    create?: XOR<CommentCreateWithoutDisLikeCommentsInput, CommentUncheckedCreateWithoutDisLikeCommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutDisLikeCommentsInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDisLikeCommentsInput = {
    create?: XOR<UserCreateWithoutDisLikeCommentsInput, UserUncheckedCreateWithoutDisLikeCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisLikeCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutDisLikeCommentsNestedInput = {
    create?: XOR<CommentCreateWithoutDisLikeCommentsInput, CommentUncheckedCreateWithoutDisLikeCommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutDisLikeCommentsInput
    upsert?: CommentUpsertWithoutDisLikeCommentsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutDisLikeCommentsInput, CommentUpdateWithoutDisLikeCommentsInput>, CommentUncheckedUpdateWithoutDisLikeCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutDisLikeCommentsNestedInput = {
    create?: XOR<UserCreateWithoutDisLikeCommentsInput, UserUncheckedCreateWithoutDisLikeCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisLikeCommentsInput
    upsert?: UserUpsertWithoutDisLikeCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisLikeCommentsInput, UserUpdateWithoutDisLikeCommentsInput>, UserUncheckedUpdateWithoutDisLikeCommentsInput>
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentRepliesInput = {
    create?: XOR<UserCreateWithoutCommentRepliesInput, UserUncheckedCreateWithoutCommentRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type UserUpdateOneRequiredWithoutCommentRepliesNestedInput = {
    create?: XOR<UserCreateWithoutCommentRepliesInput, UserUncheckedCreateWithoutCommentRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentRepliesInput
    upsert?: UserUpsertWithoutCommentRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentRepliesInput, UserUpdateWithoutCommentRepliesInput>, UserUncheckedUpdateWithoutCommentRepliesInput>
  }

  export type BlogCreateNestedOneWithoutSavedByInput = {
    create?: XOR<BlogCreateWithoutSavedByInput, BlogUncheckedCreateWithoutSavedByInput>
    connectOrCreate?: BlogCreateOrConnectWithoutSavedByInput
    connect?: BlogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSavedBlogsInput = {
    create?: XOR<UserCreateWithoutSavedBlogsInput, UserUncheckedCreateWithoutSavedBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedBlogsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogUpdateOneRequiredWithoutSavedByNestedInput = {
    create?: XOR<BlogCreateWithoutSavedByInput, BlogUncheckedCreateWithoutSavedByInput>
    connectOrCreate?: BlogCreateOrConnectWithoutSavedByInput
    upsert?: BlogUpsertWithoutSavedByInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutSavedByInput, BlogUpdateWithoutSavedByInput>, BlogUncheckedUpdateWithoutSavedByInput>
  }

  export type UserUpdateOneRequiredWithoutSavedBlogsNestedInput = {
    create?: XOR<UserCreateWithoutSavedBlogsInput, UserUncheckedCreateWithoutSavedBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedBlogsInput
    upsert?: UserUpsertWithoutSavedBlogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedBlogsInput, UserUpdateWithoutSavedBlogsInput>, UserUncheckedUpdateWithoutSavedBlogsInput>
  }

  export type UserCreateNestedOneWithoutMembershipInput = {
    create?: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMemberShipTypeFieldUpdateOperationsInput = {
    set?: $Enums.MemberShipType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutMembershipNestedInput = {
    create?: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipInput
    upsert?: UserUpsertWithoutMembershipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipInput, UserUpdateWithoutMembershipInput>, UserUncheckedUpdateWithoutMembershipInput>
  }

  export type BlogCreateNestedOneWithoutReportsInput = {
    create?: XOR<BlogCreateWithoutReportsInput, BlogUncheckedCreateWithoutReportsInput>
    connectOrCreate?: BlogCreateOrConnectWithoutReportsInput
    connect?: BlogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportedBlogsInput = {
    create?: XOR<UserCreateWithoutReportedBlogsInput, UserUncheckedCreateWithoutReportedBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedBlogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportMessageFieldUpdateOperationsInput = {
    set?: $Enums.ReportMessage
  }

  export type BlogUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<BlogCreateWithoutReportsInput, BlogUncheckedCreateWithoutReportsInput>
    connectOrCreate?: BlogCreateOrConnectWithoutReportsInput
    upsert?: BlogUpsertWithoutReportsInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutReportsInput, BlogUpdateWithoutReportsInput>, BlogUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneRequiredWithoutReportedBlogsNestedInput = {
    create?: XOR<UserCreateWithoutReportedBlogsInput, UserUncheckedCreateWithoutReportedBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedBlogsInput
    upsert?: UserUpsertWithoutReportedBlogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedBlogsInput, UserUpdateWithoutReportedBlogsInput>, UserUncheckedUpdateWithoutReportedBlogsInput>
  }

  export type CommentCreateNestedOneWithoutCommentNotificationsInput = {
    create?: XOR<CommentCreateWithoutCommentNotificationsInput, CommentUncheckedCreateWithoutCommentNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutCommentNotificationsInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentNotificationsInput = {
    create?: XOR<UserCreateWithoutCommentNotificationsInput, UserUncheckedCreateWithoutCommentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutCommentNotificationsNestedInput = {
    create?: XOR<CommentCreateWithoutCommentNotificationsInput, CommentUncheckedCreateWithoutCommentNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutCommentNotificationsInput
    upsert?: CommentUpsertWithoutCommentNotificationsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutCommentNotificationsInput, CommentUpdateWithoutCommentNotificationsInput>, CommentUncheckedUpdateWithoutCommentNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutCommentNotificationsInput, UserUncheckedCreateWithoutCommentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentNotificationsInput
    upsert?: UserUpsertWithoutCommentNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentNotificationsInput, UserUpdateWithoutCommentNotificationsInput>, UserUncheckedUpdateWithoutCommentNotificationsInput>
  }

  export type UserCreateNestedOneWithoutMessageNotificationsInput = {
    create?: XOR<UserCreateWithoutMessageNotificationsInput, UserUncheckedCreateWithoutMessageNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessageNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutMessageNotificationsInput, UserUncheckedCreateWithoutMessageNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageNotificationsInput
    upsert?: UserUpsertWithoutMessageNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageNotificationsInput, UserUpdateWithoutMessageNotificationsInput>, UserUncheckedUpdateWithoutMessageNotificationsInput>
  }

  export type BlogLikeCreateNestedOneWithoutLikeNotificationsInput = {
    create?: XOR<BlogLikeCreateWithoutLikeNotificationsInput, BlogLikeUncheckedCreateWithoutLikeNotificationsInput>
    connectOrCreate?: BlogLikeCreateOrConnectWithoutLikeNotificationsInput
    connect?: BlogLikeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikeNotificationsInput = {
    create?: XOR<UserCreateWithoutLikeNotificationsInput, UserUncheckedCreateWithoutLikeNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikeNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogLikeUpdateOneRequiredWithoutLikeNotificationsNestedInput = {
    create?: XOR<BlogLikeCreateWithoutLikeNotificationsInput, BlogLikeUncheckedCreateWithoutLikeNotificationsInput>
    connectOrCreate?: BlogLikeCreateOrConnectWithoutLikeNotificationsInput
    upsert?: BlogLikeUpsertWithoutLikeNotificationsInput
    connect?: BlogLikeWhereUniqueInput
    update?: XOR<XOR<BlogLikeUpdateToOneWithWhereWithoutLikeNotificationsInput, BlogLikeUpdateWithoutLikeNotificationsInput>, BlogLikeUncheckedUpdateWithoutLikeNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutLikeNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutLikeNotificationsInput, UserUncheckedCreateWithoutLikeNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikeNotificationsInput
    upsert?: UserUpsertWithoutLikeNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikeNotificationsInput, UserUpdateWithoutLikeNotificationsInput>, UserUncheckedUpdateWithoutLikeNotificationsInput>
  }

  export type UserCreateNestedOneWithoutInboxes_inboxes_receiverIDTousersInput = {
    create?: XOR<UserCreateWithoutInboxes_inboxes_receiverIDTousersInput, UserUncheckedCreateWithoutInboxes_inboxes_receiverIDTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInboxes_inboxes_receiverIDTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInboxes_inboxes_senderIDTousersInput = {
    create?: XOR<UserCreateWithoutInboxes_inboxes_senderIDTousersInput, UserUncheckedCreateWithoutInboxes_inboxes_senderIDTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInboxes_inboxes_senderIDTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInboxes_inboxes_receiverIDTousersNestedInput = {
    create?: XOR<UserCreateWithoutInboxes_inboxes_receiverIDTousersInput, UserUncheckedCreateWithoutInboxes_inboxes_receiverIDTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInboxes_inboxes_receiverIDTousersInput
    upsert?: UserUpsertWithoutInboxes_inboxes_receiverIDTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInboxes_inboxes_receiverIDTousersInput, UserUpdateWithoutInboxes_inboxes_receiverIDTousersInput>, UserUncheckedUpdateWithoutInboxes_inboxes_receiverIDTousersInput>
  }

  export type UserUpdateOneRequiredWithoutInboxes_inboxes_senderIDTousersNestedInput = {
    create?: XOR<UserCreateWithoutInboxes_inboxes_senderIDTousersInput, UserUncheckedCreateWithoutInboxes_inboxes_senderIDTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInboxes_inboxes_senderIDTousersInput
    upsert?: UserUpsertWithoutInboxes_inboxes_senderIDTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInboxes_inboxes_senderIDTousersInput, UserUpdateWithoutInboxes_inboxes_senderIDTousersInput>, UserUncheckedUpdateWithoutInboxes_inboxes_senderIDTousersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMemberShipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberShipType | EnumMemberShipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberShipTypeFilter<$PrismaModel> | $Enums.MemberShipType
  }

  export type NestedEnumMemberShipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberShipType | EnumMemberShipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberShipTypeWithAggregatesFilter<$PrismaModel> | $Enums.MemberShipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberShipTypeFilter<$PrismaModel>
    _max?: NestedEnumMemberShipTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumReportMessageFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportMessage | EnumReportMessageFieldRefInput<$PrismaModel>
    in?: $Enums.ReportMessage[] | ListEnumReportMessageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportMessage[] | ListEnumReportMessageFieldRefInput<$PrismaModel>
    not?: NestedEnumReportMessageFilter<$PrismaModel> | $Enums.ReportMessage
  }

  export type NestedEnumReportMessageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportMessage | EnumReportMessageFieldRefInput<$PrismaModel>
    in?: $Enums.ReportMessage[] | ListEnumReportMessageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportMessage[] | ListEnumReportMessageFieldRefInput<$PrismaModel>
    not?: NestedEnumReportMessageWithAggregatesFilter<$PrismaModel> | $Enums.ReportMessage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportMessageFilter<$PrismaModel>
    _max?: NestedEnumReportMessageFilter<$PrismaModel>
  }

  export type BlockedUserCreateWithoutBlockedUserInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBlockedUsersInput
  }

  export type BlockedUserUncheckedCreateWithoutBlockedUserInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type BlockedUserCreateOrConnectWithoutBlockedUserInput = {
    where: BlockedUserWhereUniqueInput
    create: XOR<BlockedUserCreateWithoutBlockedUserInput, BlockedUserUncheckedCreateWithoutBlockedUserInput>
  }

  export type BlockedUserCreateManyBlockedUserInputEnvelope = {
    data: BlockedUserCreateManyBlockedUserInput | BlockedUserCreateManyBlockedUserInput[]
    skipDuplicates?: boolean
  }

  export type BlockedUserCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    blockedUser: UserCreateNestedOneWithoutBlockedByUsersInput
  }

  export type BlockedUserUncheckedCreateWithoutUserInput = {
    id?: string
    blockedID: string
    createdAt?: Date | string
  }

  export type BlockedUserCreateOrConnectWithoutUserInput = {
    where: BlockedUserWhereUniqueInput
    create: XOR<BlockedUserCreateWithoutUserInput, BlockedUserUncheckedCreateWithoutUserInput>
  }

  export type BlockedUserCreateManyUserInputEnvelope = {
    data: BlockedUserCreateManyUserInput | BlockedUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogDisLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutDislikesInput
  }

  export type BlogDisLikeUncheckedCreateWithoutUserInput = {
    id?: string
    blogID: string
    createdAt?: Date | string
  }

  export type BlogDisLikeCreateOrConnectWithoutUserInput = {
    where: BlogDisLikeWhereUniqueInput
    create: XOR<BlogDisLikeCreateWithoutUserInput, BlogDisLikeUncheckedCreateWithoutUserInput>
  }

  export type BlogDisLikeCreateManyUserInputEnvelope = {
    data: BlogDisLikeCreateManyUserInput | BlogDisLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutLikesInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutBlogInput
  }

  export type BlogLikeUncheckedCreateWithoutUserInput = {
    id?: string
    blogID: string
    createdAt?: Date | string
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogLikeCreateOrConnectWithoutUserInput = {
    where: BlogLikeWhereUniqueInput
    create: XOR<BlogLikeCreateWithoutUserInput, BlogLikeUncheckedCreateWithoutUserInput>
  }

  export type BlogLikeCreateManyUserInputEnvelope = {
    data: BlogLikeCreateManyUserInput | BlogLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportBlogCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutReportsInput
  }

  export type ReportBlogUncheckedCreateWithoutUserInput = {
    id?: string
    blogID: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
  }

  export type ReportBlogCreateOrConnectWithoutUserInput = {
    where: ReportBlogWhereUniqueInput
    create: XOR<ReportBlogCreateWithoutUserInput, ReportBlogUncheckedCreateWithoutUserInput>
  }

  export type ReportBlogCreateManyUserInputEnvelope = {
    data: ReportBlogCreateManyUserInput | ReportBlogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeCreateNestedManyWithoutBlogInput
    likes?: BlogLikeCreateNestedManyWithoutBlogInput
    reports?: ReportBlogCreateNestedManyWithoutBlogInput
    comments?: CommentCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogCreateNestedManyWithoutBlogInput
    topics?: TopicCreateNestedManyWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput
    likes?: BlogLikeUncheckedCreateNestedManyWithoutBlogInput
    reports?: ReportBlogUncheckedCreateNestedManyWithoutBlogInput
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogUncheckedCreateNestedManyWithoutBlogInput
    topics?: TopicUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type BlogCreateOrConnectWithoutUserInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput>
  }

  export type BlogCreateManyUserInputEnvelope = {
    data: BlogCreateManyUserInput | BlogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DisLikeCommentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutDisLikeCommentsInput
  }

  export type DisLikeCommentUncheckedCreateWithoutUserInput = {
    id?: string
    commentID: string
    createdAt?: Date | string
  }

  export type DisLikeCommentCreateOrConnectWithoutUserInput = {
    where: DisLikeCommentWhereUniqueInput
    create: XOR<DisLikeCommentCreateWithoutUserInput, DisLikeCommentUncheckedCreateWithoutUserInput>
  }

  export type DisLikeCommentCreateManyUserInputEnvelope = {
    data: DisLikeCommentCreateManyUserInput | DisLikeCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeCommentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutLikeCommentsInput
  }

  export type LikeCommentUncheckedCreateWithoutUserInput = {
    id?: string
    commentID: string
    createdAt?: Date | string
  }

  export type LikeCommentCreateOrConnectWithoutUserInput = {
    where: LikeCommentWhereUniqueInput
    create: XOR<LikeCommentCreateWithoutUserInput, LikeCommentUncheckedCreateWithoutUserInput>
  }

  export type LikeCommentCreateManyUserInputEnvelope = {
    data: LikeCommentCreateManyUserInput | LikeCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentNotificationCreateWithoutUserInput = {
    id?: string
    isSeen?: boolean
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutCommentNotificationsInput
  }

  export type CommentNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    commentID: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type CommentNotificationCreateOrConnectWithoutUserInput = {
    where: CommentNotificationWhereUniqueInput
    create: XOR<CommentNotificationCreateWithoutUserInput, CommentNotificationUncheckedCreateWithoutUserInput>
  }

  export type CommentNotificationCreateManyUserInputEnvelope = {
    data: CommentNotificationCreateManyUserInput | CommentNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentReplyCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentReplyUncheckedCreateWithoutUserInput = {
    id?: string
    commentID: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentReplyCreateOrConnectWithoutUserInput = {
    where: CommentReplyWhereUniqueInput
    create: XOR<CommentReplyCreateWithoutUserInput, CommentReplyUncheckedCreateWithoutUserInput>
  }

  export type CommentReplyCreateManyUserInputEnvelope = {
    data: CommentReplyCreateManyUserInput | CommentReplyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    blog: BlogCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    blogId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingID: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingsInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerID: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput = {
    id: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
    users_inboxes_senderIDTousers: UserCreateNestedOneWithoutInboxes_inboxes_senderIDTousersInput
  }

  export type inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput = {
    id: string
    senderID: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type inboxesCreateOrConnectWithoutUsers_inboxes_receiverIDTousersInput = {
    where: inboxesWhereUniqueInput
    create: XOR<inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput>
  }

  export type inboxesCreateManyUsers_inboxes_receiverIDTousersInputEnvelope = {
    data: inboxesCreateManyUsers_inboxes_receiverIDTousersInput | inboxesCreateManyUsers_inboxes_receiverIDTousersInput[]
    skipDuplicates?: boolean
  }

  export type inboxesCreateWithoutUsers_inboxes_senderIDTousersInput = {
    id: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
    users_inboxes_receiverIDTousers: UserCreateNestedOneWithoutInboxes_inboxes_receiverIDTousersInput
  }

  export type inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput = {
    id: string
    receiverID: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type inboxesCreateOrConnectWithoutUsers_inboxes_senderIDTousersInput = {
    where: inboxesWhereUniqueInput
    create: XOR<inboxesCreateWithoutUsers_inboxes_senderIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput>
  }

  export type inboxesCreateManyUsers_inboxes_senderIDTousersInputEnvelope = {
    data: inboxesCreateManyUsers_inboxes_senderIDTousersInput | inboxesCreateManyUsers_inboxes_senderIDTousersInput[]
    skipDuplicates?: boolean
  }

  export type LikeNotificationCreateWithoutUserInput = {
    id?: string
    isSeen?: boolean
    createdAt?: Date | string
    blog: BlogLikeCreateNestedOneWithoutLikeNotificationsInput
  }

  export type LikeNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    isSeen?: boolean
    blogLikedId: string
    createdAt?: Date | string
  }

  export type LikeNotificationCreateOrConnectWithoutUserInput = {
    where: LikeNotificationWhereUniqueInput
    create: XOR<LikeNotificationCreateWithoutUserInput, LikeNotificationUncheckedCreateWithoutUserInput>
  }

  export type LikeNotificationCreateManyUserInputEnvelope = {
    data: LikeNotificationCreateManyUserInput | LikeNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MembershipCreateWithoutUserInput = {
    id?: string
    type: $Enums.MemberShipType
    details?: string | null
    price: number
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.MemberShipType
    details?: string | null
    price: number
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipCreateOrConnectWithoutUserInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MessageNotificationCreateWithoutReceiverInput = {
    id?: string
    senderID: string
    message: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type MessageNotificationUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderID: string
    message: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type MessageNotificationCreateOrConnectWithoutReceiverInput = {
    where: MessageNotificationWhereUniqueInput
    create: XOR<MessageNotificationCreateWithoutReceiverInput, MessageNotificationUncheckedCreateWithoutReceiverInput>
  }

  export type MessageNotificationCreateManyReceiverInputEnvelope = {
    data: MessageNotificationCreateManyReceiverInput | MessageNotificationCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ReadHistoryCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutReadHistoriesInput
  }

  export type ReadHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    blogId: string
    createdAt?: Date | string
  }

  export type ReadHistoryCreateOrConnectWithoutUserInput = {
    where: ReadHistoryWhereUniqueInput
    create: XOR<ReadHistoryCreateWithoutUserInput, ReadHistoryUncheckedCreateWithoutUserInput>
  }

  export type ReadHistoryCreateManyUserInputEnvelope = {
    data: ReadHistoryCreateManyUserInput | ReadHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportUserCreateWithoutReportedUserInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUsersReportedInput
  }

  export type ReportUserUncheckedCreateWithoutReportedUserInput = {
    id?: string
    userID: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReportUserCreateOrConnectWithoutReportedUserInput = {
    where: ReportUserWhereUniqueInput
    create: XOR<ReportUserCreateWithoutReportedUserInput, ReportUserUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportUserCreateManyReportedUserInputEnvelope = {
    data: ReportUserCreateManyReportedUserInput | ReportUserCreateManyReportedUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportUserCreateWithoutUserInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    reportedUser: UserCreateNestedOneWithoutReportedUsersInput
  }

  export type ReportUserUncheckedCreateWithoutUserInput = {
    id?: string
    reportedID: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReportUserCreateOrConnectWithoutUserInput = {
    where: ReportUserWhereUniqueInput
    create: XOR<ReportUserCreateWithoutUserInput, ReportUserUncheckedCreateWithoutUserInput>
  }

  export type ReportUserCreateManyUserInputEnvelope = {
    data: ReportUserCreateManyUserInput | ReportUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedBlogCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutSavedByInput
  }

  export type SavedBlogUncheckedCreateWithoutUserInput = {
    id?: string
    blogID: string
    createdAt?: Date | string
  }

  export type SavedBlogCreateOrConnectWithoutUserInput = {
    where: SavedBlogWhereUniqueInput
    create: XOR<SavedBlogCreateWithoutUserInput, SavedBlogUncheckedCreateWithoutUserInput>
  }

  export type SavedBlogCreateManyUserInputEnvelope = {
    data: SavedBlogCreateManyUserInput | SavedBlogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlockedUserUpsertWithWhereUniqueWithoutBlockedUserInput = {
    where: BlockedUserWhereUniqueInput
    update: XOR<BlockedUserUpdateWithoutBlockedUserInput, BlockedUserUncheckedUpdateWithoutBlockedUserInput>
    create: XOR<BlockedUserCreateWithoutBlockedUserInput, BlockedUserUncheckedCreateWithoutBlockedUserInput>
  }

  export type BlockedUserUpdateWithWhereUniqueWithoutBlockedUserInput = {
    where: BlockedUserWhereUniqueInput
    data: XOR<BlockedUserUpdateWithoutBlockedUserInput, BlockedUserUncheckedUpdateWithoutBlockedUserInput>
  }

  export type BlockedUserUpdateManyWithWhereWithoutBlockedUserInput = {
    where: BlockedUserScalarWhereInput
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyWithoutBlockedUserInput>
  }

  export type BlockedUserScalarWhereInput = {
    AND?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
    OR?: BlockedUserScalarWhereInput[]
    NOT?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
    id?: StringFilter<"BlockedUser"> | string
    userID?: StringFilter<"BlockedUser"> | string
    blockedID?: StringFilter<"BlockedUser"> | string
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
  }

  export type BlockedUserUpsertWithWhereUniqueWithoutUserInput = {
    where: BlockedUserWhereUniqueInput
    update: XOR<BlockedUserUpdateWithoutUserInput, BlockedUserUncheckedUpdateWithoutUserInput>
    create: XOR<BlockedUserCreateWithoutUserInput, BlockedUserUncheckedCreateWithoutUserInput>
  }

  export type BlockedUserUpdateWithWhereUniqueWithoutUserInput = {
    where: BlockedUserWhereUniqueInput
    data: XOR<BlockedUserUpdateWithoutUserInput, BlockedUserUncheckedUpdateWithoutUserInput>
  }

  export type BlockedUserUpdateManyWithWhereWithoutUserInput = {
    where: BlockedUserScalarWhereInput
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogDisLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogDisLikeWhereUniqueInput
    update: XOR<BlogDisLikeUpdateWithoutUserInput, BlogDisLikeUncheckedUpdateWithoutUserInput>
    create: XOR<BlogDisLikeCreateWithoutUserInput, BlogDisLikeUncheckedCreateWithoutUserInput>
  }

  export type BlogDisLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogDisLikeWhereUniqueInput
    data: XOR<BlogDisLikeUpdateWithoutUserInput, BlogDisLikeUncheckedUpdateWithoutUserInput>
  }

  export type BlogDisLikeUpdateManyWithWhereWithoutUserInput = {
    where: BlogDisLikeScalarWhereInput
    data: XOR<BlogDisLikeUpdateManyMutationInput, BlogDisLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogDisLikeScalarWhereInput = {
    AND?: BlogDisLikeScalarWhereInput | BlogDisLikeScalarWhereInput[]
    OR?: BlogDisLikeScalarWhereInput[]
    NOT?: BlogDisLikeScalarWhereInput | BlogDisLikeScalarWhereInput[]
    id?: StringFilter<"BlogDisLike"> | string
    userID?: StringFilter<"BlogDisLike"> | string
    blogID?: StringFilter<"BlogDisLike"> | string
    createdAt?: DateTimeFilter<"BlogDisLike"> | Date | string
  }

  export type BlogLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogLikeWhereUniqueInput
    update: XOR<BlogLikeUpdateWithoutUserInput, BlogLikeUncheckedUpdateWithoutUserInput>
    create: XOR<BlogLikeCreateWithoutUserInput, BlogLikeUncheckedCreateWithoutUserInput>
  }

  export type BlogLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogLikeWhereUniqueInput
    data: XOR<BlogLikeUpdateWithoutUserInput, BlogLikeUncheckedUpdateWithoutUserInput>
  }

  export type BlogLikeUpdateManyWithWhereWithoutUserInput = {
    where: BlogLikeScalarWhereInput
    data: XOR<BlogLikeUpdateManyMutationInput, BlogLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogLikeScalarWhereInput = {
    AND?: BlogLikeScalarWhereInput | BlogLikeScalarWhereInput[]
    OR?: BlogLikeScalarWhereInput[]
    NOT?: BlogLikeScalarWhereInput | BlogLikeScalarWhereInput[]
    id?: StringFilter<"BlogLike"> | string
    userID?: StringFilter<"BlogLike"> | string
    blogID?: StringFilter<"BlogLike"> | string
    createdAt?: DateTimeFilter<"BlogLike"> | Date | string
  }

  export type ReportBlogUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportBlogWhereUniqueInput
    update: XOR<ReportBlogUpdateWithoutUserInput, ReportBlogUncheckedUpdateWithoutUserInput>
    create: XOR<ReportBlogCreateWithoutUserInput, ReportBlogUncheckedCreateWithoutUserInput>
  }

  export type ReportBlogUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportBlogWhereUniqueInput
    data: XOR<ReportBlogUpdateWithoutUserInput, ReportBlogUncheckedUpdateWithoutUserInput>
  }

  export type ReportBlogUpdateManyWithWhereWithoutUserInput = {
    where: ReportBlogScalarWhereInput
    data: XOR<ReportBlogUpdateManyMutationInput, ReportBlogUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportBlogScalarWhereInput = {
    AND?: ReportBlogScalarWhereInput | ReportBlogScalarWhereInput[]
    OR?: ReportBlogScalarWhereInput[]
    NOT?: ReportBlogScalarWhereInput | ReportBlogScalarWhereInput[]
    id?: StringFilter<"ReportBlog"> | string
    userID?: StringFilter<"ReportBlog"> | string
    blogID?: StringFilter<"ReportBlog"> | string
    type?: EnumReportMessageFilter<"ReportBlog"> | $Enums.ReportMessage
    message?: StringNullableFilter<"ReportBlog"> | string | null
    createdAt?: DateTimeFilter<"ReportBlog"> | Date | string
  }

  export type BlogUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogWhereUniqueInput
    update: XOR<BlogUpdateWithoutUserInput, BlogUncheckedUpdateWithoutUserInput>
    create: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput>
  }

  export type BlogUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogWhereUniqueInput
    data: XOR<BlogUpdateWithoutUserInput, BlogUncheckedUpdateWithoutUserInput>
  }

  export type BlogUpdateManyWithWhereWithoutUserInput = {
    where: BlogScalarWhereInput
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogScalarWhereInput = {
    AND?: BlogScalarWhereInput | BlogScalarWhereInput[]
    OR?: BlogScalarWhereInput[]
    NOT?: BlogScalarWhereInput | BlogScalarWhereInput[]
    id?: StringFilter<"Blog"> | string
    userID?: StringFilter<"Blog"> | string
    title?: StringFilter<"Blog"> | string
    content?: StringFilter<"Blog"> | string
    thumbnail?: StringNullableFilter<"Blog"> | string | null
    isMemberOnly?: BoolFilter<"Blog"> | boolean
    isPublished?: BoolFilter<"Blog"> | boolean
    viewCount?: IntFilter<"Blog"> | number
    readCount?: IntFilter<"Blog"> | number
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
  }

  export type DisLikeCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: DisLikeCommentWhereUniqueInput
    update: XOR<DisLikeCommentUpdateWithoutUserInput, DisLikeCommentUncheckedUpdateWithoutUserInput>
    create: XOR<DisLikeCommentCreateWithoutUserInput, DisLikeCommentUncheckedCreateWithoutUserInput>
  }

  export type DisLikeCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: DisLikeCommentWhereUniqueInput
    data: XOR<DisLikeCommentUpdateWithoutUserInput, DisLikeCommentUncheckedUpdateWithoutUserInput>
  }

  export type DisLikeCommentUpdateManyWithWhereWithoutUserInput = {
    where: DisLikeCommentScalarWhereInput
    data: XOR<DisLikeCommentUpdateManyMutationInput, DisLikeCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type DisLikeCommentScalarWhereInput = {
    AND?: DisLikeCommentScalarWhereInput | DisLikeCommentScalarWhereInput[]
    OR?: DisLikeCommentScalarWhereInput[]
    NOT?: DisLikeCommentScalarWhereInput | DisLikeCommentScalarWhereInput[]
    id?: StringFilter<"DisLikeComment"> | string
    userID?: StringFilter<"DisLikeComment"> | string
    commentID?: StringFilter<"DisLikeComment"> | string
    createdAt?: DateTimeFilter<"DisLikeComment"> | Date | string
  }

  export type LikeCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeCommentWhereUniqueInput
    update: XOR<LikeCommentUpdateWithoutUserInput, LikeCommentUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCommentCreateWithoutUserInput, LikeCommentUncheckedCreateWithoutUserInput>
  }

  export type LikeCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeCommentWhereUniqueInput
    data: XOR<LikeCommentUpdateWithoutUserInput, LikeCommentUncheckedUpdateWithoutUserInput>
  }

  export type LikeCommentUpdateManyWithWhereWithoutUserInput = {
    where: LikeCommentScalarWhereInput
    data: XOR<LikeCommentUpdateManyMutationInput, LikeCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeCommentScalarWhereInput = {
    AND?: LikeCommentScalarWhereInput | LikeCommentScalarWhereInput[]
    OR?: LikeCommentScalarWhereInput[]
    NOT?: LikeCommentScalarWhereInput | LikeCommentScalarWhereInput[]
    id?: StringFilter<"LikeComment"> | string
    userID?: StringFilter<"LikeComment"> | string
    commentID?: StringFilter<"LikeComment"> | string
    createdAt?: DateTimeFilter<"LikeComment"> | Date | string
  }

  export type CommentNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentNotificationWhereUniqueInput
    update: XOR<CommentNotificationUpdateWithoutUserInput, CommentNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<CommentNotificationCreateWithoutUserInput, CommentNotificationUncheckedCreateWithoutUserInput>
  }

  export type CommentNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentNotificationWhereUniqueInput
    data: XOR<CommentNotificationUpdateWithoutUserInput, CommentNotificationUncheckedUpdateWithoutUserInput>
  }

  export type CommentNotificationUpdateManyWithWhereWithoutUserInput = {
    where: CommentNotificationScalarWhereInput
    data: XOR<CommentNotificationUpdateManyMutationInput, CommentNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentNotificationScalarWhereInput = {
    AND?: CommentNotificationScalarWhereInput | CommentNotificationScalarWhereInput[]
    OR?: CommentNotificationScalarWhereInput[]
    NOT?: CommentNotificationScalarWhereInput | CommentNotificationScalarWhereInput[]
    id?: StringFilter<"CommentNotification"> | string
    userID?: StringFilter<"CommentNotification"> | string
    commentID?: StringFilter<"CommentNotification"> | string
    isSeen?: BoolFilter<"CommentNotification"> | boolean
    createdAt?: DateTimeFilter<"CommentNotification"> | Date | string
  }

  export type CommentReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentReplyWhereUniqueInput
    update: XOR<CommentReplyUpdateWithoutUserInput, CommentReplyUncheckedUpdateWithoutUserInput>
    create: XOR<CommentReplyCreateWithoutUserInput, CommentReplyUncheckedCreateWithoutUserInput>
  }

  export type CommentReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentReplyWhereUniqueInput
    data: XOR<CommentReplyUpdateWithoutUserInput, CommentReplyUncheckedUpdateWithoutUserInput>
  }

  export type CommentReplyUpdateManyWithWhereWithoutUserInput = {
    where: CommentReplyScalarWhereInput
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentReplyScalarWhereInput = {
    AND?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
    OR?: CommentReplyScalarWhereInput[]
    NOT?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
    id?: StringFilter<"CommentReply"> | string
    userID?: StringFilter<"CommentReply"> | string
    commentID?: StringFilter<"CommentReply"> | string
    message?: StringFilter<"CommentReply"> | string
    createdAt?: DateTimeFilter<"CommentReply"> | Date | string
    updatedAt?: DateTimeFilter<"CommentReply"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    userID?: StringFilter<"Comment"> | string
    blogId?: StringFilter<"Comment"> | string
    message?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerID?: StringFilter<"Follow"> | string
    followingID?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput = {
    where: inboxesWhereUniqueInput
    update: XOR<inboxesUpdateWithoutUsers_inboxes_receiverIDTousersInput, inboxesUncheckedUpdateWithoutUsers_inboxes_receiverIDTousersInput>
    create: XOR<inboxesCreateWithoutUsers_inboxes_receiverIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_receiverIDTousersInput>
  }

  export type inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_receiverIDTousersInput = {
    where: inboxesWhereUniqueInput
    data: XOR<inboxesUpdateWithoutUsers_inboxes_receiverIDTousersInput, inboxesUncheckedUpdateWithoutUsers_inboxes_receiverIDTousersInput>
  }

  export type inboxesUpdateManyWithWhereWithoutUsers_inboxes_receiverIDTousersInput = {
    where: inboxesScalarWhereInput
    data: XOR<inboxesUpdateManyMutationInput, inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersInput>
  }

  export type inboxesScalarWhereInput = {
    AND?: inboxesScalarWhereInput | inboxesScalarWhereInput[]
    OR?: inboxesScalarWhereInput[]
    NOT?: inboxesScalarWhereInput | inboxesScalarWhereInput[]
    id?: StringFilter<"inboxes"> | string
    senderID?: StringFilter<"inboxes"> | string
    receiverID?: StringFilter<"inboxes"> | string
    message?: StringFilter<"inboxes"> | string
    createdAt?: DateTimeFilter<"inboxes"> | Date | string
    updatedAt?: DateTimeFilter<"inboxes"> | Date | string
  }

  export type inboxesUpsertWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput = {
    where: inboxesWhereUniqueInput
    update: XOR<inboxesUpdateWithoutUsers_inboxes_senderIDTousersInput, inboxesUncheckedUpdateWithoutUsers_inboxes_senderIDTousersInput>
    create: XOR<inboxesCreateWithoutUsers_inboxes_senderIDTousersInput, inboxesUncheckedCreateWithoutUsers_inboxes_senderIDTousersInput>
  }

  export type inboxesUpdateWithWhereUniqueWithoutUsers_inboxes_senderIDTousersInput = {
    where: inboxesWhereUniqueInput
    data: XOR<inboxesUpdateWithoutUsers_inboxes_senderIDTousersInput, inboxesUncheckedUpdateWithoutUsers_inboxes_senderIDTousersInput>
  }

  export type inboxesUpdateManyWithWhereWithoutUsers_inboxes_senderIDTousersInput = {
    where: inboxesScalarWhereInput
    data: XOR<inboxesUpdateManyMutationInput, inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersInput>
  }

  export type LikeNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeNotificationWhereUniqueInput
    update: XOR<LikeNotificationUpdateWithoutUserInput, LikeNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<LikeNotificationCreateWithoutUserInput, LikeNotificationUncheckedCreateWithoutUserInput>
  }

  export type LikeNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeNotificationWhereUniqueInput
    data: XOR<LikeNotificationUpdateWithoutUserInput, LikeNotificationUncheckedUpdateWithoutUserInput>
  }

  export type LikeNotificationUpdateManyWithWhereWithoutUserInput = {
    where: LikeNotificationScalarWhereInput
    data: XOR<LikeNotificationUpdateManyMutationInput, LikeNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeNotificationScalarWhereInput = {
    AND?: LikeNotificationScalarWhereInput | LikeNotificationScalarWhereInput[]
    OR?: LikeNotificationScalarWhereInput[]
    NOT?: LikeNotificationScalarWhereInput | LikeNotificationScalarWhereInput[]
    id?: StringFilter<"LikeNotification"> | string
    userID?: StringFilter<"LikeNotification"> | string
    isSeen?: BoolFilter<"LikeNotification"> | boolean
    blogLikedId?: StringFilter<"LikeNotification"> | string
    createdAt?: DateTimeFilter<"LikeNotification"> | Date | string
  }

  export type MembershipUpsertWithoutUserInput = {
    update: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
    where?: MembershipWhereInput
  }

  export type MembershipUpdateToOneWithWhereWithoutUserInput = {
    where?: MembershipWhereInput
    data: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageNotificationUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageNotificationWhereUniqueInput
    update: XOR<MessageNotificationUpdateWithoutReceiverInput, MessageNotificationUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageNotificationCreateWithoutReceiverInput, MessageNotificationUncheckedCreateWithoutReceiverInput>
  }

  export type MessageNotificationUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageNotificationWhereUniqueInput
    data: XOR<MessageNotificationUpdateWithoutReceiverInput, MessageNotificationUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageNotificationUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageNotificationScalarWhereInput
    data: XOR<MessageNotificationUpdateManyMutationInput, MessageNotificationUncheckedUpdateManyWithoutReceiverInput>
  }

  export type MessageNotificationScalarWhereInput = {
    AND?: MessageNotificationScalarWhereInput | MessageNotificationScalarWhereInput[]
    OR?: MessageNotificationScalarWhereInput[]
    NOT?: MessageNotificationScalarWhereInput | MessageNotificationScalarWhereInput[]
    id?: StringFilter<"MessageNotification"> | string
    receiverID?: StringFilter<"MessageNotification"> | string
    senderID?: StringFilter<"MessageNotification"> | string
    message?: StringFilter<"MessageNotification"> | string
    isSeen?: BoolFilter<"MessageNotification"> | boolean
    createdAt?: DateTimeFilter<"MessageNotification"> | Date | string
  }

  export type ReadHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ReadHistoryWhereUniqueInput
    update: XOR<ReadHistoryUpdateWithoutUserInput, ReadHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ReadHistoryCreateWithoutUserInput, ReadHistoryUncheckedCreateWithoutUserInput>
  }

  export type ReadHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ReadHistoryWhereUniqueInput
    data: XOR<ReadHistoryUpdateWithoutUserInput, ReadHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ReadHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ReadHistoryScalarWhereInput
    data: XOR<ReadHistoryUpdateManyMutationInput, ReadHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ReadHistoryScalarWhereInput = {
    AND?: ReadHistoryScalarWhereInput | ReadHistoryScalarWhereInput[]
    OR?: ReadHistoryScalarWhereInput[]
    NOT?: ReadHistoryScalarWhereInput | ReadHistoryScalarWhereInput[]
    id?: StringFilter<"ReadHistory"> | string
    userID?: StringFilter<"ReadHistory"> | string
    blogId?: StringFilter<"ReadHistory"> | string
    createdAt?: DateTimeFilter<"ReadHistory"> | Date | string
  }

  export type ReportUserUpsertWithWhereUniqueWithoutReportedUserInput = {
    where: ReportUserWhereUniqueInput
    update: XOR<ReportUserUpdateWithoutReportedUserInput, ReportUserUncheckedUpdateWithoutReportedUserInput>
    create: XOR<ReportUserCreateWithoutReportedUserInput, ReportUserUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportUserUpdateWithWhereUniqueWithoutReportedUserInput = {
    where: ReportUserWhereUniqueInput
    data: XOR<ReportUserUpdateWithoutReportedUserInput, ReportUserUncheckedUpdateWithoutReportedUserInput>
  }

  export type ReportUserUpdateManyWithWhereWithoutReportedUserInput = {
    where: ReportUserScalarWhereInput
    data: XOR<ReportUserUpdateManyMutationInput, ReportUserUncheckedUpdateManyWithoutReportedUserInput>
  }

  export type ReportUserScalarWhereInput = {
    AND?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
    OR?: ReportUserScalarWhereInput[]
    NOT?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
    id?: StringFilter<"ReportUser"> | string
    userID?: StringFilter<"ReportUser"> | string
    reportedID?: StringFilter<"ReportUser"> | string
    reason?: StringNullableFilter<"ReportUser"> | string | null
    createdAt?: DateTimeFilter<"ReportUser"> | Date | string
  }

  export type ReportUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportUserWhereUniqueInput
    update: XOR<ReportUserUpdateWithoutUserInput, ReportUserUncheckedUpdateWithoutUserInput>
    create: XOR<ReportUserCreateWithoutUserInput, ReportUserUncheckedCreateWithoutUserInput>
  }

  export type ReportUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportUserWhereUniqueInput
    data: XOR<ReportUserUpdateWithoutUserInput, ReportUserUncheckedUpdateWithoutUserInput>
  }

  export type ReportUserUpdateManyWithWhereWithoutUserInput = {
    where: ReportUserScalarWhereInput
    data: XOR<ReportUserUpdateManyMutationInput, ReportUserUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedBlogUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedBlogWhereUniqueInput
    update: XOR<SavedBlogUpdateWithoutUserInput, SavedBlogUncheckedUpdateWithoutUserInput>
    create: XOR<SavedBlogCreateWithoutUserInput, SavedBlogUncheckedCreateWithoutUserInput>
  }

  export type SavedBlogUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedBlogWhereUniqueInput
    data: XOR<SavedBlogUpdateWithoutUserInput, SavedBlogUncheckedUpdateWithoutUserInput>
  }

  export type SavedBlogUpdateManyWithWhereWithoutUserInput = {
    where: SavedBlogScalarWhereInput
    data: XOR<SavedBlogUpdateManyMutationInput, SavedBlogUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedBlogScalarWhereInput = {
    AND?: SavedBlogScalarWhereInput | SavedBlogScalarWhereInput[]
    OR?: SavedBlogScalarWhereInput[]
    NOT?: SavedBlogScalarWhereInput | SavedBlogScalarWhereInput[]
    id?: StringFilter<"SavedBlog"> | string
    userID?: StringFilter<"SavedBlog"> | string
    blogID?: StringFilter<"SavedBlog"> | string
    createdAt?: DateTimeFilter<"SavedBlog"> | Date | string
  }

  export type UserCreateWithoutBlockedByUsersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlockedByUsersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlockedByUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedByUsersInput, UserUncheckedCreateWithoutBlockedByUsersInput>
  }

  export type UserCreateWithoutBlockedUsersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlockedUsersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlockedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
  }

  export type UserUpsertWithoutBlockedByUsersInput = {
    update: XOR<UserUpdateWithoutBlockedByUsersInput, UserUncheckedUpdateWithoutBlockedByUsersInput>
    create: XOR<UserCreateWithoutBlockedByUsersInput, UserUncheckedCreateWithoutBlockedByUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedByUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedByUsersInput, UserUncheckedUpdateWithoutBlockedByUsersInput>
  }

  export type UserUpdateWithoutBlockedByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBlockedUsersInput = {
    update: XOR<UserUpdateWithoutBlockedUsersInput, UserUncheckedUpdateWithoutBlockedUsersInput>
    create: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedUsersInput, UserUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type UserUpdateWithoutBlockedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReportedUsersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportedUsersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedUsersInput, UserUncheckedCreateWithoutReportedUsersInput>
  }

  export type UserCreateWithoutUsersReportedInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsersReportedInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsersReportedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsersReportedInput, UserUncheckedCreateWithoutUsersReportedInput>
  }

  export type UserUpsertWithoutReportedUsersInput = {
    update: XOR<UserUpdateWithoutReportedUsersInput, UserUncheckedUpdateWithoutReportedUsersInput>
    create: XOR<UserCreateWithoutReportedUsersInput, UserUncheckedCreateWithoutReportedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedUsersInput, UserUncheckedUpdateWithoutReportedUsersInput>
  }

  export type UserUpdateWithoutReportedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutUsersReportedInput = {
    update: XOR<UserUpdateWithoutUsersReportedInput, UserUncheckedUpdateWithoutUsersReportedInput>
    create: XOR<UserCreateWithoutUsersReportedInput, UserUncheckedCreateWithoutUsersReportedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsersReportedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsersReportedInput, UserUncheckedUpdateWithoutUsersReportedInput>
  }

  export type UserUpdateWithoutUsersReportedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsersReportedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCreateWithoutReadHistoriesInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeCreateNestedManyWithoutBlogInput
    likes?: BlogLikeCreateNestedManyWithoutBlogInput
    reports?: ReportBlogCreateNestedManyWithoutBlogInput
    user: UserCreateNestedOneWithoutBlogsInput
    comments?: CommentCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogCreateNestedManyWithoutBlogInput
    topics?: TopicCreateNestedManyWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutReadHistoriesInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput
    likes?: BlogLikeUncheckedCreateNestedManyWithoutBlogInput
    reports?: ReportBlogUncheckedCreateNestedManyWithoutBlogInput
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogUncheckedCreateNestedManyWithoutBlogInput
    topics?: TopicUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type BlogCreateOrConnectWithoutReadHistoriesInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutReadHistoriesInput, BlogUncheckedCreateWithoutReadHistoriesInput>
  }

  export type UserCreateWithoutReadHistoriesInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReadHistoriesInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReadHistoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReadHistoriesInput, UserUncheckedCreateWithoutReadHistoriesInput>
  }

  export type BlogUpsertWithoutReadHistoriesInput = {
    update: XOR<BlogUpdateWithoutReadHistoriesInput, BlogUncheckedUpdateWithoutReadHistoriesInput>
    create: XOR<BlogCreateWithoutReadHistoriesInput, BlogUncheckedCreateWithoutReadHistoriesInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutReadHistoriesInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutReadHistoriesInput, BlogUncheckedUpdateWithoutReadHistoriesInput>
  }

  export type BlogUpdateWithoutReadHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUpdateManyWithoutBlogNestedInput
    user?: UserUpdateOneRequiredWithoutBlogsNestedInput
    comments?: CommentUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUpdateManyWithoutBlogNestedInput
    topics?: TopicUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutReadHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUncheckedUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUncheckedUpdateManyWithoutBlogNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUncheckedUpdateManyWithoutBlogNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBlogsNestedInput
  }

  export type UserUpsertWithoutReadHistoriesInput = {
    update: XOR<UserUpdateWithoutReadHistoriesInput, UserUncheckedUpdateWithoutReadHistoriesInput>
    create: XOR<UserCreateWithoutReadHistoriesInput, UserUncheckedCreateWithoutReadHistoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReadHistoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReadHistoriesInput, UserUncheckedUpdateWithoutReadHistoriesInput>
  }

  export type UserUpdateWithoutReadHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReadHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogDisLikeCreateWithoutBlogInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBlogDisLikesInput
  }

  export type BlogDisLikeUncheckedCreateWithoutBlogInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type BlogDisLikeCreateOrConnectWithoutBlogInput = {
    where: BlogDisLikeWhereUniqueInput
    create: XOR<BlogDisLikeCreateWithoutBlogInput, BlogDisLikeUncheckedCreateWithoutBlogInput>
  }

  export type BlogDisLikeCreateManyBlogInputEnvelope = {
    data: BlogDisLikeCreateManyBlogInput | BlogDisLikeCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type BlogLikeCreateWithoutBlogInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBlogLikesInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutBlogInput
  }

  export type BlogLikeUncheckedCreateWithoutBlogInput = {
    id?: string
    userID: string
    createdAt?: Date | string
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogLikeCreateOrConnectWithoutBlogInput = {
    where: BlogLikeWhereUniqueInput
    create: XOR<BlogLikeCreateWithoutBlogInput, BlogLikeUncheckedCreateWithoutBlogInput>
  }

  export type BlogLikeCreateManyBlogInputEnvelope = {
    data: BlogLikeCreateManyBlogInput | BlogLikeCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type ReportBlogCreateWithoutBlogInput = {
    id?: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReportedBlogsInput
  }

  export type ReportBlogUncheckedCreateWithoutBlogInput = {
    id?: string
    userID: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
  }

  export type ReportBlogCreateOrConnectWithoutBlogInput = {
    where: ReportBlogWhereUniqueInput
    create: XOR<ReportBlogCreateWithoutBlogInput, ReportBlogUncheckedCreateWithoutBlogInput>
  }

  export type ReportBlogCreateManyBlogInputEnvelope = {
    data: ReportBlogCreateManyBlogInput | ReportBlogCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBlogsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
  }

  export type CommentCreateWithoutBlogInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutBlogInput = {
    id?: string
    userID: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutBlogInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput>
  }

  export type CommentCreateManyBlogInputEnvelope = {
    data: CommentCreateManyBlogInput | CommentCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type ReadHistoryCreateWithoutBlogInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReadHistoriesInput
  }

  export type ReadHistoryUncheckedCreateWithoutBlogInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type ReadHistoryCreateOrConnectWithoutBlogInput = {
    where: ReadHistoryWhereUniqueInput
    create: XOR<ReadHistoryCreateWithoutBlogInput, ReadHistoryUncheckedCreateWithoutBlogInput>
  }

  export type ReadHistoryCreateManyBlogInputEnvelope = {
    data: ReadHistoryCreateManyBlogInput | ReadHistoryCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type SavedBlogCreateWithoutBlogInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSavedBlogsInput
  }

  export type SavedBlogUncheckedCreateWithoutBlogInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type SavedBlogCreateOrConnectWithoutBlogInput = {
    where: SavedBlogWhereUniqueInput
    create: XOR<SavedBlogCreateWithoutBlogInput, SavedBlogUncheckedCreateWithoutBlogInput>
  }

  export type SavedBlogCreateManyBlogInputEnvelope = {
    data: SavedBlogCreateManyBlogInput | SavedBlogCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type TopicCreateWithoutBlogsInput = {
    id?: string
    topicName: string
    slug: string
  }

  export type TopicUncheckedCreateWithoutBlogsInput = {
    id?: string
    topicName: string
    slug: string
  }

  export type TopicCreateOrConnectWithoutBlogsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutBlogsInput, TopicUncheckedCreateWithoutBlogsInput>
  }

  export type BlogDisLikeUpsertWithWhereUniqueWithoutBlogInput = {
    where: BlogDisLikeWhereUniqueInput
    update: XOR<BlogDisLikeUpdateWithoutBlogInput, BlogDisLikeUncheckedUpdateWithoutBlogInput>
    create: XOR<BlogDisLikeCreateWithoutBlogInput, BlogDisLikeUncheckedCreateWithoutBlogInput>
  }

  export type BlogDisLikeUpdateWithWhereUniqueWithoutBlogInput = {
    where: BlogDisLikeWhereUniqueInput
    data: XOR<BlogDisLikeUpdateWithoutBlogInput, BlogDisLikeUncheckedUpdateWithoutBlogInput>
  }

  export type BlogDisLikeUpdateManyWithWhereWithoutBlogInput = {
    where: BlogDisLikeScalarWhereInput
    data: XOR<BlogDisLikeUpdateManyMutationInput, BlogDisLikeUncheckedUpdateManyWithoutBlogInput>
  }

  export type BlogLikeUpsertWithWhereUniqueWithoutBlogInput = {
    where: BlogLikeWhereUniqueInput
    update: XOR<BlogLikeUpdateWithoutBlogInput, BlogLikeUncheckedUpdateWithoutBlogInput>
    create: XOR<BlogLikeCreateWithoutBlogInput, BlogLikeUncheckedCreateWithoutBlogInput>
  }

  export type BlogLikeUpdateWithWhereUniqueWithoutBlogInput = {
    where: BlogLikeWhereUniqueInput
    data: XOR<BlogLikeUpdateWithoutBlogInput, BlogLikeUncheckedUpdateWithoutBlogInput>
  }

  export type BlogLikeUpdateManyWithWhereWithoutBlogInput = {
    where: BlogLikeScalarWhereInput
    data: XOR<BlogLikeUpdateManyMutationInput, BlogLikeUncheckedUpdateManyWithoutBlogInput>
  }

  export type ReportBlogUpsertWithWhereUniqueWithoutBlogInput = {
    where: ReportBlogWhereUniqueInput
    update: XOR<ReportBlogUpdateWithoutBlogInput, ReportBlogUncheckedUpdateWithoutBlogInput>
    create: XOR<ReportBlogCreateWithoutBlogInput, ReportBlogUncheckedCreateWithoutBlogInput>
  }

  export type ReportBlogUpdateWithWhereUniqueWithoutBlogInput = {
    where: ReportBlogWhereUniqueInput
    data: XOR<ReportBlogUpdateWithoutBlogInput, ReportBlogUncheckedUpdateWithoutBlogInput>
  }

  export type ReportBlogUpdateManyWithWhereWithoutBlogInput = {
    where: ReportBlogScalarWhereInput
    data: XOR<ReportBlogUpdateManyMutationInput, ReportBlogUncheckedUpdateManyWithoutBlogInput>
  }

  export type UserUpsertWithoutBlogsInput = {
    update: XOR<UserUpdateWithoutBlogsInput, UserUncheckedUpdateWithoutBlogsInput>
    create: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogsInput, UserUncheckedUpdateWithoutBlogsInput>
  }

  export type UserUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutBlogInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutBlogInput, CommentUncheckedUpdateWithoutBlogInput>
    create: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutBlogInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutBlogInput, CommentUncheckedUpdateWithoutBlogInput>
  }

  export type CommentUpdateManyWithWhereWithoutBlogInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutBlogInput>
  }

  export type ReadHistoryUpsertWithWhereUniqueWithoutBlogInput = {
    where: ReadHistoryWhereUniqueInput
    update: XOR<ReadHistoryUpdateWithoutBlogInput, ReadHistoryUncheckedUpdateWithoutBlogInput>
    create: XOR<ReadHistoryCreateWithoutBlogInput, ReadHistoryUncheckedCreateWithoutBlogInput>
  }

  export type ReadHistoryUpdateWithWhereUniqueWithoutBlogInput = {
    where: ReadHistoryWhereUniqueInput
    data: XOR<ReadHistoryUpdateWithoutBlogInput, ReadHistoryUncheckedUpdateWithoutBlogInput>
  }

  export type ReadHistoryUpdateManyWithWhereWithoutBlogInput = {
    where: ReadHistoryScalarWhereInput
    data: XOR<ReadHistoryUpdateManyMutationInput, ReadHistoryUncheckedUpdateManyWithoutBlogInput>
  }

  export type SavedBlogUpsertWithWhereUniqueWithoutBlogInput = {
    where: SavedBlogWhereUniqueInput
    update: XOR<SavedBlogUpdateWithoutBlogInput, SavedBlogUncheckedUpdateWithoutBlogInput>
    create: XOR<SavedBlogCreateWithoutBlogInput, SavedBlogUncheckedCreateWithoutBlogInput>
  }

  export type SavedBlogUpdateWithWhereUniqueWithoutBlogInput = {
    where: SavedBlogWhereUniqueInput
    data: XOR<SavedBlogUpdateWithoutBlogInput, SavedBlogUncheckedUpdateWithoutBlogInput>
  }

  export type SavedBlogUpdateManyWithWhereWithoutBlogInput = {
    where: SavedBlogScalarWhereInput
    data: XOR<SavedBlogUpdateManyMutationInput, SavedBlogUncheckedUpdateManyWithoutBlogInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutBlogsInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutBlogsInput, TopicUncheckedUpdateWithoutBlogsInput>
    create: XOR<TopicCreateWithoutBlogsInput, TopicUncheckedCreateWithoutBlogsInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutBlogsInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutBlogsInput, TopicUncheckedUpdateWithoutBlogsInput>
  }

  export type TopicUpdateManyWithWhereWithoutBlogsInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutBlogsInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: StringFilter<"Topic"> | string
    topicName?: StringFilter<"Topic"> | string
    slug?: StringFilter<"Topic"> | string
  }

  export type BlogCreateWithoutLikesInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeCreateNestedManyWithoutBlogInput
    reports?: ReportBlogCreateNestedManyWithoutBlogInput
    user: UserCreateNestedOneWithoutBlogsInput
    comments?: CommentCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogCreateNestedManyWithoutBlogInput
    topics?: TopicCreateNestedManyWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutLikesInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput
    reports?: ReportBlogUncheckedCreateNestedManyWithoutBlogInput
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogUncheckedCreateNestedManyWithoutBlogInput
    topics?: TopicUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type BlogCreateOrConnectWithoutLikesInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutLikesInput, BlogUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutBlogLikesInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogLikesInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogLikesInput, UserUncheckedCreateWithoutBlogLikesInput>
  }

  export type LikeNotificationCreateWithoutBlogInput = {
    id?: string
    isSeen?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikeNotificationsInput
  }

  export type LikeNotificationUncheckedCreateWithoutBlogInput = {
    id?: string
    userID: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type LikeNotificationCreateOrConnectWithoutBlogInput = {
    where: LikeNotificationWhereUniqueInput
    create: XOR<LikeNotificationCreateWithoutBlogInput, LikeNotificationUncheckedCreateWithoutBlogInput>
  }

  export type LikeNotificationCreateManyBlogInputEnvelope = {
    data: LikeNotificationCreateManyBlogInput | LikeNotificationCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type BlogUpsertWithoutLikesInput = {
    update: XOR<BlogUpdateWithoutLikesInput, BlogUncheckedUpdateWithoutLikesInput>
    create: XOR<BlogCreateWithoutLikesInput, BlogUncheckedCreateWithoutLikesInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutLikesInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutLikesInput, BlogUncheckedUpdateWithoutLikesInput>
  }

  export type BlogUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUpdateManyWithoutBlogNestedInput
    user?: UserUpdateOneRequiredWithoutBlogsNestedInput
    comments?: CommentUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUpdateManyWithoutBlogNestedInput
    topics?: TopicUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUncheckedUpdateManyWithoutBlogNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUncheckedUpdateManyWithoutBlogNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBlogsNestedInput
  }

  export type UserUpsertWithoutBlogLikesInput = {
    update: XOR<UserUpdateWithoutBlogLikesInput, UserUncheckedUpdateWithoutBlogLikesInput>
    create: XOR<UserCreateWithoutBlogLikesInput, UserUncheckedCreateWithoutBlogLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogLikesInput, UserUncheckedUpdateWithoutBlogLikesInput>
  }

  export type UserUpdateWithoutBlogLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LikeNotificationUpsertWithWhereUniqueWithoutBlogInput = {
    where: LikeNotificationWhereUniqueInput
    update: XOR<LikeNotificationUpdateWithoutBlogInput, LikeNotificationUncheckedUpdateWithoutBlogInput>
    create: XOR<LikeNotificationCreateWithoutBlogInput, LikeNotificationUncheckedCreateWithoutBlogInput>
  }

  export type LikeNotificationUpdateWithWhereUniqueWithoutBlogInput = {
    where: LikeNotificationWhereUniqueInput
    data: XOR<LikeNotificationUpdateWithoutBlogInput, LikeNotificationUncheckedUpdateWithoutBlogInput>
  }

  export type LikeNotificationUpdateManyWithWhereWithoutBlogInput = {
    where: LikeNotificationScalarWhereInput
    data: XOR<LikeNotificationUpdateManyMutationInput, LikeNotificationUncheckedUpdateManyWithoutBlogInput>
  }

  export type BlogCreateWithoutDislikesInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: BlogLikeCreateNestedManyWithoutBlogInput
    reports?: ReportBlogCreateNestedManyWithoutBlogInput
    user: UserCreateNestedOneWithoutBlogsInput
    comments?: CommentCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogCreateNestedManyWithoutBlogInput
    topics?: TopicCreateNestedManyWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutDislikesInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: BlogLikeUncheckedCreateNestedManyWithoutBlogInput
    reports?: ReportBlogUncheckedCreateNestedManyWithoutBlogInput
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogUncheckedCreateNestedManyWithoutBlogInput
    topics?: TopicUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type BlogCreateOrConnectWithoutDislikesInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutDislikesInput, BlogUncheckedCreateWithoutDislikesInput>
  }

  export type UserCreateWithoutBlogDisLikesInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogDisLikesInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogDisLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogDisLikesInput, UserUncheckedCreateWithoutBlogDisLikesInput>
  }

  export type BlogUpsertWithoutDislikesInput = {
    update: XOR<BlogUpdateWithoutDislikesInput, BlogUncheckedUpdateWithoutDislikesInput>
    create: XOR<BlogCreateWithoutDislikesInput, BlogUncheckedCreateWithoutDislikesInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutDislikesInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutDislikesInput, BlogUncheckedUpdateWithoutDislikesInput>
  }

  export type BlogUpdateWithoutDislikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BlogLikeUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUpdateManyWithoutBlogNestedInput
    user?: UserUpdateOneRequiredWithoutBlogsNestedInput
    comments?: CommentUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUpdateManyWithoutBlogNestedInput
    topics?: TopicUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutDislikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BlogLikeUncheckedUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUncheckedUpdateManyWithoutBlogNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUncheckedUpdateManyWithoutBlogNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBlogsNestedInput
  }

  export type UserUpsertWithoutBlogDisLikesInput = {
    update: XOR<UserUpdateWithoutBlogDisLikesInput, UserUncheckedUpdateWithoutBlogDisLikesInput>
    create: XOR<UserCreateWithoutBlogDisLikesInput, UserUncheckedCreateWithoutBlogDisLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogDisLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogDisLikesInput, UserUncheckedUpdateWithoutBlogDisLikesInput>
  }

  export type UserUpdateWithoutBlogDisLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogDisLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCreateWithoutTopicsInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeCreateNestedManyWithoutBlogInput
    likes?: BlogLikeCreateNestedManyWithoutBlogInput
    reports?: ReportBlogCreateNestedManyWithoutBlogInput
    user: UserCreateNestedOneWithoutBlogsInput
    comments?: CommentCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutTopicsInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput
    likes?: BlogLikeUncheckedCreateNestedManyWithoutBlogInput
    reports?: ReportBlogUncheckedCreateNestedManyWithoutBlogInput
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutTopicsInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutTopicsInput, BlogUncheckedCreateWithoutTopicsInput>
  }

  export type BlogUpsertWithWhereUniqueWithoutTopicsInput = {
    where: BlogWhereUniqueInput
    update: XOR<BlogUpdateWithoutTopicsInput, BlogUncheckedUpdateWithoutTopicsInput>
    create: XOR<BlogCreateWithoutTopicsInput, BlogUncheckedCreateWithoutTopicsInput>
  }

  export type BlogUpdateWithWhereUniqueWithoutTopicsInput = {
    where: BlogWhereUniqueInput
    data: XOR<BlogUpdateWithoutTopicsInput, BlogUncheckedUpdateWithoutTopicsInput>
  }

  export type BlogUpdateManyWithWhereWithoutTopicsInput = {
    where: BlogScalarWhereInput
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyWithoutTopicsInput>
  }

  export type UserCreateWithoutFollowingsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowingsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserUpsertWithoutFollowingsInput = {
    update: XOR<UserUpdateWithoutFollowingsInput, UserUncheckedUpdateWithoutFollowingsInput>
    create: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingsInput, UserUncheckedUpdateWithoutFollowingsInput>
  }

  export type UserUpdateWithoutFollowingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DisLikeCommentCreateWithoutCommentInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDisLikeCommentsInput
  }

  export type DisLikeCommentUncheckedCreateWithoutCommentInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type DisLikeCommentCreateOrConnectWithoutCommentInput = {
    where: DisLikeCommentWhereUniqueInput
    create: XOR<DisLikeCommentCreateWithoutCommentInput, DisLikeCommentUncheckedCreateWithoutCommentInput>
  }

  export type DisLikeCommentCreateManyCommentInputEnvelope = {
    data: DisLikeCommentCreateManyCommentInput | DisLikeCommentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type LikeCommentCreateWithoutCommentInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikeCommentsInput
  }

  export type LikeCommentUncheckedCreateWithoutCommentInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type LikeCommentCreateOrConnectWithoutCommentInput = {
    where: LikeCommentWhereUniqueInput
    create: XOR<LikeCommentCreateWithoutCommentInput, LikeCommentUncheckedCreateWithoutCommentInput>
  }

  export type LikeCommentCreateManyCommentInputEnvelope = {
    data: LikeCommentCreateManyCommentInput | LikeCommentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommentNotificationCreateWithoutCommentInput = {
    id?: string
    isSeen?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentNotificationsInput
  }

  export type CommentNotificationUncheckedCreateWithoutCommentInput = {
    id?: string
    userID: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type CommentNotificationCreateOrConnectWithoutCommentInput = {
    where: CommentNotificationWhereUniqueInput
    create: XOR<CommentNotificationCreateWithoutCommentInput, CommentNotificationUncheckedCreateWithoutCommentInput>
  }

  export type CommentNotificationCreateManyCommentInputEnvelope = {
    data: CommentNotificationCreateManyCommentInput | CommentNotificationCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommentReplyCreateWithoutCommentInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentRepliesInput
  }

  export type CommentReplyUncheckedCreateWithoutCommentInput = {
    id?: string
    userID: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentReplyCreateOrConnectWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    create: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput>
  }

  export type CommentReplyCreateManyCommentInputEnvelope = {
    data: CommentReplyCreateManyCommentInput | CommentReplyCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type BlogCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeCreateNestedManyWithoutBlogInput
    likes?: BlogLikeCreateNestedManyWithoutBlogInput
    reports?: ReportBlogCreateNestedManyWithoutBlogInput
    user: UserCreateNestedOneWithoutBlogsInput
    readHistories?: ReadHistoryCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogCreateNestedManyWithoutBlogInput
    topics?: TopicCreateNestedManyWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutCommentsInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput
    likes?: BlogLikeUncheckedCreateNestedManyWithoutBlogInput
    reports?: ReportBlogUncheckedCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogUncheckedCreateNestedManyWithoutBlogInput
    topics?: TopicUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type BlogCreateOrConnectWithoutCommentsInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutCommentsInput, BlogUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type DisLikeCommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: DisLikeCommentWhereUniqueInput
    update: XOR<DisLikeCommentUpdateWithoutCommentInput, DisLikeCommentUncheckedUpdateWithoutCommentInput>
    create: XOR<DisLikeCommentCreateWithoutCommentInput, DisLikeCommentUncheckedCreateWithoutCommentInput>
  }

  export type DisLikeCommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: DisLikeCommentWhereUniqueInput
    data: XOR<DisLikeCommentUpdateWithoutCommentInput, DisLikeCommentUncheckedUpdateWithoutCommentInput>
  }

  export type DisLikeCommentUpdateManyWithWhereWithoutCommentInput = {
    where: DisLikeCommentScalarWhereInput
    data: XOR<DisLikeCommentUpdateManyMutationInput, DisLikeCommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type LikeCommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: LikeCommentWhereUniqueInput
    update: XOR<LikeCommentUpdateWithoutCommentInput, LikeCommentUncheckedUpdateWithoutCommentInput>
    create: XOR<LikeCommentCreateWithoutCommentInput, LikeCommentUncheckedCreateWithoutCommentInput>
  }

  export type LikeCommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: LikeCommentWhereUniqueInput
    data: XOR<LikeCommentUpdateWithoutCommentInput, LikeCommentUncheckedUpdateWithoutCommentInput>
  }

  export type LikeCommentUpdateManyWithWhereWithoutCommentInput = {
    where: LikeCommentScalarWhereInput
    data: XOR<LikeCommentUpdateManyMutationInput, LikeCommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentNotificationUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentNotificationWhereUniqueInput
    update: XOR<CommentNotificationUpdateWithoutCommentInput, CommentNotificationUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentNotificationCreateWithoutCommentInput, CommentNotificationUncheckedCreateWithoutCommentInput>
  }

  export type CommentNotificationUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentNotificationWhereUniqueInput
    data: XOR<CommentNotificationUpdateWithoutCommentInput, CommentNotificationUncheckedUpdateWithoutCommentInput>
  }

  export type CommentNotificationUpdateManyWithWhereWithoutCommentInput = {
    where: CommentNotificationScalarWhereInput
    data: XOR<CommentNotificationUpdateManyMutationInput, CommentNotificationUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentReplyUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    update: XOR<CommentReplyUpdateWithoutCommentInput, CommentReplyUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput>
  }

  export type CommentReplyUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    data: XOR<CommentReplyUpdateWithoutCommentInput, CommentReplyUncheckedUpdateWithoutCommentInput>
  }

  export type CommentReplyUpdateManyWithWhereWithoutCommentInput = {
    where: CommentReplyScalarWhereInput
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyWithoutCommentInput>
  }

  export type BlogUpsertWithoutCommentsInput = {
    update: XOR<BlogUpdateWithoutCommentsInput, BlogUncheckedUpdateWithoutCommentsInput>
    create: XOR<BlogCreateWithoutCommentsInput, BlogUncheckedCreateWithoutCommentsInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutCommentsInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutCommentsInput, BlogUncheckedUpdateWithoutCommentsInput>
  }

  export type BlogUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUpdateManyWithoutBlogNestedInput
    user?: UserUpdateOneRequiredWithoutBlogsNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUpdateManyWithoutBlogNestedInput
    topics?: TopicUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUncheckedUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUncheckedUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUncheckedUpdateManyWithoutBlogNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBlogsNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutLikeCommentsInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    blog: BlogCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutLikeCommentsInput = {
    id?: string
    userID: string
    blogId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutLikeCommentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutLikeCommentsInput, CommentUncheckedCreateWithoutLikeCommentsInput>
  }

  export type UserCreateWithoutLikeCommentsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikeCommentsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikeCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikeCommentsInput, UserUncheckedCreateWithoutLikeCommentsInput>
  }

  export type CommentUpsertWithoutLikeCommentsInput = {
    update: XOR<CommentUpdateWithoutLikeCommentsInput, CommentUncheckedUpdateWithoutLikeCommentsInput>
    create: XOR<CommentCreateWithoutLikeCommentsInput, CommentUncheckedCreateWithoutLikeCommentsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutLikeCommentsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutLikeCommentsInput, CommentUncheckedUpdateWithoutLikeCommentsInput>
  }

  export type CommentUpdateWithoutLikeCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    blog?: BlogUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutLikeCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UserUpsertWithoutLikeCommentsInput = {
    update: XOR<UserUpdateWithoutLikeCommentsInput, UserUncheckedUpdateWithoutLikeCommentsInput>
    create: XOR<UserCreateWithoutLikeCommentsInput, UserUncheckedCreateWithoutLikeCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikeCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikeCommentsInput, UserUncheckedUpdateWithoutLikeCommentsInput>
  }

  export type UserUpdateWithoutLikeCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikeCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutDisLikeCommentsInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likeComments?: LikeCommentCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    blog: BlogCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutDisLikeCommentsInput = {
    id?: string
    userID: string
    blogId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutDisLikeCommentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutDisLikeCommentsInput, CommentUncheckedCreateWithoutDisLikeCommentsInput>
  }

  export type UserCreateWithoutDisLikeCommentsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDisLikeCommentsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDisLikeCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisLikeCommentsInput, UserUncheckedCreateWithoutDisLikeCommentsInput>
  }

  export type CommentUpsertWithoutDisLikeCommentsInput = {
    update: XOR<CommentUpdateWithoutDisLikeCommentsInput, CommentUncheckedUpdateWithoutDisLikeCommentsInput>
    create: XOR<CommentCreateWithoutDisLikeCommentsInput, CommentUncheckedCreateWithoutDisLikeCommentsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutDisLikeCommentsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutDisLikeCommentsInput, CommentUncheckedUpdateWithoutDisLikeCommentsInput>
  }

  export type CommentUpdateWithoutDisLikeCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likeComments?: LikeCommentUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    blog?: BlogUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutDisLikeCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likeComments?: LikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UserUpsertWithoutDisLikeCommentsInput = {
    update: XOR<UserUpdateWithoutDisLikeCommentsInput, UserUncheckedUpdateWithoutDisLikeCommentsInput>
    create: XOR<UserCreateWithoutDisLikeCommentsInput, UserUncheckedCreateWithoutDisLikeCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisLikeCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisLikeCommentsInput, UserUncheckedUpdateWithoutDisLikeCommentsInput>
  }

  export type UserUpdateWithoutDisLikeCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDisLikeCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutCommentInput
    blog: BlogCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    userID: string
    blogId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutCommentInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type UserCreateWithoutCommentRepliesInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentRepliesInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentRepliesInput, UserUncheckedCreateWithoutCommentRepliesInput>
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutCommentNestedInput
    blog?: BlogUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UserUpsertWithoutCommentRepliesInput = {
    update: XOR<UserUpdateWithoutCommentRepliesInput, UserUncheckedUpdateWithoutCommentRepliesInput>
    create: XOR<UserCreateWithoutCommentRepliesInput, UserUncheckedCreateWithoutCommentRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentRepliesInput, UserUncheckedUpdateWithoutCommentRepliesInput>
  }

  export type UserUpdateWithoutCommentRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCreateWithoutSavedByInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeCreateNestedManyWithoutBlogInput
    likes?: BlogLikeCreateNestedManyWithoutBlogInput
    reports?: ReportBlogCreateNestedManyWithoutBlogInput
    user: UserCreateNestedOneWithoutBlogsInput
    comments?: CommentCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryCreateNestedManyWithoutBlogInput
    topics?: TopicCreateNestedManyWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutSavedByInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput
    likes?: BlogLikeUncheckedCreateNestedManyWithoutBlogInput
    reports?: ReportBlogUncheckedCreateNestedManyWithoutBlogInput
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutBlogInput
    topics?: TopicUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type BlogCreateOrConnectWithoutSavedByInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutSavedByInput, BlogUncheckedCreateWithoutSavedByInput>
  }

  export type UserCreateWithoutSavedBlogsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedBlogsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedBlogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedBlogsInput, UserUncheckedCreateWithoutSavedBlogsInput>
  }

  export type BlogUpsertWithoutSavedByInput = {
    update: XOR<BlogUpdateWithoutSavedByInput, BlogUncheckedUpdateWithoutSavedByInput>
    create: XOR<BlogCreateWithoutSavedByInput, BlogUncheckedCreateWithoutSavedByInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutSavedByInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutSavedByInput, BlogUncheckedUpdateWithoutSavedByInput>
  }

  export type BlogUpdateWithoutSavedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUpdateManyWithoutBlogNestedInput
    user?: UserUpdateOneRequiredWithoutBlogsNestedInput
    comments?: CommentUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutBlogNestedInput
    topics?: TopicUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutSavedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUncheckedUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUncheckedUpdateManyWithoutBlogNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBlogsNestedInput
  }

  export type UserUpsertWithoutSavedBlogsInput = {
    update: XOR<UserUpdateWithoutSavedBlogsInput, UserUncheckedUpdateWithoutSavedBlogsInput>
    create: XOR<UserCreateWithoutSavedBlogsInput, UserUncheckedCreateWithoutSavedBlogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedBlogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedBlogsInput, UserUncheckedUpdateWithoutSavedBlogsInput>
  }

  export type UserUpdateWithoutSavedBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMembershipInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput>
  }

  export type UserUpsertWithoutMembershipInput = {
    update: XOR<UserUpdateWithoutMembershipInput, UserUncheckedUpdateWithoutMembershipInput>
    create: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipInput, UserUncheckedUpdateWithoutMembershipInput>
  }

  export type UserUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogCreateWithoutReportsInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeCreateNestedManyWithoutBlogInput
    likes?: BlogLikeCreateNestedManyWithoutBlogInput
    user: UserCreateNestedOneWithoutBlogsInput
    comments?: CommentCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogCreateNestedManyWithoutBlogInput
    topics?: TopicCreateNestedManyWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutReportsInput = {
    id?: string
    userID: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: BlogDisLikeUncheckedCreateNestedManyWithoutBlogInput
    likes?: BlogLikeUncheckedCreateNestedManyWithoutBlogInput
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutBlogInput
    savedBy?: SavedBlogUncheckedCreateNestedManyWithoutBlogInput
    topics?: TopicUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type BlogCreateOrConnectWithoutReportsInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutReportsInput, BlogUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReportedBlogsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportedBlogsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportedBlogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedBlogsInput, UserUncheckedCreateWithoutReportedBlogsInput>
  }

  export type BlogUpsertWithoutReportsInput = {
    update: XOR<BlogUpdateWithoutReportsInput, BlogUncheckedUpdateWithoutReportsInput>
    create: XOR<BlogCreateWithoutReportsInput, BlogUncheckedCreateWithoutReportsInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutReportsInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutReportsInput, BlogUncheckedUpdateWithoutReportsInput>
  }

  export type BlogUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUpdateManyWithoutBlogNestedInput
    user?: UserUpdateOneRequiredWithoutBlogsNestedInput
    comments?: CommentUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUpdateManyWithoutBlogNestedInput
    topics?: TopicUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUncheckedUpdateManyWithoutBlogNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUncheckedUpdateManyWithoutBlogNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBlogsNestedInput
  }

  export type UserUpsertWithoutReportedBlogsInput = {
    update: XOR<UserUpdateWithoutReportedBlogsInput, UserUncheckedUpdateWithoutReportedBlogsInput>
    create: XOR<UserCreateWithoutReportedBlogsInput, UserUncheckedCreateWithoutReportedBlogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedBlogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedBlogsInput, UserUncheckedUpdateWithoutReportedBlogsInput>
  }

  export type UserUpdateWithoutReportedBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutCommentNotificationsInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentCreateNestedManyWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    blog: BlogCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutCommentNotificationsInput = {
    id?: string
    userID: string
    blogId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutCommentInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutCommentNotificationsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCommentNotificationsInput, CommentUncheckedCreateWithoutCommentNotificationsInput>
  }

  export type UserCreateWithoutCommentNotificationsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentNotificationsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentNotificationsInput, UserUncheckedCreateWithoutCommentNotificationsInput>
  }

  export type CommentUpsertWithoutCommentNotificationsInput = {
    update: XOR<CommentUpdateWithoutCommentNotificationsInput, CommentUncheckedUpdateWithoutCommentNotificationsInput>
    create: XOR<CommentCreateWithoutCommentNotificationsInput, CommentUncheckedCreateWithoutCommentNotificationsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutCommentNotificationsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutCommentNotificationsInput, CommentUncheckedUpdateWithoutCommentNotificationsInput>
  }

  export type CommentUpdateWithoutCommentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    blog?: BlogUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutCommentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UserUpsertWithoutCommentNotificationsInput = {
    update: XOR<UserUpdateWithoutCommentNotificationsInput, UserUncheckedUpdateWithoutCommentNotificationsInput>
    create: XOR<UserCreateWithoutCommentNotificationsInput, UserUncheckedCreateWithoutCommentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentNotificationsInput, UserUncheckedUpdateWithoutCommentNotificationsInput>
  }

  export type UserUpdateWithoutCommentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMessageNotificationsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageNotificationsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageNotificationsInput, UserUncheckedCreateWithoutMessageNotificationsInput>
  }

  export type UserUpsertWithoutMessageNotificationsInput = {
    update: XOR<UserUpdateWithoutMessageNotificationsInput, UserUncheckedUpdateWithoutMessageNotificationsInput>
    create: XOR<UserCreateWithoutMessageNotificationsInput, UserUncheckedCreateWithoutMessageNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageNotificationsInput, UserUncheckedUpdateWithoutMessageNotificationsInput>
  }

  export type UserUpdateWithoutMessageNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogLikeCreateWithoutLikeNotificationsInput = {
    id?: string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutBlogLikesInput
  }

  export type BlogLikeUncheckedCreateWithoutLikeNotificationsInput = {
    id?: string
    userID: string
    blogID: string
    createdAt?: Date | string
  }

  export type BlogLikeCreateOrConnectWithoutLikeNotificationsInput = {
    where: BlogLikeWhereUniqueInput
    create: XOR<BlogLikeCreateWithoutLikeNotificationsInput, BlogLikeUncheckedCreateWithoutLikeNotificationsInput>
  }

  export type UserCreateWithoutLikeNotificationsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikeNotificationsInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikeNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikeNotificationsInput, UserUncheckedCreateWithoutLikeNotificationsInput>
  }

  export type BlogLikeUpsertWithoutLikeNotificationsInput = {
    update: XOR<BlogLikeUpdateWithoutLikeNotificationsInput, BlogLikeUncheckedUpdateWithoutLikeNotificationsInput>
    create: XOR<BlogLikeCreateWithoutLikeNotificationsInput, BlogLikeUncheckedCreateWithoutLikeNotificationsInput>
    where?: BlogLikeWhereInput
  }

  export type BlogLikeUpdateToOneWithWhereWithoutLikeNotificationsInput = {
    where?: BlogLikeWhereInput
    data: XOR<BlogLikeUpdateWithoutLikeNotificationsInput, BlogLikeUncheckedUpdateWithoutLikeNotificationsInput>
  }

  export type BlogLikeUpdateWithoutLikeNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutBlogLikesNestedInput
  }

  export type BlogLikeUncheckedUpdateWithoutLikeNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutLikeNotificationsInput = {
    update: XOR<UserUpdateWithoutLikeNotificationsInput, UserUncheckedUpdateWithoutLikeNotificationsInput>
    create: XOR<UserCreateWithoutLikeNotificationsInput, UserUncheckedCreateWithoutLikeNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikeNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikeNotificationsInput, UserUncheckedUpdateWithoutLikeNotificationsInput>
  }

  export type UserUpdateWithoutLikeNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikeNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInboxes_inboxes_receiverIDTousersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_senderIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInboxes_inboxes_receiverIDTousersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_senderIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInboxes_inboxes_receiverIDTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInboxes_inboxes_receiverIDTousersInput, UserUncheckedCreateWithoutInboxes_inboxes_receiverIDTousersInput>
  }

  export type UserCreateWithoutInboxes_inboxes_senderIDTousersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogCreateNestedManyWithoutUserInput
    blogs?: BlogCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    followings?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    likeNotifications?: LikeNotificationCreateNestedManyWithoutUserInput
    membership?: MembershipCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInboxes_inboxes_senderIDTousersInput = {
    id?: string
    email: string
    name: string
    age?: number | null
    about?: string | null
    experience?: number | null
    interests?: UserCreateinterestsInput | string[]
    field?: string | null
    password?: string | null
    shortBio?: string | null
    profilePhoto?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blockedByUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutUserInput
    blogDisLikes?: BlogDisLikeUncheckedCreateNestedManyWithoutUserInput
    blogLikes?: BlogLikeUncheckedCreateNestedManyWithoutUserInput
    reportedBlogs?: ReportBlogUncheckedCreateNestedManyWithoutUserInput
    blogs?: BlogUncheckedCreateNestedManyWithoutUserInput
    disLikeComments?: DisLikeCommentUncheckedCreateNestedManyWithoutUserInput
    likeComments?: LikeCommentUncheckedCreateNestedManyWithoutUserInput
    commentNotifications?: CommentNotificationUncheckedCreateNestedManyWithoutUserInput
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedCreateNestedManyWithoutUsers_inboxes_receiverIDTousersInput
    likeNotifications?: LikeNotificationUncheckedCreateNestedManyWithoutUserInput
    membership?: MembershipUncheckedCreateNestedOneWithoutUserInput
    messageNotifications?: MessageNotificationUncheckedCreateNestedManyWithoutReceiverInput
    readHistories?: ReadHistoryUncheckedCreateNestedManyWithoutUserInput
    reportedUsers?: ReportUserUncheckedCreateNestedManyWithoutReportedUserInput
    usersReported?: ReportUserUncheckedCreateNestedManyWithoutUserInput
    savedBlogs?: SavedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInboxes_inboxes_senderIDTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInboxes_inboxes_senderIDTousersInput, UserUncheckedCreateWithoutInboxes_inboxes_senderIDTousersInput>
  }

  export type UserUpsertWithoutInboxes_inboxes_receiverIDTousersInput = {
    update: XOR<UserUpdateWithoutInboxes_inboxes_receiverIDTousersInput, UserUncheckedUpdateWithoutInboxes_inboxes_receiverIDTousersInput>
    create: XOR<UserCreateWithoutInboxes_inboxes_receiverIDTousersInput, UserUncheckedCreateWithoutInboxes_inboxes_receiverIDTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInboxes_inboxes_receiverIDTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInboxes_inboxes_receiverIDTousersInput, UserUncheckedUpdateWithoutInboxes_inboxes_receiverIDTousersInput>
  }

  export type UserUpdateWithoutInboxes_inboxes_receiverIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInboxes_inboxes_receiverIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_senderIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutInboxes_inboxes_senderIDTousersInput = {
    update: XOR<UserUpdateWithoutInboxes_inboxes_senderIDTousersInput, UserUncheckedUpdateWithoutInboxes_inboxes_senderIDTousersInput>
    create: XOR<UserCreateWithoutInboxes_inboxes_senderIDTousersInput, UserUncheckedCreateWithoutInboxes_inboxes_senderIDTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInboxes_inboxes_senderIDTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInboxes_inboxes_senderIDTousersInput, UserUncheckedUpdateWithoutInboxes_inboxes_senderIDTousersInput>
  }

  export type UserUpdateWithoutInboxes_inboxes_senderIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUpdateManyWithoutUserNestedInput
    blogs?: BlogUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    followings?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutUserNestedInput
    membership?: MembershipUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInboxes_inboxes_senderIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    field?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    shortBio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedByUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutUserNestedInput
    blogDisLikes?: BlogDisLikeUncheckedUpdateManyWithoutUserNestedInput
    blogLikes?: BlogLikeUncheckedUpdateManyWithoutUserNestedInput
    reportedBlogs?: ReportBlogUncheckedUpdateManyWithoutUserNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutUserNestedInput
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutUserNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutUserNestedInput
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    inboxes_inboxes_receiverIDTousers?: inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersNestedInput
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutUserNestedInput
    membership?: MembershipUncheckedUpdateOneWithoutUserNestedInput
    messageNotifications?: MessageNotificationUncheckedUpdateManyWithoutReceiverNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutUserNestedInput
    reportedUsers?: ReportUserUncheckedUpdateManyWithoutReportedUserNestedInput
    usersReported?: ReportUserUncheckedUpdateManyWithoutUserNestedInput
    savedBlogs?: SavedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlockedUserCreateManyBlockedUserInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type BlockedUserCreateManyUserInput = {
    id?: string
    blockedID: string
    createdAt?: Date | string
  }

  export type BlogDisLikeCreateManyUserInput = {
    id?: string
    blogID: string
    createdAt?: Date | string
  }

  export type BlogLikeCreateManyUserInput = {
    id?: string
    blogID: string
    createdAt?: Date | string
  }

  export type ReportBlogCreateManyUserInput = {
    id?: string
    blogID: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
  }

  export type BlogCreateManyUserInput = {
    id?: string
    title: string
    content: string
    thumbnail?: string | null
    isMemberOnly?: boolean
    isPublished?: boolean
    viewCount?: number
    readCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisLikeCommentCreateManyUserInput = {
    id?: string
    commentID: string
    createdAt?: Date | string
  }

  export type LikeCommentCreateManyUserInput = {
    id?: string
    commentID: string
    createdAt?: Date | string
  }

  export type CommentNotificationCreateManyUserInput = {
    id?: string
    commentID: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type CommentReplyCreateManyUserInput = {
    id?: string
    commentID: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    blogId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingID: string
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerID: string
    createdAt?: Date | string
  }

  export type inboxesCreateManyUsers_inboxes_receiverIDTousersInput = {
    id: string
    senderID: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type inboxesCreateManyUsers_inboxes_senderIDTousersInput = {
    id: string
    receiverID: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LikeNotificationCreateManyUserInput = {
    id?: string
    isSeen?: boolean
    blogLikedId: string
    createdAt?: Date | string
  }

  export type MessageNotificationCreateManyReceiverInput = {
    id?: string
    senderID: string
    message: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type ReadHistoryCreateManyUserInput = {
    id?: string
    blogId: string
    createdAt?: Date | string
  }

  export type ReportUserCreateManyReportedUserInput = {
    id?: string
    userID: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReportUserCreateManyUserInput = {
    id?: string
    reportedID: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type SavedBlogCreateManyUserInput = {
    id?: string
    blogID: string
    createdAt?: Date | string
  }

  export type BlockedUserUpdateWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlockedUsersNestedInput
  }

  export type BlockedUserUncheckedUpdateWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedUser?: UserUpdateOneRequiredWithoutBlockedByUsersNestedInput
  }

  export type BlockedUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogDisLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutDislikesNestedInput
  }

  export type BlogDisLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogDisLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutLikesNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutBlogNestedInput
  }

  export type BlogLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportBlogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportBlogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportBlogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUpdateManyWithoutBlogNestedInput
    comments?: CommentUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUpdateManyWithoutBlogNestedInput
    topics?: TopicUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUncheckedUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUncheckedUpdateManyWithoutBlogNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUncheckedUpdateManyWithoutBlogNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisLikeCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutDisLikeCommentsNestedInput
  }

  export type DisLikeCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisLikeCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutLikeCommentsNestedInput
  }

  export type LikeCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutCommentNotificationsNestedInput
  }

  export type CommentNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type CommentReplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReplyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    blog?: BlogUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingsNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inboxesUpdateWithoutUsers_inboxes_receiverIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_inboxes_senderIDTousers?: UserUpdateOneRequiredWithoutInboxes_inboxes_senderIDTousersNestedInput
  }

  export type inboxesUncheckedUpdateWithoutUsers_inboxes_receiverIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inboxesUncheckedUpdateManyWithoutUsers_inboxes_receiverIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inboxesUpdateWithoutUsers_inboxes_senderIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_inboxes_receiverIDTousers?: UserUpdateOneRequiredWithoutInboxes_inboxes_receiverIDTousersNestedInput
  }

  export type inboxesUncheckedUpdateWithoutUsers_inboxes_senderIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inboxesUncheckedUpdateManyWithoutUsers_inboxes_senderIDTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogLikeUpdateOneRequiredWithoutLikeNotificationsNestedInput
  }

  export type LikeNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    blogLikedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    blogLikedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageNotificationUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageNotificationUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageNotificationUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutReadHistoriesNestedInput
  }

  export type ReadHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsersReportedNestedInput
  }

  export type ReportUserUncheckedUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserUncheckedUpdateManyWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUser?: UserUpdateOneRequiredWithoutReportedUsersNestedInput
  }

  export type ReportUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportedID?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportedID?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedBlogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutSavedByNestedInput
  }

  export type SavedBlogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedBlogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogDisLikeCreateManyBlogInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type BlogLikeCreateManyBlogInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type ReportBlogCreateManyBlogInput = {
    id?: string
    userID: string
    type: $Enums.ReportMessage
    message?: string | null
    createdAt?: Date | string
  }

  export type CommentCreateManyBlogInput = {
    id?: string
    userID: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReadHistoryCreateManyBlogInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type SavedBlogCreateManyBlogInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type BlogDisLikeUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogDisLikesNestedInput
  }

  export type BlogDisLikeUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogDisLikeUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogLikeUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogLikesNestedInput
    likeNotifications?: LikeNotificationUpdateManyWithoutBlogNestedInput
  }

  export type BlogLikeUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likeNotifications?: LikeNotificationUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogLikeUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportBlogUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportedBlogsNestedInput
  }

  export type ReportBlogUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportBlogUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    type?: EnumReportMessageFieldUpdateOperationsInput | $Enums.ReportMessage
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disLikeComments?: DisLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    likeComments?: LikeCommentUncheckedUpdateManyWithoutCommentNestedInput
    commentNotifications?: CommentNotificationUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadHistoryUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadHistoriesNestedInput
  }

  export type ReadHistoryUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadHistoryUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedBlogUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedBlogsNestedInput
  }

  export type SavedBlogUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedBlogUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateManyWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type LikeNotificationCreateManyBlogInput = {
    id?: string
    userID: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type LikeNotificationUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikeNotificationsNestedInput
  }

  export type LikeNotificationUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeNotificationUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUpdateManyWithoutBlogNestedInput
    user?: UserUpdateOneRequiredWithoutBlogsNestedInput
    comments?: CommentUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: BlogDisLikeUncheckedUpdateManyWithoutBlogNestedInput
    likes?: BlogLikeUncheckedUpdateManyWithoutBlogNestedInput
    reports?: ReportBlogUncheckedUpdateManyWithoutBlogNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    readHistories?: ReadHistoryUncheckedUpdateManyWithoutBlogNestedInput
    savedBy?: SavedBlogUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateManyWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberOnly?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisLikeCommentCreateManyCommentInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type LikeCommentCreateManyCommentInput = {
    id?: string
    userID: string
    createdAt?: Date | string
  }

  export type CommentNotificationCreateManyCommentInput = {
    id?: string
    userID: string
    isSeen?: boolean
    createdAt?: Date | string
  }

  export type CommentReplyCreateManyCommentInput = {
    id?: string
    userID: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisLikeCommentUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDisLikeCommentsNestedInput
  }

  export type DisLikeCommentUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisLikeCommentUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCommentUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikeCommentsNestedInput
  }

  export type LikeCommentUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCommentUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentNotificationUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentNotificationsNestedInput
  }

  export type CommentNotificationUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentNotificationUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReplyUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentRepliesNestedInput
  }

  export type CommentReplyUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReplyUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}